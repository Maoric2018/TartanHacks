<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NEON PHASES</title><style>*{margin:0;padding:0;box-sizing:border-box}body{background:#000;overflow:hidden;user-select:none}canvas{display:block;cursor:crosshair}</style></head><body><canvas id="c"></canvas><script>"use strict";
(()=>{var VJ={playerSpeed:240,playerHP:10,playerR:12,invulnDur:0.8,trailAlpha:0.18,maxEnemies:50,maxEBullets:900,maxPBullets:150,maxParticles:500,chunkSize:500,cullDist:1400};function e(J,$){return J+Math.random()*($-J)}function UJ(J,$){return J+Math.random()*($-J+1)|0}function RJ(){return Math.random()*Math.PI*2}function NJ(J){return J[Math.random()*J.length|0]}var G=Math.PI,v=G*2,{cos:I,sin:F,sqrt:b,abs:GJ,min:r,max:B,atan2:k,floor:qJ}=Math;function W(J,$,Q){return J<$?$:J>Q?Q:J}function x(J,$,Q){return J+($-J)*Q}function A(J,$,Q,V){return b((J-Q)**2+($-V)**2)}function dJ(J,$,Q,V,K,q){let z=K-Q,R=q-V,M=z*z+R*R;if(M<=0.000001)return A(J,$,Q,V);let L=W(((J-Q)*z+($-V)*R)/M,0,1),_=Q+z*L,H=V+R*L;return A(J,$,_,H)}function DZ(J){while(J>G)J-=v;while(J<-G)J+=v;return J}var lJ=document.getElementById("c"),Z=lJ.getContext("2d"),g,l,X,P,nJ,c={x:0,y:0};function YZ(){nJ=devicePixelRatio||1,g=innerWidth,l=innerHeight,lJ.width=g*nJ,lJ.height=l*nJ,lJ.style.width=g+"px",lJ.style.height=l+"px",Z.setTransform(nJ,0,0,nJ,0,0),X=g/2,P=l/2}addEventListener("resize",YZ);YZ();var vZ=new Set,wJ=X,oJ=P,s=null,VZ=!1,KZ=!1;addEventListener("keyup",(J)=>vZ.delete(J.code));addEventListener("mousemove",(J)=>{wJ=J.clientX,oJ=J.clientY});addEventListener("mousedown",(J)=>{if(J.button===0)VZ=!0;if(J.button===2)KZ=!0;s={x:J.clientX,y:J.clientY,btn:J.button}});addEventListener("mouseup",(J)=>{if(J.button===0)VZ=!1;if(J.button===2)KZ=!1});addEventListener("contextmenu",(J)=>J.preventDefault());function XJ(J){return vZ.has(J)}function aZ(){let J=0,$=0;if(XJ("KeyW")||XJ("ArrowUp"))$=-1;if(XJ("KeyS")||XJ("ArrowDown"))$=1;if(XJ("KeyA")||XJ("ArrowLeft"))J=-1;if(XJ("KeyD")||XJ("ArrowRight"))J=1;let Q=b(J*J+$*$);return Q>0?{x:J/Q,y:$/Q}:{x:0,y:0}}function NZ(){return{x:wJ-X+c.x,y:oJ-P+c.y}}var d="title",j={time:0,difficulty:0.8,wave:0,waveKills:0,waveQuota:0,waveState:"spawning",wavePhaseIdx:-1,bossEntity:null,xp:0,level:1,xpToNext:160,levelUpQueue:0,totalKills:0,frozen:!1,freezeTimer:0,bannerTimer:0,bannerText:"",bannerColor:"#fff",reflect:!1,gravity:0,windX:0,windY:0,pulseTimer:0,pulseSpeed:0,decay:!1,reversed:!1,reverseTimer:0,reverseCD:0,pierce:!1,echo:!1,weapons:[],passives:{},killFlash:0,waveBannerTimer:0,waveBannerText:"",waveBannerSub:"",waveModTimer:0,waveModText:"",_bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:!1,gameOverFade:0},GZ=0.64,XZ={speed:[["moveSpeed","mul",[1,1.15,1.3,1.4]],["dodgeChance","set",[0,0,0,0.08]]],regen:[["regenInterval","set",[999,14,8,8]]],cooldown:[["cdReduction","set",[0,0.12,0.2,0.25]]],shield:[["shieldRecharge","set",[0,12,8]]],damage:[["dmgMult","mul",[1,1.3,1.5]]]},sZ={dmgMult:"add",moveSpeed:"mul1",xpMult:"add",dodgeChance:"add",cdReduction:"add_cap"};function WZ(J,$,Q){if(Q===void 0)return;if($==="mul")C[J]*=Q;else if($==="mul1")C[J]*=1+Q;else if($==="add")C[J]+=Q;else if($==="add_cap")C[J]=r(0.5,C[J]+Q);else C[J]=Q}var C={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};function gZ(){C.moveSpeed=VJ.playerSpeed,C.critChance=0,C.critMult=2,C.xpMult=1,C.cdReduction=0,C.regenInterval=999,C.dodgeChance=0,C.dmgMult=1,C.shieldRecharge=0;let J=j.passives;for(let Q in XZ){let V=J[Q]|0;if(!V)continue;let K=XZ[Q];for(let q=0;q<K.length;q++){let z=K[q],R=z[2];WZ(z[0],z[1],R[r(V,R.length-1)])}}let $=j._microBuffs;if($)for(let Q in $)WZ(Q,sZ[Q]||"add",$[Q])}var MZ=0,FZ=0,CJ=0,eJ=0,mZ=1;function DJ(J){CJ=B(CJ,J)}function cZ(){if(CJ>0.2)MZ=(Math.random()-0.5)*CJ*2,FZ=(Math.random()-0.5)*CJ*2,CJ*=0.87;else MZ=FZ=CJ=0}function JZ(J,$){eJ=J,mZ=$}function zZ(J,$,Q,V,K){K=K||3,Z.save();for(let q=K;q>0;q--)Z.beginPath(),Z.arc(J,$,Q+q*2.5,0,v),Z.strokeStyle=V,Z.lineWidth=q*2,Z.globalAlpha=0.07,Z.stroke();Z.beginPath(),Z.arc(J,$,Q,0,v),Z.strokeStyle=V,Z.lineWidth=1.5,Z.globalAlpha=1,Z.stroke(),Z.restore()}function tZ(J,$,Q,V){Z.save(),Z.beginPath(),Z.arc(J,$,Q+4,0,v),Z.fillStyle=V,Z.globalAlpha=0.12,Z.fill(),Z.beginPath(),Z.arc(J,$,Q,0,v),Z.fillStyle=V,Z.globalAlpha=0.9,Z.fill(),Z.restore()}function YJ(J,$,Q,V){Q=Q!==!1,V=V||3;function K(){Z.beginPath(),Z.moveTo(J[0].x,J[0].y);for(let q=1;q<J.length;q++)Z.lineTo(J[q].x,J[q].y);if(Q)Z.closePath()}Z.save();for(let q=V;q>0;q--)K(),Z.strokeStyle=$,Z.lineWidth=q*2.5,Z.globalAlpha=0.07,Z.stroke();K(),Z.strokeStyle=$,Z.lineWidth=1.5,Z.globalAlpha=1,Z.stroke(),Z.restore()}function eZ(J,$,Q,V,K,q){Z.save();for(let z=3;z>0;z--)Z.beginPath(),Z.moveTo(J,$),Z.lineTo(Q,V),Z.strokeStyle=K,Z.lineWidth=(q||1.5)+z*2,Z.globalAlpha=0.06,Z.stroke();Z.beginPath(),Z.moveTo(J,$),Z.lineTo(Q,V),Z.strokeStyle=K,Z.lineWidth=q||1.5,Z.globalAlpha=1,Z.stroke(),Z.restore()}function ZZ(J,$,Q,V){let K=[];for(let q=0;q<3;q++){let z=V+v/3*q-G/2;K.push({x:J+I(z)*Q,y:$+F(z)*Q})}return K}function yZ(J,$,Q,V){let K=[];for(let q=0;q<4;q++){let z=V+v/4*q+G/4;K.push({x:J+I(z)*Q,y:$+F(z)*Q})}return K}function f(J,$,Q,V,K,q,z){Z.save(),Z.font="bold "+V+"px monospace",Z.textAlign=q||"left",Z.textBaseline=z||"top",Z.shadowColor=K,Z.shadowBlur=10,Z.fillStyle=K,Z.globalAlpha=0.5,Z.fillText(J,$,Q),Z.shadowBlur=0,Z.globalAlpha=1,Z.fillText(J,$,Q),Z.restore()}function wZ(J,$,Q,V,K,q,z){Z.save();for(let R=3;R>0;R--)Z.beginPath(),Z.arc(J,$,Q,V,K),Z.strokeStyle=q,Z.lineWidth=(z||2)+R*2,Z.globalAlpha=0.06,Z.stroke();Z.beginPath(),Z.arc(J,$,Q,V,K),Z.strokeStyle=q,Z.lineWidth=z||2,Z.globalAlpha=1,Z.stroke(),Z.restore()}function qZ(J,$){let Q=[];for(let V=0;V<J;V++){let K=$();K.active=!1,Q.push(K)}return Q.spawn=function(V){for(let z=0;z<Q.length;z++)if(!Q[z].active)return Q[z].active=!0,V(Q[z]),Q[z];let K=0,q=1/0;for(let z=0;z<Q.length;z++)if(Q[z].spawnTime<q)q=Q[z].spawnTime,K=z;return Q[K].active=!0,V(Q[K]),Q[K]},Q.each=function(V){for(let K=0;K<Q.length;K++)if(Q[K].active)V(Q[K])},Q.count=function(){let V=0;for(let K=0;K<Q.length;K++)if(Q[K].active)V++;return V},Q.clear=function(){for(let V=0;V<Q.length;V++)Q[V].active=!1},Q}function oZ(){return{active:!1,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:"normal",color:"#f44",spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:!1,reflected:!1,echoed:!1,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}function J0(){return{active:!1,x:0,y:0,vx:0,vy:0,life:0,maxLife:0.4,color:"#fff",r:2,spawnTime:0}}function Z0(){return{active:!1,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:"circle",color:"#f44",moveType:"drifter",firePattern:"single",fireTimer:0,fireCD:2,tier:"small",angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},isBoss:!1,bossAI:null,shieldHP:0}}var LJ=qZ(VJ.maxEBullets,oZ),gJ=qZ(VJ.maxPBullets,oZ),jZ=qZ(VJ.maxParticles,J0),m=qZ(VJ.maxEnemies,Z0),PJ=[];function EZ(J,$,Q,V){if(PJ.length>200)return;PJ.push({x:J+(Math.random()-0.5)*20,y:$,vy:-60-Math.random()*30,text:V?Q+"!":""+Q,color:V?"#ff0":"#fff",life:0.6,maxLife:0.6,scale:V?1.4:1})}function $0(J){for(let $=PJ.length-1;$>=0;$--){let Q=PJ[$];if(Q.y+=Q.vy*J,Q.vy+=100*J,Q.life-=J,Q.life<=0)PJ.splice($,1)}}function Q0(){for(let J of PJ){let $=J.life/J.maxLife;Z.save(),Z.globalAlpha=$,Z.font="bold "+12*J.scale+"px monospace",Z.textAlign="center",Z.textBaseline="middle",Z.fillStyle=J.color,Z.shadowColor=J.color,Z.shadowBlur=6,Z.fillText(J.text,J.x,J.y),Z.restore()}}function bJ(J,$,Q,V,K,q,z){jZ.spawn((R)=>{R.x=J,R.y=$,R.vx=Q,R.vy=V,R.color=K,R.life=q||0.4,R.maxLife=q||0.4,R.r=z||2,R.spawnTime=j.time})}function h(J,$,Q,V,K){for(let q=0;q<V;q++){let z=Math.random()*v,R=K*(0.3+Math.random()*0.7);bJ(J,$,I(z)*R,F(z)*R,Q,0.2+Math.random()*0.3,1+Math.random()*2)}}function _Z(J){jZ.each(($)=>{if($.x+=$.vx*J,$.y+=$.vy*J,$.vx*=0.97,$.vy*=0.97,$.life-=J,$.life<=0)$.active=!1})}function IZ(){jZ.each((J)=>{let $=W(J.life/J.maxLife,0,1);Z.save(),Z.globalAlpha=$*0.8,Z.beginPath(),Z.arc(J.x,J.y,J.r*$,0,v),Z.fillStyle=J.color,Z.fill(),Z.restore()})}var yJ=[];function V0(J){for(let $=yJ.length-1;$>=0;$--){let Q=yJ[$];if(Q.life-=J,!Number.isFinite(Q.life)||!Number.isFinite(Q.maxLife)||Q.maxLife<=0||!Number.isFinite(Q.r)||Q.r<=0||!Number.isFinite(Q.dmg)||Q.dmg<=0){yJ.splice($,1);continue}if(!(Q.dmgCD instanceof Map))Q.dmgCD=new Map;if(Q.life<=0){yJ.splice($,1);continue}if(Q._checkT=(Q._checkT||0)-J,Q._checkT>0)continue;Q._checkT=0.15,m.each((V)=>{if(!V.active)return;if(A(Q.x,Q.y,V.x,V.y)<Q.r+V.r){let K=Q.dmgCD.get(V)||0;if(j.time-K>0.25)Q.dmgCD.set(V,j.time),MJ(V,Q.dmg,"trail")}})}}function K0(){for(let J of yJ){let $=W(J.life/J.maxLife,0,1),Q=J.r*(0.6+$*0.4);Z.save();let V=J.x*7+J.y*13|0,K=6+(V&7);for(let q=0;q<K;q++){let z=v/K*q+F(j.time*3+q)*0.4,R=Q*(0.3+(V+q*17)%100/100*0.7),M=J.x+I(z)*R,L=J.y+F(z)*R,_=(1.5+(V+q*31)%100/100*2)*$;Z.beginPath(),Z.arc(M,L,_,0,v),Z.fillStyle=J.color,Z.globalAlpha=$*(0.4+(V+q*7)%100/100*0.4),Z.fill()}Z.beginPath(),Z.arc(J.x,J.y,Q*0.6,0,v),Z.fillStyle=J.color,Z.globalAlpha=$*0.08,Z.fill(),Z.restore()}}var uJ=[],z0=24;function q0(J,$,Q,V,K,q,z){if(uJ.length>=z0)return;if(!Number.isFinite(J)||!Number.isFinite($)||!Number.isFinite(Q)||!Number.isFinite(V))return;let R=Number.isFinite(K)&&K>0?K:30,M=Number.isFinite(q)&&q>0?q:1,L=Number.isFinite(z)&&z>0?z:0.8;uJ.push({x1:J,y1:$,x2:Q,y2:V,width:R,dmg:M,life:L,maxLife:L,tickT:0})}function j0(J){for(let $=uJ.length-1;$>=0;$--){let Q=uJ[$];if(Q.life-=J,Q.life<=0){uJ.splice($,1);continue}if(Q.tickT-=J,Q.tickT>0)continue;Q.tickT=0.08,m.each((V)=>{if(!V.active)return;if(dJ(V.x,V.y,Q.x1,Q.y1,Q.x2,Q.y2)<=Q.width*0.5+V.r){if(!V._swordAfterT||j.time-V._swordAfterT>0.18)V._swordAfterT=j.time,MJ(V,Q.dmg,"sword_aftershock")}})}}function R0(){for(let J of uJ){let $=W(J.life/J.maxLife,0,1),Q=J.x2-J.x1,V=J.y2-J.y1,K=b(Q*Q+V*V)||1,q=Q/K,z=V/K,R=-z,M=q,L=B(6,J.width*(0.7+0.25*$)),_=(J.x1+J.x2)*0.5,H=(J.y1+J.y2)*0.5;Z.save();let O=Z.createLinearGradient(J.x1,J.y1,J.x2,J.y2);O.addColorStop(0,"rgba(255,120,255,0)"),O.addColorStop(0.5,"rgba(255,120,255,"+(0.12+0.18*$)+")"),O.addColorStop(1,"rgba(255,120,255,0)"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.quadraticCurveTo(_+R*L*0.85,H+M*L*0.85,J.x2,J.y2),Z.quadraticCurveTo(_-R*L*0.85,H-M*L*0.85,J.x1,J.y1),Z.closePath(),Z.fillStyle=O,Z.globalAlpha=1,Z.shadowColor="#f0f",Z.shadowBlur=20,Z.fill();let D=Z.createLinearGradient(J.x1,J.y1,J.x2,J.y2);D.addColorStop(0,"rgba(255,255,255,0)"),D.addColorStop(0.5,"rgba(255,255,255,"+(0.18+0.2*$)+")"),D.addColorStop(1,"rgba(255,255,255,0)"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(J.x2,J.y2),Z.strokeStyle=D,Z.lineWidth=B(1.8,L*0.18),Z.lineCap="round",Z.shadowBlur=10,Z.stroke();let Y=5+(j.time*15+J.x1+J.y1|0)%4;for(let U=0;U<Y;U++){let E=(U+0.5)/Y+F(j.time*9+U*1.7)*0.03,T=x(J.x1,J.x2,W(E,0,1)),n=x(J.y1,J.y2,W(E,0,1)),i=F(j.time*14+U*2.2)*(L*0.22),y=T+R*i,a=n+M*i;Z.beginPath(),Z.arc(y,a,1.2+$*2.2,0,v),Z.fillStyle="#f8f",Z.globalAlpha=0.12+0.22*$,Z.fill(),Z.beginPath(),Z.arc(y+R*1.5,a+M*1.5,0.9+$*1.4,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.08+0.18*$,Z.fill()}Z.restore()}}var EJ=[],L0=36;function N0(){let J=!1;return m.each(($)=>{if($.isBoss)J=!0}),J}function M0(J,$){if(EJ.length>=L0)return;let Q=160+32*($.lv.a||0),V=34+8*($.lv.b||0),K=(8+2*($.lv.a||0))*2,q=N.x+I(J)*26,z=N.y+F(J)*26,R=820;EJ.push({x:q,y:z,vx:I(J)*R,vy:F(J)*R,a:J,life:0.55,maxLife:0.55,len:Q,width:V,dmg:K,hitSet:new Set}),h(q,z,"#f6f",7,130)}function F0(J){for(let $=EJ.length-1;$>=0;$--){let Q=EJ[$];if(Q.life-=J,Q.life<=0){EJ.splice($,1);continue}if(Q.x+=Q.vx*J,Q.y+=Q.vy*J,A(N.x,N.y,Q.x,Q.y)>B(g,l)*1.35){EJ.splice($,1);continue}let V=Q.x-I(Q.a)*Q.len*0.25,K=Q.y-F(Q.a)*Q.len*0.25,q=Q.x+I(Q.a)*Q.len*0.75,z=Q.y+F(Q.a)*Q.len*0.75;m.each((R)=>{if(!R.active||!R.isBoss||Q.hitSet.has(R))return;if(dJ(R.x,R.y,V,K,q,z)<=R.r+Q.width*0.45)Q.hitSet.add(R),MJ(R,Q.dmg,"sword_boss_slash"),h(R.x,R.y,"#f8f",9,170)})}}function _0(){for(let J of EJ){let $=W(J.life/J.maxLife,0,1),Q=I(J.a+G/2),V=F(J.a+G/2),K=J.x-I(J.a)*J.len*0.25,q=J.y-F(J.a)*J.len*0.25,z=J.x+I(J.a)*J.len*0.75,R=J.y+F(J.a)*J.len*0.75,M=J.width*(0.8+0.35*$),L=(K+z)*0.5,_=(q+R)*0.5;Z.save();let H=Z.createLinearGradient(K,q,z,R);H.addColorStop(0,"rgba(255,120,255,0)"),H.addColorStop(0.45,"rgba(255,120,255,"+(0.2+0.22*$)+")"),H.addColorStop(1,"rgba(255,255,255,"+(0.1+0.22*$)+")"),Z.beginPath(),Z.moveTo(K,q),Z.quadraticCurveTo(L+Q*M*0.75,_+V*M*0.75,z,R),Z.quadraticCurveTo(L-Q*M*0.75,_-V*M*0.75,K,q),Z.closePath(),Z.fillStyle=H,Z.globalAlpha=0.95,Z.shadowColor="#f6f",Z.shadowBlur=14,Z.fill(),Z.restore()}}var kJ=[],I0=18;function RZ(J,$,Q,V,K,q,z,R){if(kJ.length>=I0)return;let M=V||0,L=K||1,_=q||1,H=z||1,O=-F(Q),D=I(Q),Y=N.x+I(Q)*16+O*M,U=N.y+F(Q)*16+D*M,E=B(g,l)*1.9*H,T=x(4,26,$)*_,n=x(1.2,11,$)*L,i=W(J.lv.a|0,0,2);E*=1+i*0.08,T*=1+i*0.08,n*=1+i*0.07;let y=Y+I(Q)*E,a=U+F(Q)*E;m.each((w)=>{if(!w.active)return;if(dJ(w.x,w.y,Y,U,y,a)<=T*0.5+w.r){MJ(w,n,"bow_beam");let t=W(J.lv.c|0,0,2);if(t>0)w.cc.bleedDmg=B(w.cc.bleedDmg,[0,1.2,2.2][t]),w.cc.bleedT=B(w.cc.bleedT,[0,1.5,2.5][t])}}),LJ.each((w)=>{if(!w.active)return;if(dJ(w.x,w.y,Y,U,y,a)<=T*0.55+w.r)w.active=!1,h(w.x,w.y,"#ff0",2,70)});for(let w=0;w<6;w++){let t=0.15+w*0.15;h(x(Y,y,t),x(U,a,t),"#ff0",2,60)}kJ.push({x1:Y,y1:U,x2:y,y2:a,width:T,length:E,life:0.12+$*0.1,maxLife:0.12+$*0.1,color:R||"#ff0",phase:RJ()})}function H0(J){for(let $=kJ.length-1;$>=0;$--)if(kJ[$].life-=J,kJ[$].life<=0)kJ.splice($,1)}function O0(){for(let J of kJ){let $=W(J.life/J.maxLife,0,1),Q=0.9+F(j.time*40+J.phase)*0.1,V=J.width*(0.8+0.4*$)*Q,K=B(3,J.width*0.3*(0.8+0.3*$)),q=B(2,J.width*0.12);Z.save(),Z.lineCap="round";let z=Z.createLinearGradient(J.x1,J.y1,J.x2,J.y2);z.addColorStop(0,"rgba(255,216,74,0)"),z.addColorStop(0.08,"rgba(255,216,74,"+(0.12+0.14*$)+")"),z.addColorStop(1,"rgba(255,216,74,"+(0.08+0.2*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(J.x2,J.y2),Z.strokeStyle=z,Z.lineWidth=V,Z.globalAlpha=1,Z.shadowColor=J.color,Z.shadowBlur=20,Z.stroke();let R=Z.createLinearGradient(J.x1,J.y1,J.x2,J.y2);R.addColorStop(0,"rgba(255,255,255,0)"),R.addColorStop(0.08,"rgba(255,255,255,"+(0.16+0.2*$)+")"),R.addColorStop(1,"rgba(255,216,74,"+(0.2+0.4*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(J.x2,J.y2),Z.strokeStyle=R,Z.lineWidth=K,Z.globalAlpha=1,Z.shadowBlur=12,Z.stroke();let M=Z.createLinearGradient(J.x1,J.y1,J.x2,J.y2);M.addColorStop(0,"rgba(255,255,255,0)"),M.addColorStop(0.1,"rgba(255,255,255,"+(0.25+0.25*$)+")"),M.addColorStop(1,"rgba(255,255,255,"+(0.35+0.45*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(J.x2,J.y2),Z.strokeStyle=M,Z.lineWidth=q,Z.globalAlpha=1,Z.shadowBlur=8,Z.stroke();for(let L=0;L<5;L++){let _=(L+0.5)/5+F(j.time*10+L+J.phase)*0.015,H=x(J.x1,J.x2,W(_,0,1)),O=x(J.y1,J.y2,W(_,0,1));Z.beginPath(),Z.arc(H,O,2+$*3,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.1+0.25*$,Z.fill()}Z.restore()}}var AJ=[];function D0(J){AJ.push({owner:J.owner||null,x1:J.x1||0,y1:J.y1||0,angle:J.angle||0,length:J.length||800,width:J.width||20,rotSpeed:J.rotSpeed||0,life:J.life||0.9,maxLife:J.life||0.9,color:J.color||"#f66",offsetX:J.offsetX||0,offsetY:J.offsetY||0,warn:J.warn||0,maxWarn:J.warn||0,warnColor:J.warnColor||"#ffcc66"})}function Y0(J){j._bossLaserHitCD=B(0,(j._bossLaserHitCD||0)-J);for(let $=AJ.length-1;$>=0;$--){let Q=AJ[$];if(!Q.owner||!Q.owner.active){AJ.splice($,1);continue}if(Q.angle+=Q.rotSpeed*J,Q.x1=Q.owner.x+Q.offsetX,Q.y1=Q.owner.y+Q.offsetY,Q.warn>0){Q.warn=B(0,Q.warn-J);continue}if(Q.life-=J,Q.life<=0){AJ.splice($,1);continue}let V=Q.x1+I(Q.angle)*Q.length,K=Q.y1+F(Q.angle)*Q.length;if(N.alive&&N.invuln<=0&&j._bossLaserHitCD<=0){if(dJ(N.x,N.y,Q.x1,Q.y1,V,K)<=Q.width*0.45+N.r)j._bossLaserHitCD=0.12,QZ()}}}function v0(){for(let J of AJ){let $=W(J.life/J.maxLife,0,1),Q=J.x1+I(J.angle)*J.length,V=J.y1+F(J.angle)*J.length;if(J.warn>0){let _=W(J.warn/B(0.0001,J.maxWarn),0,1),H=0.45+0.45*GJ(F(j.time*18));Z.save(),Z.lineCap="round",Z.setLineDash([12,10]),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(Q,V),Z.strokeStyle=J.warnColor,Z.lineWidth=B(2,J.width*0.22),Z.globalAlpha=(0.2+0.55*(1-_))*H,Z.shadowColor=J.warnColor,Z.shadowBlur=10,Z.stroke(),Z.setLineDash([]),Z.restore();continue}let K=J.width*(1+0.35*$),q=B(4,J.width*0.45*(0.85+0.25*$)),z=B(2.5,J.width*0.2);Z.save(),Z.lineCap="round";let R=Z.createLinearGradient(J.x1,J.y1,Q,V);R.addColorStop(0,"rgba(255,255,255,0)"),R.addColorStop(0.08,"rgba(255,216,74,"+(0.12+0.14*$)+")"),R.addColorStop(1,"rgba(255,120,120,"+(0.1+0.22*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(Q,V),Z.strokeStyle=R,Z.lineWidth=K,Z.globalAlpha=1,Z.shadowColor=J.color,Z.shadowBlur=18,Z.stroke();let M=Z.createLinearGradient(J.x1,J.y1,Q,V);M.addColorStop(0,"rgba(255,255,255,0)"),M.addColorStop(0.1,"rgba(255,255,255,"+(0.15+0.2*$)+")"),M.addColorStop(1,"rgba(255,180,180,"+(0.2+0.38*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(Q,V),Z.strokeStyle=M,Z.lineWidth=q,Z.shadowBlur=10,Z.stroke();let L=Z.createLinearGradient(J.x1,J.y1,Q,V);L.addColorStop(0,"rgba(255,255,255,0)"),L.addColorStop(0.12,"rgba(255,255,255,"+(0.25+0.25*$)+")"),L.addColorStop(1,"rgba(255,255,255,"+(0.3+0.4*$)+")"),Z.beginPath(),Z.moveTo(J.x1,J.y1),Z.lineTo(Q,V),Z.strokeStyle=L,Z.lineWidth=z,Z.shadowBlur=6,Z.stroke(),Z.restore()}}var OJ=VJ.chunkSize,sJ=new Map,U0=Math.random()*4294967295>>>0;function B0(J,$){let Q=(J*374761393+$*668265263^U0)>>>0;return Q=Math.imul(Q^Q>>>13,1274126177),(Q^Q>>>16)>>>0}function UZ(J,$){let Q=J+","+$;if(sJ.has(Q))return sJ.get(Q);let V=B0(J,$),K=()=>{return V=V*1103515245+12345&2147483647,V/2147483647},q=qJ(K()*5),z=[],R=12,M=(L)=>{for(let _=0;_<z.length;_++){let H=z[_];if(L.type==="pillar"&&H.type==="pillar"){if(A(L.x,L.y,H.x,H.y)<L.r+H.r+R)return!0}else{let O=L.type==="pillar"?{x:L.x-L.r,y:L.y-L.r,w:L.r*2,h:L.r*2}:L,D=H.type==="pillar"?{x:H.x-H.r,y:H.y-H.r,w:H.r*2,h:H.r*2}:H;if(O.x<O.x+O.w&&D.x<D.x+D.w){let Y=O.x<D.x+D.w&&O.x+O.w>D.x,U=O.y<D.y+D.h&&O.y+O.h>D.y;if(Y&&U){if(!(O.x+O.w+R<D.x||O.x>D.x+D.w+R||O.y+O.h+R<D.y||O.y>D.y+D.h+R))return!0}}}}return!1};for(let L=0;L<q;L++){let _=!1;for(let H=0;H<10;H++){let O=J*OJ+K()*(OJ-120)+60,D=$*OJ+K()*(OJ-120)+60,Y=K()<0.5?{type:"pillar",x:O,y:D,r:18+K()*32}:{type:"wall",x:O-(50+K()*110)/2,y:D-(18+K()*45)/2,w:50+K()*110,h:18+K()*45};if(!M(Y)){z.push(Y),_=!0;break}}if(!_)continue}return sJ.set(Q,z),z}function X0(J,$,Q,V){let K=J.x-$,q=J.y-Q,z=b(K*K+q*q),R=J.r+V;if(z<R&&z>0.01)J.x=$+K/z*R,J.y=Q+q/z*R}function W0(J,$,Q,V,K){let q=W(J.x,$,$+V),z=W(J.y,Q,Q+K),R=J.x-q,M=J.y-z,L=b(R*R+M*M);if(L<J.r&&L>0.01)J.x=q+R/L*J.r,J.y=z+M/L*J.r;else if(L<=0.01&&J.x>=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&J.x<=$+V&&J.y>=Q&&J.y<=Q+K){let _=[J.x-$,$+V-J.x,J.y-Q,Q+K-J.y],H=_.indexOf(r(..._));if(H===0)J.x=$-J.r;else if(H===1)J.x=$+V+J.r;else if(H===2)J.y=Q-J.r;else J.y=Q+K+J.r}}function jJ(J){let $=qJ(J.x/OJ),Q=qJ(J.y/OJ);for(let V=-1;V<=1;V++)for(let K=-1;K<=1;K++){let q=UZ($+V,Q+K);for(let z=0;z<q.length;z++)q[z].type==="pillar"?X0(J,q[z].x,q[z].y,q[z].r):W0(J,q[z].x,q[z].y,q[z].w,q[z].h)}}function E0(J){let $=qJ(J.x/OJ),Q=qJ(J.y/OJ);for(let V=-1;V<=1;V++)for(let K=-1;K<=1;K++){let q=UZ($+V,Q+K);for(let z=0;z<q.length;z++){let R=q[z];if(R.type==="pillar"){if(A(J.x,J.y,R.x,R.y)<J.r+R.r)return R}else{let M=W(J.x,R.x,R.x+R.w),L=W(J.y,R.y,R.y+R.h);if(A(J.x,J.y,M,L)<J.r)return R}}}return null}function k0(J,$){let Q,V;if($.type==="pillar"){let q=J.x-$.x,z=J.y-$.y,R=b(q*q+z*z)||1;Q=q/R,V=z/R,J.x=$.x+Q*($.r+J.r+1),J.y=$.y+V*($.r+J.r+1)}else{let q=W(J.x,$.x,$.x+$.w),z=W(J.y,$.y,$.y+$.h);Q=J.x-q,V=J.y-z;let R=b(Q*Q+V*V)||1;Q/=R,V/=R,J.x=q+Q*(J.r+1),J.y=z+V*(J.r+1)}let K=J.vx*Q+J.vy*V;J.vx-=2*K*Q,J.vy-=2*K*V}function T0(){let $=c.x-X-100,Q=c.y-P-100,V=c.x+X+100,K=c.y+P+100,q=qJ($/100)*100,z=qJ(Q/100)*100;Z.save(),Z.strokeStyle="#111d28",Z.lineWidth=0.5,Z.globalAlpha=0.5,Z.beginPath();for(let R=q;R<=V;R+=100)Z.moveTo(R,Q),Z.lineTo(R,K);for(let R=z;R<=K;R+=100)Z.moveTo($,R),Z.lineTo(V,R);Z.stroke(),Z.restore()}function S0(){let J=qJ((c.x-X)/OJ)-1,$=qJ((c.x+X)/OJ)+1,Q=qJ((c.y-P)/OJ)-1,V=qJ((c.y+P)/OJ)+1;for(let K=J;K<=$;K++)for(let q=Q;q<=V;q++){let z=UZ(K,q);for(let R=0;R<z.length;R++){let M=z[R];if(M.type==="pillar")Z.save(),Z.beginPath(),Z.arc(M.x,M.y,M.r,0,v),Z.fillStyle="#0a1520",Z.globalAlpha=0.6,Z.fill(),Z.restore(),zZ(M.x,M.y,M.r,"#1a4a6a",2);else Z.save(),Z.fillStyle="#0a1520",Z.globalAlpha=0.6,Z.fillRect(M.x,M.y,M.w,M.h),Z.restore(),YJ([{x:M.x,y:M.y},{x:M.x+M.w,y:M.y},{x:M.x+M.w,y:M.y+M.h},{x:M.x,y:M.y+M.h}],"#1a4a6a",!0,2)}}}var N={x:0,y:0,r:VJ.playerR,hp:VJ.playerHP,maxHp:VJ.playerHP,invuln:0,angle:0,hitFlash:0,alive:!0,swordIFrame:0};function C0(){N.x=0,N.y=0,N.hp=VJ.playerHP,N.maxHp=VJ.playerHP,N.invuln=0,N.hitFlash=0,N.alive=!0,N.angle=0,N.shieldUp=!1,N.shieldCD=0,N.swordIFrame=0}function A0(J){if(!N.alive)return;let $=j.weapons.find((L)=>L.id==="sword");if(<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.lungeTimer>0){N.invuln=B(0,N.invuln-J),N.hitFlash=B(0,N.hitFlash-J*5),N.swordIFrame=B(0,N.swordIFrame-J);let L=NZ(),_=L.x-N.x,H=L.y-N.y;if(_*_+H*H>4)N.angle=k(H,_);if(jJ(N),j.passives.regen){if(C.regenTimer-=J,C.regenTimer<=0){if(C.regenTimer=C.regenInterval,N.hp<N.maxHp)N.hp++}}return}let Q=aZ(),V=Q.x,K=Q.y;if(j.reversed)V=-V,K=-K;let q=1;if(N.x+=V*C.moveSpeed*q*J,N.y+=K*C.moveSpeed*q*J,V!==0||K!==0)N.x+=j.windX*J*0.3,N.y+=j.windY*J*0.3;jJ(N);let z=NZ(),R=z.x-N.x,M=z.y-N.y;if(R*R+M*M>4)N.angle=k(M,R);if(N.invuln=B(0,N.invuln-J),N.hitFlash=B(0,N.hitFlash-J*5),N.swordIFrame=B(0,N.swordIFrame-J),C.regenTimer=(C.regenTimer||0)+J,C.regenTimer>=C.regenInterval&&N.hp<N.maxHp)C.regenTimer=0,N.hp=r(N.hp+1,N.maxHp);if(C.shieldRecharge>0&&!N.shieldUp){if(N.shieldCD=(N.shieldCD||0)-J,N.shieldCD<=0)N.shieldUp=!0,h(N.x,N.y,"#4af",6,80)}}function P0(){if(!N.alive)return;if(N.invuln>0&&N.swordIFrame<=0&&(j.time*20|0)%2===0)return;let J=N.hitFlash>0?"#fff":"#0ff";if(YJ(ZZ(N.x,N.y,N.r,N.angle+G/2),J,!0,4),Z.save(),Z.beginPath(),Z.arc(N.x,N.y,N.r*0.4,0,v),Z.fillStyle=J,Z.globalAlpha=0.15,Z.fill(),Z.restore(),N.swordIFrame>0){let $=W(N.swordIFrame/0.25,0,1),Q=N.r+8+F(j.time*18)*2;Z.save(),Z.beginPath(),Z.arc(N.x,N.y,Q,0,v),Z.strokeStyle="#f6f",Z.lineWidth=2.2,Z.globalAlpha=0.2+0.35*$,Z.shadowColor="#f6f",Z.shadowBlur=10,Z.stroke(),Z.beginPath(),Z.arc(N.x,N.y,Q-4,0,v),Z.strokeStyle="#8ff",Z.lineWidth=1.2,Z.globalAlpha=0.15+0.25*$,Z.shadowColor="#8ff",Z.shadowBlur=6,Z.stroke();for(let V=0;V<2;V++){let K=j.time*14+V*G,q=N.x-I(N.angle)*(8+V*5)+I(K)*2,z=N.y-F(N.angle)*(8+V*5)+F(K)*2,R=ZZ(q,z,N.r*0.65,N.angle+G/2);Z.beginPath(),Z.moveTo(R[0].x,R[0].y),Z.lineTo(R[1].x,R[1].y),Z.lineTo(R[2].x,R[2].y),Z.closePath(),Z.fillStyle="#f6f",Z.globalAlpha=0.08+0.12*$,Z.fill()}Z.restore()}if(N.shieldUp)Z.save(),Z.beginPath(),Z.arc(N.x,N.y,N.r+6,0,v),Z.strokeStyle="#4af",Z.lineWidth=2,Z.globalAlpha=0.5+F(j.time*4)*0.2,Z.shadowColor="#4af",Z.shadowBlur=8,Z.stroke(),Z.restore()}var nZ=[{name:"MIRROR",color:"#f0f",desc:"Bullets reflect off obstacles",apply(){j.reflect=!0},unapply(){j.reflect=!1},tick(){}},{name:"GRAVITY",color:"#84f",desc:"Bullets strongly curve toward you",apply(){j.gravity=220},unapply(){j.gravity=0},tick(){}},{name:"DRIFT",color:"#4ff",desc:"Wind pushes everything",apply(){let J=RJ();j.windX=I(J)*80,j.windY=F(J)*80},unapply(){j.windX=0,j.windY=0},tick(J){let $=k(j.windY,j.windX)+J*0.3,Q=b(j.windX**2+j.windY**2);j.windX=I($)*Q,j.windY=F($)*Q}},{name:"PULSE",color:"#ff0",desc:"Periodic bullet speed bursts",apply(){j.pulseTimer=0,j.pulseSpeed=0},unapply(){j.pulseSpeed=0,j.pulseTimer=0},tick(J){if(j.pulseTimer+=J,j.pulseTimer>3)j.pulseTimer=0,j.pulseSpeed=200,DJ(5);if(j.pulseSpeed>0)j.pulseSpeed=B(0,j.pulseSpeed-400*J)}},{name:"DECAY",color:"#4f4",desc:"Bullets slow down and pop",apply(){j.decay=!0},unapply(){j.decay=!1},tick(){}},{name:"ECHO",color:"#0af",desc:"Bullets spawn ghost copies",apply(){j.echo=!0},unapply(){j.echo=!1},tick(){}}],p=null,HZ=-1;function u0(){let J,$=0;do J=UJ(0,nZ.length-1),$++;while(J===HZ&&$<10);return HZ=J,J}function h0(J){if(p)p.unapply();j.wavePhaseIdx=J,p=nZ[J],p.apply()}var kZ={drifter(J,$){if(J.x+=J.vx*$,J.y+=J.vy*$,A(J.x,J.y,N.x,N.y)>500){let K=k(N.y-J.y,N.x-J.x);J.vx+=I(K)*40*$,J.vy+=F(K)*40*$}let V=b(J.vx**2+J.vy**2);if(V>100)J.vx*=100/V,J.vy*=100/V;jJ(J)},chaser(J,$){let Q=k(N.y-J.y,N.x-J.x),V=J.moveParams.speed||120;J.vx=x(J.vx,I(Q)*V,2*$),J.vy=x(J.vy,F(Q)*V,2*$),J.x+=J.vx*$,J.y+=J.vy*$,jJ(J)},orbiter(J,$){let Q=J.moveParams.radius||150;J.moveParams.angle=(J.moveParams.angle||0)+(J.moveParams.speed||1.5)*$,J.x=x(J.x,N.x+I(J.moveParams.angle)*Q,3*$),J.y=x(J.y,N.y+F(J.moveParams.angle)*Q,3*$),jJ(J)},dasher(J,$){let Q=J.moveParams;if(!Q.state)Q.state="wait";if(Q.state==="wait"){Q.waitTime=(Q.waitTime||0)+$;let V=k(N.y-J.y,N.x-J.x);if(J.x+=I(V)*20*$,J.y+=F(V)*20*$,Q.waitTime>1.5){let K=k(N.y-J.y,N.x-J.x),q=W(A(J.x,J.y,N.x,N.y)+36,120,260);Q.state="telegraph",Q.dashTx=J.x+I(K)*q,Q.dashTy=J.y+F(K)*q,Q.teleT=1,Q.teleMax=1,J._dashTele={t:1,maxT:1,tx:Q.dashTx,ty:Q.dashTy}}}else if(Q.state==="telegraph"){if(Q.teleT-=$,J._dashInvuln=B(J._dashInvuln,0.1),J._dashTele)J._dashTele.t=Q.teleT;if(Q.teleT<=0)Q.state="dashing",Q.dashT=0.32,Q.dashMax=0.32,Q.sx=J.x,Q.sy=J.y,Q.ex=Q.dashTx,Q.ey=Q.dashTy,J._dashTele=null}else{Q.dashT-=$;let V=W(1-Q.dashT/Q.dashMax,0,1),K=1-(1-V)*(1-V);if(J.x=x(Q.sx,Q.ex,K),J.y=x(Q.sy,Q.ey,K),J._dashInvuln=B(J._dashInvuln,0.3),Q.dashT<=0)J.x=Q.ex,J.y=Q.ey,Q.state="wait",Q.waitTime=0}jJ(J)},sentry(J,$){let Q=k(N.y-J.y,N.x-J.x);J.x+=I(Q)*15*$,J.y+=F(Q)*15*$,J.angle+=1.5*$,jJ(J)},weaver(J,$){let Q=J.moveParams;Q.t=(Q.t||0)+$;let V=k(N.y-J.y,N.x-J.x),K=Q.speed||100,q=Q.freq||2,z=V+G/2,R=F(Q.t*q)*80;J.x+=(I(V)*K+I(z)*R*q)*$,J.y+=(F(V)*K+F(z)*R*q)*$,jJ(J)},stationary(J,$){jJ(J)},bossChase(J,$){let Q=k(N.y-J.y,N.x-J.x);J.x+=I(Q)*60*$,J.y+=F(Q)*60*$,jJ(J)},converge(J,$){let Q=k(N.y-J.y,N.x-J.x),V=J.moveParams.speed||150;J.x+=I(Q)*V*$,J.y+=F(Q)*V*$,jJ(J)}},$Z={single(J){let $=k(N.y-J.y,N.x-J.x),Q=180+j.difficulty*10;WJ(J.x,J.y,I($)*Q,F($)*Q,4,J.color,"normal",3)},triple(J){let $=k(N.y-J.y,N.x-J.x),Q=170+j.difficulty*8;for(let V=-1;V<=1;V++)WJ(J.x,J.y,I($+V*0.2)*Q,F($+V*0.2)*Q,3.5,J.color,"normal",2.5)},radial(J){let $=J.fireParams.count||8,Q=140+j.difficulty*5,V=J.fireParams.offset||0;for(let K=0;K<$;K++){let q=v/$*K+V;WJ(J.x,J.y,I(q)*Q,F(q)*Q,3.5,J.color,"normal",3)}J.fireParams.offset=(V+0.15)%v},spiral(J){let $=160+j.difficulty*6;J.spiralAngle=(J.spiralAngle||0)+0.4,WJ(J.x,J.y,I(J.spiralAngle)*$,F(J.spiralAngle)*$,4,J.color,"curve",3.5,{curve:0.4})},ringpop(J){for(let V=0;V<10;V++){let K=v/10*V;WJ(J.x,J.y,I(K)*200,F(K)*200,3,J.color,"pulse",3,{pulseAmp:0.7,pulseFreq:3})}},wave(J){let $=k(N.y-J.y,N.x-J.x),Q=160+j.difficulty*5,V=$+G/2;for(let K=0;K<5;K++){let q=(K-2)*15;WJ(J.x+I(V)*q,J.y+F(V)*q,I($)*Q,F($)*Q,3,J.color,"normal",3)}},bossRadial(J){let V=J.spiralAngle||0;for(let K=0;K<16;K++){let q=v/16*K+V;hJ(J.x,J.y,I(q)*150,F(q)*150,5,J.color,"normal",4)}J.spiralAngle=(V+0.2)%v},bossWall(J){let $=k(N.y-J.y,N.x-J.x),Q=$+G/2;for(let z=0;z<13;z++){let R=(z-6)*30,M=J.x+I(Q)*R,L=J.y+F(Q)*R;hJ(M,L,I($)*220,F($)*220,4.2,J.color,"normal",3.2)}}};function f0(){let J=NJ(["normal","gravity","speed_shift","wind_shift","homing"]);if(J==="gravity")return{bossFx:"gravity",bossFxPower:360+Math.random()*220};if(J==="speed_shift")return{bossFx:"speed_shift",bossFxPower:1.25+Math.random()*0.95,bossFxFreq:6+Math.random()*4,bossFxPhase:RJ()};if(J==="wind_shift"){let $=RJ(),Q=260+Math.random()*170;return{bossFx:"wind_shift",bossWindX:I($)*Q,bossWindY:F($)*Q,bossFxSpin:0.8+Math.random()*1.1}}if(J==="homing")return{bossFx:"homing",bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};return{bossFx:"normal"}}function WJ(J,$,Q,V,K,q,z,R,M){LJ.spawn((L)=>{L.x=J,L.y=$,L.vx=Q,L.vy=V,L.r=K||4,L.color=q||"#f44",L.type=z||"normal",L.life=R||3,L.maxLife=R||3,L.spawnTime=j.time,L.reflected=!1,L.echoed=!1,L.echoTimer=0,L.damage=1,L.curve=M&&M.curve||0,L.pulseAmp=M&&M.pulseAmp||0,L.pulseFreq=M&&M.pulseFreq||0,L.split=M&&M.split||!1,L.baseSpeed=b(Q*Q+V*V),L.loopAmp=M&&M.loopAmp||0,L.loopFreq=M&&M.loopFreq||0,L.loopBaseAng=M&&M.loopBaseAng!==void 0?M.loopBaseAng:k(V,Q),L.bossFx=M&&M.bossFx||"normal",L.bossFxPower=M&&M.bossFxPower||0,L.bossFxFreq=M&&M.bossFxFreq||0,L.bossFxPhase=M&&M.bossFxPhase||0,L.bossWindX=M&&M.bossWindX||0,L.bossWindY=M&&M.bossWindY||0,L.bossFxSpin=M&&M.bossFxSpin||0,L.bossHomingTurn=M&&M.bossHomingTurn||0,L.bossHomingStop=M&&M.bossHomingStop||0})}function hJ(J,$,Q,V,K,q,z,R,M){WJ(J,$,Q,V,K,q,z,R,Object.assign({},M||{},f0()))}var G0=["#f44","#f84","#ff4","#4f4","#4ff","#f4f","#84f"],g0=["circle","square","triangle"],m0=["drifter","chaser","orbiter","dasher","sentry","weaver"],y0=["single","triple","radial","spiral","ringpop","wave"];function lZ(J,$){J=J||"small";let Q=J==="elite";m.spawn((V)=>{let K=RJ(),q=B(X,P)+50+e(0,100);V.x=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.x!==void 0?$.x:N.x+I(K)*q,V.y=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.y!==void 0?$.y:N.y+F(K)*q,V.shape=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.shape||NJ(g0),V.color=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.color||NJ(G0),V.moveType=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.moveType||NJ(m0),V.firePattern=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.firePattern||NJ(y0),V.tier=J,V.r=Q?22:14;let z=1+j.wave*0.11+j.wave*j.wave*0.003;if(V.hp=(Q?10:3)*z|0,V.maxHp=V.hp,V.fireCD=(Q?e(0.8,1.5):e(1.5,3))/(1+j.difficulty*0.08),<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.fireMult)V.fireCD/=$.fireMult;if(V.fireTimer=e(0.5,V.fireCD),V.hitFlash=0,V.angle=RJ(),V.spiralAngle=RJ(),V.spawnTime=j.time,V._dashTele=null,V._dashInvuln=0,V.moveParams=<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.moveParams||{},V.fireParams={},V.isBoss=!1,V.bossAI=null,V.shieldHP=0,V.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},V.moveType==="drifter"){let R=e(40,80),M=RJ();V.vx=I(M)*R,V.vy=F(M)*R}else if(V.moveType==="orbiter")V.moveParams.radius=V.moveParams.radius||e(100,200),V.moveParams.speed=V.moveParams.speed||e(1,2.5)*(Math.random()<0.5?1:-1),V.moveParams.angle=V.moveParams.angle||RJ();else if(V.moveType==="dasher")V.moveParams.state="wait",V.moveParams.waitTime=0,V.vx=0,V.vy=0;else if(V.moveType==="weaver")V.moveParams.t=0,V.moveParams.speed=V.moveParams.speed||e(60,120),V.moveParams.freq=V.moveParams.freq||e(2,5);else if(V.moveType==="chaser")V.moveParams.speed=V.moveParams.speed||e(80,140),V.vx=0,V.vy=0;else if(V.moveType==="sentry")V.vx=e(-20,20),V.vy=e(-20,20);else if(V.moveType==="converge")V.moveParams.speed=V.moveParams.speed||150;if(V.firePattern==="radial")V.fireParams.count=Q?UJ(10,16):UJ(6,10),V.fireParams.offset=RJ();if(<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.hpMult)V.hp=V.hp*$.hpMult|0,V.maxHp=V.hp;if(<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&$.spdMult)V.moveParams.speed=(V.moveParams.speed||100)*$.spdMult;return V})}function w0(J){if(j.frozen)return;m.each(($)=>{let Q=$.cc;if(Q.bleedT>0){if(Q.bleedT-=J,$.hp-=Q.bleedDmg*J,$.hp<=0)rZ($)}if(Q.stunT>0){Q.stunT-=J,$.hitFlash=0.2;return}if(Q.silenceT>0)Q.silenceT-=J;if(Q.rootT>0)Q.rootT-=J;if(Q.slowT>0)Q.slowT-=J;else Q.slowAmt=0;if(Q.fearT>0){Q.fearT-=J;let V=k($.y-N.y,$.x-N.x),K=($.moveParams.speed||100)*1.5;$.x+=I(V)*K*J,$.y+=F(V)*K*J,jJ($)}else if(Q.disorientT>0)Q.disorientT-=J,$.x+=(Math.random()-0.5)*200*J,$.y+=(Math.random()-0.5)*200*J,jJ($);else if(Q.kbVx||Q.kbVy){if($.x+=Q.kbVx*J,$.y+=Q.kbVy*J,Q.kbVx*=0.9,Q.kbVy*=0.9,GJ(Q.kbVx)<5)Q.kbVx=0;if(GJ(Q.kbVy)<5)Q.kbVy=0;jJ($)}else if(Q.rootT<=0){let V=Q.slowT>0?1-Q.slowAmt:1,K=$.moveParams.speed;if(K)$.moveParams.speed=K*V;if($.isBoss&&$.bossAI)$.bossAI.update($,J);else if(kZ[$.moveType])kZ[$.moveType]($,J);if(K)$.moveParams.speed=K}if(Q.markT>0)Q.markT-=J;else Q.markAmp=0;if(Q.silenceT<=0){let V=Q.slowT>0?1-Q.slowAmt*0.5:1;if($.fireTimer-=J*V,$.fireTimer<=0&&N.alive){if($.fireTimer+=$.fireCD,$.isBoss&&$.bossAI)$.bossAI.fire($);else if($Z[$.firePattern])$Z[$.firePattern]($)}}if($.angle+=J*($.moveType==="sentry"?1.5:0.5),$.hitFlash=B(0,$.hitFlash-J*5),$._dashInvuln>0)$._dashInvuln=B(0,$._dashInvuln-J);if(A($.x,$.y,N.x,N.y)>VJ.cullDist&&!$.isBoss)$.active=!1})}function o0(J){let $=j.time,Q=J.r,V=J.color||"#f6c";Z.save(),Z.translate(J.x,J.y),Z.rotate(J.angle*0.6);let K=J.bossShape||"circle";if(K==="square")YJ(yZ(0,0,Q,0),V,!0,6);else if(K==="triangle")YJ(ZZ(0,0,Q,0),V,!0,6);else zZ(0,0,Q,V,6);let q=J.bossAccessory|0;if(q===0)for(let z=0;z<4;z++){let R=$*1.7+v/4*z;Z.beginPath(),Z.arc(I(R)*Q*0.8,F(R)*Q*0.8,2.5,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.55,Z.fill()}else if(q===1){Z.rotate($*1.4),Z.beginPath();for(let z=0;z<8;z++){let R=v/8*z,M=z%2===0?Q+8:Q*0.6,L=I(R)*M,_=F(R)*M;if(z===0)Z.moveTo(L,_);else Z.lineTo(L,_)}Z.closePath(),Z.strokeStyle=V,Z.lineWidth=1.8,Z.globalAlpha=0.5,Z.stroke()}else for(let z=0;z<3;z++){let R=$*1.1+z*2.1,M=Q*0.55+z*6;Z.beginPath(),Z.arc(I(R)*M,F(R)*M,3,0,v),Z.fillStyle=V,Z.globalAlpha=0.4,Z.fill()}if(Z.beginPath(),Z.arc(0,0,Q*0.24+F($*5)*1.2,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.7,Z.fill(),J._dashInvuln>0){let z=W(J._dashInvuln/0.3,0,1);Z.beginPath(),Z.arc(0,0,Q+8+F($*16)*2,0,v),Z.strokeStyle="#ffd0ff",Z.lineWidth=2.4,Z.globalAlpha=0.28+0.35*z,Z.shadowColor="#f6f",Z.shadowBlur=12,Z.stroke(),Z.beginPath(),Z.arc(0,0,Q+3,0,v),Z.strokeStyle="#fff",Z.lineWidth=1.2,Z.globalAlpha=0.18+0.25*z,Z.shadowBlur=7,Z.stroke()}if(Z.restore(),J.bossAI&&J.bossAI.shieldNodes&&J.bossAI.shieldNodes.some((z)=>z.hp>0))for(let z of J.bossAI.shieldNodes){if(z.hp<=0)continue;let R=J.x+I(z.angle)*(J.r+22),M=J.y+F(z.angle)*(J.r+22),L=z.angle+G/2,_=10,H=[];for(let O=0;O<6;O++){let D=L+v/6*O;H.push({x:R+I(D)*_,y:M+F(D)*_})}Z.save(),Z.beginPath(),Z.moveTo(H[0].x,H[0].y);for(let O=1;O<H.length;O++)Z.lineTo(H[O].x,H[O].y);Z.closePath(),Z.fillStyle="rgba(235,245,255,.22)",Z.strokeStyle=V,Z.lineWidth=2,Z.shadowColor=V,Z.shadowBlur=10,Z.fill(),Z.stroke(),Z.beginPath(),Z.arc(R,M,_+5,z.angle-0.65,z.angle+0.65),Z.strokeStyle="rgba(255,255,255,.45)",Z.lineWidth=2.2,Z.shadowBlur=6,Z.stroke(),Z.beginPath(),Z.arc(R,M,3.2,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.9,Z.fill(),Z.restore()}}function aJ(J,$,Q,V){let K=j.time+V,q=W(Q,0,1),R=72*(0.84+F(K*5)*0.2);Z.save(),Z.translate(J,$),Z.beginPath(),Z.arc(0,0,R+18,0,v),Z.strokeStyle="rgba(120,70,220,"+0.3*q+")",Z.lineWidth=10,Z.shadowColor="#8a5dff",Z.shadowBlur=20,Z.stroke(),Z.save(),Z.rotate(K*1.2);let M=10;Z.beginPath();for(let _=0;_<M;_++){let H=v/M*_,O=(_%2===0?R+8:R-2)+F(K*7+_)*2,D=I(H)*O,Y=F(H)*O;if(_===0)Z.moveTo(D,Y);else Z.lineTo(D,Y)}Z.closePath(),Z.strokeStyle="rgba(198,150,255,"+0.62*q+")",Z.lineWidth=3.6,Z.shadowBlur=12,Z.stroke(),Z.restore();for(let _=0;_<3;_++){let H=R*(0.72-_*0.18);Z.beginPath(),Z.arc(0,0,H+F(K*6+_*1.8)*2.5,0,v),Z.strokeStyle=_===0?"rgba(230,215,255,"+0.7*q+")":"rgba(176,128,255,"+0.52*q+")",Z.lineWidth=2.4-_*0.35,Z.shadowBlur=10-_*2,Z.stroke()}let L=14;for(let _=0;_<L;_++){let H=K*1.4+v/L*_,O=R*0.38+F(K*8+_)*3,D=R+10+F(K*5+_*1.7)*4,Y=I(H)*O,U=F(H)*O,E=I(H)*D,T=F(H)*D;Z.beginPath(),Z.moveTo(Y,U),Z.lineTo(E,T),Z.strokeStyle="rgba(215,182,255,"+0.42*q+")",Z.lineWidth=1.6,Z.shadowBlur=8,Z.stroke()}Z.restore()}function n0(J){if(!J._dashTele)return;let $=J._dashTele,Q=1-W($.t/B(0.0001,$.maxT),0,1),V=$.tx,K=$.ty,q=k(K-J.y,V-J.x),z=J.x+I(q)*(J.r+12),R=J.y+F(q)*(J.r+12);Z.save(),Z.beginPath(),Z.arc(J.x,J.y,J.r+9+F(j.time*18)*2,0,v),Z.strokeStyle="rgba(255,235,140,"+(0.24+0.42*Q)+")",Z.lineWidth=2.3,Z.shadowColor="#ffea8a",Z.shadowBlur=10,Z.stroke(),Z.translate(z,R),Z.rotate(q);let M=7+Q*1.8;Z.beginPath(),Z.moveTo(M,0),Z.lineTo(-M*0.55,-M*0.55),Z.lineTo(-M*0.55,M*0.55),Z.closePath(),Z.fillStyle="rgba(255,245,180,"+(0.35+0.4*Q)+")",Z.shadowColor="#fff0a0",Z.shadowBlur=8,Z.fill(),Z.restore()}function l0(){m.each((J)=>{let $=J.cc,Q=J.hitFlash>0?"#fff":J.color;if($.fearT>0)Q="#ddd";let V=J.r+(J.hitFlash>0?2:0);if(J.isBoss)o0(J);else{let K=J.isBoss?6:J.tier==="elite"?5:3;if(J.shape==="circle")zZ(J.x,J.y,V,Q,K);else if(J.shape==="square")YJ(yZ(J.x,J.y,V,J.angle),Q,!0,K);else YJ(ZZ(J.x,J.y,V,J.angle),Q,!0,K)}if(J._dashTele&&(J.moveType==="dasher"||J.isBoss))n0(J);if(J.tier==="elite"&&J.hp<J.maxHp&&!J.isBoss){let K=J.r*2;Z.save(),Z.fillStyle="#333",Z.globalAlpha=0.7,Z.fillRect(J.x-K/2,J.y-J.r-8,K,3),Z.fillStyle=J.color,Z.globalAlpha=0.9,Z.fillRect(J.x-K/2,J.y-J.r-8,K*(J.hp/J.maxHp),3),Z.restore()}if($.stunT>0)Z.save(),Z.globalAlpha=0.6+Math.random()*0.4,Z.beginPath(),Z.arc(J.x+(Math.random()-0.5)*4,J.y+(Math.random()-0.5)*4,J.r+3,0,v),Z.strokeStyle="#fff",Z.lineWidth=2,Z.stroke(),Z.restore();if($.silenceT>0){Z.save(),Z.globalAlpha=0.6,Z.strokeStyle="#0aa",Z.lineWidth=2;let K=J.r*0.4;Z.beginPath(),Z.moveTo(J.x-K,J.y-K),Z.lineTo(J.x+K,J.y+K),Z.moveTo(J.x+K,J.y-K),Z.lineTo(J.x-K,J.y+K),Z.stroke(),Z.restore()}if($.rootT>0){Z.save(),Z.strokeStyle="#4f4",Z.lineWidth=2,Z.globalAlpha=0.6;for(let K=0;K<3;K++)Z.beginPath(),Z.arc(J.x,J.y+J.r*0.3,J.r*0.6+K*4,0,v),Z.stroke();Z.restore()}if($.slowT>0){Z.save(),Z.strokeStyle="#f4f",Z.lineWidth=1.5,Z.globalAlpha=0.5,Z.beginPath();let K=j.time*3;for(let q=0;q<3;q++){let z=K+v/3*q;Z.moveTo(J.x+I(z)*J.r,J.y+F(z)*J.r),Z.lineTo(J.x+I(z+0.5)*(J.r+8),J.y+F(z+0.5)*(J.r+8))}Z.stroke(),Z.restore()}if($.markT>0){Z.save(),Z.fillStyle="#ccc",Z.globalAlpha=0.8;let K=5;Z.beginPath(),Z.moveTo(J.x,J.y-J.r-10-K),Z.lineTo(J.x+K,J.y-J.r-10),Z.lineTo(J.x,J.y-J.r-10+K),Z.lineTo(J.x-K,J.y-J.r-10),Z.closePath(),Z.fill(),Z.restore()}if($.fearT>0)Z.save(),f("!",J.x,J.y-J.r-14,12,"#ff0","center","middle"),Z.restore();if($.bleedT>0){Z.save(),Z.fillStyle="#f00",Z.globalAlpha=0.5;for(let K=0;K<3;K++){let q=j.time*5+v/3*K;Z.beginPath(),Z.arc(J.x+I(q)*J.r*0.6,J.y+F(q)*J.r*0.6,2,0,v),Z.fill()}Z.restore()}})}function TZ(J,$,Q){if(j.frozen&&!Q)return;J.each((V)=>{if(V.type==="curve"&&V.curve){let q=b(V.vx**2+V.vy**2),z=k(V.vy,V.vx)+V.curve*$;V.vx=I(z)*q,V.vy=F(z)*q}if(V.type==="loop"&&V.loopAmp){let q=(j.time-V.spawnTime)*(V.loopFreq||2.6),z=V.loopBaseAng,R=B(80,V.baseSpeed),M=F(q*v)*(V.loopAmp||120),L=I(z),_=F(z),H=-_,O=L;V.vx=L*R+H*M,V.vy=_*R+O*M}if(V.type==="pulse"&&V.pulseAmp){let q=1-V.life/V.maxLife,z=V.baseSpeed*(1+F(q*V.pulseFreq*v)*V.pulseAmp),R=k(V.vy,V.vx);V.vx=I(R)*z,V.vy=F(R)*z}if(!Q){if(V.bossFx==="gravity"){let q=N.x-V.x,z=N.y-V.y,R=B(45,b(q*q+z*z)),M=V.bossFxPower||420;V.vx+=q/R*M*$,V.vy+=z/R*M*$}else if(V.bossFx==="speed_shift"){let q=V.bossFxPower||1.6,z=V.bossFxFreq||7,R=V.bossFxPhase||0,M=V.baseSpeed*(1+F((j.time+V.spawnTime)*z+R)*q*0.45),L=k(V.vy,V.vx);V.vx=I(L)*B(80,M),V.vy=F(L)*B(80,M)}else if(V.bossFx==="wind_shift"){let q=V.bossFxSpin||0;if(q){let z=k(V.bossWindY,V.bossWindX)+$*q,R=b(V.bossWindX*V.bossWindX+V.bossWindY*V.bossWindY);V.bossWindX=I(z)*R,V.bossWindY=F(z)*R}V.vx+=V.bossWindX*$,V.vy+=V.bossWindY*$}else if(V.bossFx==="homing"){let q=N.x-V.x,z=N.y-V.y,R=b(q*q+z*z),M=V.bossHomingStop||180;if(R>M){let L=k(z,q),_=k(V.vy,V.vx),H=W(DZ(L-_),-(V.bossHomingTurn||3)*$,(V.bossHomingTurn||3)*$),O=_+H,D=B(90,b(V.vx*V.vx+V.vy*V.vy));V.vx=I(O)*D,V.vy=F(O)*D}}if(j.gravity){let q=N.x-V.x,z=N.y-V.y,R=B(50,b(q*q+z*z));V.vx+=q/R*j.gravity*$,V.vy+=z/R*j.gravity*$}if(j.decay){let q=V.baseSpeed*B(0.2,1-(1-V.life/V.maxLife)*0.8),z=k(V.vy,V.vx);V.vx=I(z)*q,V.vy=F(z)*q}if(j.pulseSpeed){let q=b(V.vx**2+V.vy**2)+j.pulseSpeed*$,z=k(V.vy,V.vx);V.vx=I(z)*q,V.vy=F(z)*q}if(j.echo&&!V.echoed){if(V.echoTimer+=$,V.echoTimer>0.15)V.echoed=!0,LJ.spawn((q)=>{q.x=V.x,q.y=V.y,q.vx=V.vx*0.7,q.vy=V.vy*0.7,q.r=V.r*0.7,q.color=V.color,q.type="normal",q.life=V.life*0.5,q.maxLife=q.life,q.spawnTime=j.time,q.reflected=!1,q.echoed=!0,q.echoTimer=0,q.curve=0,q.pulseAmp=0,q.split=!1,q.damage=1,q.baseSpeed=b(q.vx**2+q.vy**2)})}V.vx+=j.windX*$*0.5,V.vy+=j.windY*$*0.5}V.x+=V.vx*$,V.y+=V.vy*$,V.life-=$;let K=E0(V);if(K)if(j.reflect&&!V.reflected&&!Q)k0(V,K),V.reflected=!0;else V.active=!1,h(V.x,V.y,V.color,3,60);if(A(V.x,V.y,N.x,N.y)>VJ.cullDist)V.active=!1;if(V.life<=0){if(V.active=!1,V.split&&!Q)for(let q=0;q<3;q++){let z=Math.random()*v;WJ(V.x,V.y,I(z)*100,F(z)*100,2.5,V.color,"normal",1.5)}if(j.decay&&!Q)h(V.x,V.y,V.color,4,60)}})}function SZ(J){J.each(($)=>{let Q=W($.life/$.maxLife,0,1);if(Z.save(),Z.globalAlpha=Q,$.src==="rocket"||$.src==="rocket_mini"){let V=$.src==="rocket_mini"?0.6:1,K=k($.vy,$.vx),q=K+G/2,z={x:$.x+I(K)*10*V,y:$.y+F(K)*10*V},R={x:$.x-I(K)*6*V+I(q)*4*V,y:$.y-F(K)*6*V+F(q)*4*V},M={x:$.x-I(K)*6*V-I(q)*4*V,y:$.y-F(K)*6*V-F(q)*4*V};Z.beginPath(),Z.moveTo(z.x,z.y),Z.lineTo(R.x,R.y),Z.lineTo(M.x,M.y),Z.closePath(),Z.fillStyle=$.src==="rocket_mini"?"#fa0":"#f80",Z.fill(),Z.strokeStyle="#fa0",Z.lineWidth=1,Z.stroke();let L=$.x-I(K)*8*V,_=$.y-F(K)*8*V;Z.beginPath(),Z.arc(L,_,(3+Math.random()*2)*V,0,v),Z.fillStyle="#ff4",Z.globalAlpha=Q*0.7,Z.fill(),Z.beginPath(),Z.arc(L-I(K)*3*V,_-F(K)*3*V,(2+Math.random()*2)*V,0,v),Z.fillStyle="#f80",Z.globalAlpha=Q*0.4,Z.fill()}else tZ($.x,$.y,$.r,$.color);if($.bossFx&&$.bossFx!=="normal")Z.beginPath(),Z.arc($.x,$.y,$.r+2.2,0,v),Z.strokeStyle=$.bossFx==="gravity"?"#f8f":$.bossFx==="speed_shift"?"#ff8":"#8ff",Z.lineWidth=1.2,Z.globalAlpha=0.45*Q,Z.stroke();Z.restore()})}var b0={dagger:(J)=>Object.assign(J,{state:"idle",dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),sword:(J)=>Object.assign(J,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),bow:(J)=>Object.assign(J,{charging:!1,chargeTime:0,maxCharge:1.5,shotCD:0}),chain:(J)=>Object.assign(J,{timer:0.1,range:200,chains:4,stunDur:0.3,dmg:5,_arcTimer:0,_targets:null}),rocket:(J)=>Object.assign(J,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),drone:(J)=>Object.assign(J,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),shuriken:(J)=>Object.assign(J,{timer:0.1,count:1,markDur:3,markAmp:0.3,bounces:2,_shurikens:[]})};function bZ(J){let $={id:J,lv:{a:0,b:0,c:0,d:0}},Q=b0[J];if(Q)Q($);return $}var fJ={dagger:{name:"MAGIC DAGGER",color:"#0ff",type:"starter",desc:"Click to throw. Click again to redirect.",upgrades:[{id:"a",name:"PIERCING THROW",maxLv:3,desc:["+50% speed","90% + homing","120% + homing"]},{id:"b",name:"SPECTRAL COPY",maxLv:3,desc:["1 ghost 50% dmg","2 ghosts 60%","3 ghosts 75%"]},{id:"d",name:"DAGGER STORM",maxLv:2,desc:["0.8s spin 35px","1.2s 50px"]}]},sword:{name:"PLASMA SWORD",color:"#f0f",type:"starter",desc:"Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.",upgrades:[{id:"a",name:"LUNGE REACH",maxLv:3,desc:["160px lunge","200px","250px"]},{id:"b",name:"WIDE CLEAVE",maxLv:3,desc:["50px wide","60px","75px"]},{id:"c",name:"AFTERSHOCK",maxLv:2,desc:["Trail 2dmg 1.8s","3dmg 2.5s"]}]},bow:{name:"VOLT BOW",color:"#ff0",type:"starter",desc:"Hold to charge, release a piercing beam.",upgrades:[{id:"a",name:"PRISM SPLIT",maxLv:2,desc:["1 side pair","2 side pairs"]},{id:"b",name:"QUICK DRAW",maxLv:3,desc:["1.0s charge","0.8s","0.6s"]},{id:"c",name:"PLASMA BURN",maxLv:2,desc:["Applies burn","Stronger burn"]}]},chain:{name:"CHAIN LIGHTNING",color:"#a0f",type:"cc",cc:"BULLET CLEAR",desc:"Arcs lightning to destroy enemy bullets.",upgrades:[{id:"a",name:"EXTRA CHAINS",maxLv:2,desc:["+3 chains (7)","+3 (10)"]},{id:"b",name:"MULTI STRIKE",maxLv:2,desc:["2 bolts at once","3 bolts"]},{id:"c",name:"STATIC FIELD",maxLv:2,desc:["3s lingering stun zone","5s zone + wider"]}]},rocket:{name:"ROCKET LAUNCHER",color:"#f80",type:"cc",cc:"KNOCKBACK",desc:"Homing rockets knock enemies back, clear bullets.",upgrades:[{id:"a",name:"CONCUSSIVE BLAST",maxLv:3,desc:["+60 knockback","+120 kb","+200 kb"]},{id:"b",name:"CLUSTER BOMB",maxLv:2,desc:["5 homing mini-rockets","7"]},{id:"c",name:"BLAST RADIUS",maxLv:2,desc:["130px","160px"]}]},drone:{name:"PULSE DRONE",color:"#0aa",type:"cc",cc:"SILENCE",desc:"Drone silences enemies, slows bullets.",upgrades:[{id:"a",name:"EXTRA DRONE",maxLv:2,desc:["+1 drone","+1 (3 total)"]},{id:"b",name:"EXT SILENCE",maxLv:2,desc:["2.5s","3.5s"]},{id:"c",name:"DISRUPTION",maxLv:2,desc:["20% slow","40%"]},{id:"d",name:"OVERDRIVE",maxLv:2,desc:["0.9s cd","0.7s"]}]},shuriken:{name:"SHURIKEN",color:"#bbb",type:"cc",cc:"MARK",desc:"Bouncing shurikens mark enemies for bonus damage.",upgrades:[{id:"a",name:"EXTRA SHURIKEN",maxLv:2,desc:["+1","+1 (3 total)"]},{id:"b",name:"DEEP MARK",maxLv:2,desc:["45% bonus dmg","60%"]},{id:"c",name:"EXT MARK",maxLv:2,desc:["5s","7s"]},{id:"d",name:"EXTRA BOUNCES",maxLv:3,desc:["+2 bounces (4)","+2 (6)","+2 (8)"]}]}},pJ=["dagger","sword","bow"];var i0=["chain","rocket","drone","shuriken"],d0={dagger:a0,sword:e0,bow:
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
,chain:j1,rocket:_1,drone:O1,shuriken:Y1},p0={dagger:c0,sword:Z1,bow:q1,chain:F1,rocket:I1,drone:D1,shuriken:v1};function r0(J){for(let $ of j.weapons){let Q=d0[$.id];if(Q)Q($,J)}}function x0(){for(let J of j.weapons){let $=p0[J.id];if($)$(J)}}function iZ(J){let $=null,Q=null;for(let V=0;V<j.weapons.length;V++){let K=j.weapons[V];if(fJ[K.id].type!=="starter")continue;if(!$){$=K;continue}Q=K;break}if(J===0)return $;if(J===2)return Q;return null}function a0(J,$){if(J.state==="flying"){let Q=[1,1.5,1.9,2.2][J.lv.a],V=k(J.ty-J.dy,J.tx-J.dx),K=J.speed*Q*$;if(A(J.dx,J.dy,J.tx,J.ty)<K+5)if(J.dx=J.tx,J.dy=J.ty,J.lv.d>0)J.state="spinning",J.spinTimer=[0,0.8,1.2][J.lv.d],J.spinR=[0,35,50][J.lv.d];else J.state="waiting",J.idleTimer=0;else J.dx+=I(V)*K,J.dy+=F(V)*K;CZ(J,J.dmg)}else if(J.state==="spinning"){if(J.spinTimer-=$,J.angle=(J.angle||0)+$*15,s0(J,$),J.spinTimer<=0)J.state="waiting",J.idleTimer=0}else if(J.state==="waiting"){if(J.idleTimer+=$,J.idleTimer>2)J.state="returning"}else if(J.state==="returning"){let Q=k(N.y-J.dy,N.x-J.dx),V=J.speed*1.2*$;if(J.dx+=I(Q)*V,J.dy+=F(Q)*V,CZ(J,J.dmg),A(J.dx,J.dy,N.x,N.y)<20)J.state="idle"}else J.dx=N.x,J.dy=N.y;if(J.lv.b>0){let Q=[0,1,2,3][J.lv.b];if(!J._ghosts)J._ghosts=[];if(!J._posHistory)J._posHistory=[];if(J._posHistory.push({x:J.dx,y:J.dy}),J._posHistory.length>30)J._posHistory.shift();J._ghosts=[];for(let V=0;V<Q;V++){let K=B(0,J._posHistory.length-1-(V+1)*6);J._ghosts.push({x:J._posHistory[K].x,y:J._posHistory[K].y})}}}function CZ(J,$){if(m.each((Q)=>{if(!Q.active)return;if(A(J.dx,J.dy,Q.x,Q.y)<Q.r+8)MJ(Q,$,"dagger")}),J.lv.b>0&&J._ghosts){let Q=$*[0,0.5,0.6,0.75][J.lv.b];for(let V of J._ghosts)m.each((K)=>{if(!K.active)return;if(A(V.x,V.y,K.x,K.y)<K.r+8)MJ(K,Q,"dagger_ghost")})}}function s0(J,$){m.each((Q)=>{if(!Q.active)return;if(A(J.dx,J.dy,Q.x,Q.y)<J.spinR+Q.r)MJ(Q,[0,3,4][J.lv.d]*$*10,"dagger")})}function c0(J){let $=J.dx||N.x,Q=J.dy||N.y;if(J.state==="idle"){let V=N.angle,K=N.x+I(V)*18,q=N.y+F(V)*18;YJ([{x:K+I(V)*8,y:q+F(V)*8},{x:K+I(V+2.3)*5,y:q+F(V+2.3)*5},{x:K+I(V-2.3)*5,y:q+F(V-2.3)*5}],"#0ff",!0,3)}else{let V=J.state==="spinning"?J.angle||0:k(J.dy-(J.state==="returning"?N.y:J.ty),J.dx-(J.state==="returning"?N.x:J.tx))+G;if(YJ([{x:$+I(V)*10,y:Q+F(V)*10},{x:$+I(V+2.3)*6,y:Q+F(V+2.3)*6},{x:$+I(V-2.3)*6,y:Q+F(V-2.3)*6}],"#0ff",!0,4),J.state==="spinning")wZ($,Q,J.spinR,0,v,"#0ff",1);if(J.lv.b>0&&J._ghosts&&J.state!=="idle")for(let K=0;K<J._ghosts.length;K++){let q=J._ghosts[K],z=J.state==="spinning"?J.angle||0:k(J.dy-q.y,J.dx-q.x);Z.save(),Z.globalAlpha=0.35-K*0.08,YJ([{x:q.x+I(z)*10,y:q.y+F(z)*10},{x:q.x+I(z+2.3)*6,y:q.y+F(z+2.3)*6},{x:q.x+I(z-2.3)*6,y:q.y+F(z-2.3)*6}],"#0ff",!0,3),Z.restore()}}}function t0(J,$,Q){if(J.state==="idle"||J.state==="waiting"||J.state==="spinning"){if(J.state="flying",J.tx=$,J.ty=Q,J.state==="idle")J.dx=N.x,J.dy=N.y}else if(J.state==="flying")J.tx=$,J.ty=Q;else if(J.state==="returning")J.state="flying",J.tx=$,J.ty=Q}function e0(J,$){if(J.swingCD=B(0,J.swingCD-$),J.lungeTimer>0){J.lungeTimer-=$;let Q=0.18;J.lungeProg=W(1-J.lungeTimer/Q,0,1);let V=J.lungeDist,K=[35,50,60,75][J.lv.b],q=J.lungeStartX+I(J.lungeDir)*V*J.lungeProg,z=J.lungeStartY+F(J.lungeDir)*V*J.lungeProg;N.x=q,N.y=z,N.invuln=B(N.invuln,0.25),N.swordIFrame=B(N.swordIFrame,0.25);let R=8,M=70;if(m.each((L)=>{if(!L.active)return;let _=L.x-q,H=L.y-z,O=I(J.lungeDir),D=F(J.lungeDir),Y=_*O+H*D;if(Y<-15-L.r||Y>M+L.r)return;if(GJ(_*-D+H*O)<K+L.r){if(!L._swordHitT||j.time-L._swordHitT>0.15)L._swordHitT=j.time,MJ(L,R,"sword",!1),DJ(2)}}),LJ.each((L)=>{if(!L.active)return;let _=L.x-q,H=L.y-z,O=I(J.lungeDir),D=F(J.lungeDir),Y=_*O+H*D;if(Y<-15-L.r||Y>M+L.r)return;if(GJ(_*-D+H*O)<K+L.r)L.active=!1,h(L.x,L.y,"#f0f",3,80)}),J.lv.c>0)J._aftershockEnd={x:q,y:z,w:K};if(J.lungeTimer<=0){J.lungeTimer=0,J.lungeProg=0;let L=W(J.lv.c|0,0,2);if(L>0&&J._aftershockEnd){let _=[0,2,3][L],H=[0,1.8,2.5][L],O=J.lungeStartX,D=J.lungeStartY,Y=J._aftershockEnd.x,U=J._aftershockEnd.y;q0(O,D,Y,U,J._aftershockEnd.w*1.1,_,H)}J._aftershockEnd=null,h(N.x,N.y,"#f0f",8,120),DJ(4)}}}function J1(J,$,Q){let V=0.4*(1-C.cdReduction);if(J.swingCD>0||J.lungeTimer>0)return;if(J.swingCD=V,J.lungeDir=N.angle,J.lungeDist=[120,160,200,250][J.lv.a],J.lungeStartX=N.x,J.lungeStartY=N.y,J.lungeTimer=0.18,J.lungeProg=0,J._aftershockEnd=null,N0())M0(J.lungeDir,J);h(N.x+I(J.lungeDir)*15,N.y+F(J.lungeDir)*15,"#f0f",6,100)}function Z1(J){let V=J.lungeTimer>0?J.lungeDir:N.angle,K=V+G/2;if(J.lungeTimer>0){let{lungeProg:q,lungeDist:z}=J,R=[35,50,60,75][J.lv.b];Z.save();let{lungeStartX:M,lungeStartY:L}=J,_=M+I(V)*z*q,H=L+F(V)*z*q,O=R*0.65,D=R*1.05,Y=B(8,R*0.2),U=Z.createLinearGradient(M,L,_,H);U.addColorStop(0,"rgba(255,120,255,0)"),U.addColorStop(0.35,"rgba(255,120,255,.08)"),U.addColorStop(1,"rgba(255,180,255,.18)"),Z.beginPath(),Z.moveTo(M+I(K)*O,L+F(K)*O),Z.quadraticCurveTo((M+_)*0.5+I(K)*Y,(L+H)*0.5+F(K)*Y,_+I(K)*D,H+F(K)*D),Z.lineTo(_-I(K)*D,H-F(K)*D),Z.quadraticCurveTo((M+_)*0.5-I(K)*Y,(L+H)*0.5-F(K)*Y,M-I(K)*O,L-F(K)*O),Z.closePath(),Z.fillStyle=U,Z.globalAlpha=1,Z.fill(),Z.strokeStyle="rgba(255,120,255,.24)",Z.lineWidth=1.2,Z.stroke(),Z.restore(),Z.save();for(let JJ=0;JJ<5;JJ++){let vJ=JJ/5,KJ=x(M,_,vJ),ZJ=x(L,H,vJ),zJ=(JJ%2===0?1:-1)*R*0.5;Z.beginPath(),Z.moveTo(KJ+I(K)*zJ,ZJ+F(K)*zJ),Z.lineTo(KJ+I(K)*zJ-I(V)*15,ZJ+F(K)*zJ-F(V)*15),Z.strokeStyle="#f0f",Z.lineWidth=1.5,Z.globalAlpha=0.25*(1-vJ),Z.stroke()}Z.restore();let E=V+(-G/2+G*q),T=E+G/2,n=N.x+I(E)*10,i=N.y+F(E)*10,y=N.x+I(E)*70,a=N.y+F(E)*70,w=[{x:n+I(T)*4,y:i+F(T)*4},{x:n-I(T)*4,y:i-F(T)*4},{x:y-I(T)*1.5,y:a-F(T)*1.5},{x:y+I(E)*6,y:a+F(E)*6},{x:y+I(T)*1.5,y:a+F(T)*1.5}];YJ(w,"#f0f",!0,5),Z.save(),Z.lineCap="round";let t=7;for(let JJ=1;JJ<=t;JJ++){let vJ=B(0,q-JJ*0.05),KJ=V+(-G/2+G*vJ),ZJ=1-JJ/t,zJ=F(j.time*20+JJ*0.9)*2.2*ZJ,S=I(KJ+G/2),u=F(KJ+G/2),o=N.x+I(KJ)*10+S*zJ,$J=N.y+F(KJ)*10+u*zJ,QJ=N.x+I(KJ)*70+S*zJ*1.4,FJ=N.y+F(KJ)*70+u*zJ*1.4,_J=(o+QJ)*0.5+S*(6+2*ZJ),SJ=($J+FJ)*0.5+u*(6+2*ZJ),IJ=Z.createLinearGradient(o,$J,QJ,FJ);IJ.addColorStop(0,"rgba(255,120,255,0)"),IJ.addColorStop(0.35,"rgba(255,120,255,"+(0.08+0.15*ZJ)+")"),IJ.addColorStop(1,"rgba(255,255,255,"+(0.05+0.15*ZJ)+")"),Z.strokeStyle=IJ,Z.lineWidth=2.2+3.4*ZJ,Z.beginPath(),Z.moveTo(o,$J),Z.quadraticCurveTo(_J,SJ,QJ,FJ),Z.stroke()}Z.restore()}else{let q=N.x+I(V)*14,z=N.y+F(V)*14,R=N.x+I(V)*56,M=N.y+F(V)*56,L=[{x:q+I(K)*2.5,y:z+F(K)*2.5},{x:q-I(K)*2.5,y:z-F(K)*2.5},{x:R-I(K)*1,y:M-F(K)*1},{x:R+I(V)*4,y:M+F(V)*4},{x:R+I(K)*1,y:M+F(K)*1}];YJ(L,"#f0f",!0,2)}}function 
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
(J,$){J.shotCD=B(0,J.shotCD-$);let Q=[1.5,1,0.8,0.6][J.lv.b];if(J.maxCharge=Q,J.charging)J.chargeTime=r(J.chargeTime+$,Q)}function Q1(J){if(J.shotCD<=0)J.charging=!0}function V1(J){if(!J.charging)return;if(J.charging=!1,J.shotCD>0){J.chargeTime=0;return}let{chargeTime:$,maxCharge:Q}=J,V=W($/Q,0,1),K=N.angle,q=1,z=10+V*18;for(let R=0;R<q;R++){let M=(R-(q-1)/2)*z;RZ(J,V,K,M,1,1,1,"#ff0");let L=W(J.lv.a|0,0,2);for(let _=1;_<=L;_++){let H=0.07*_;RZ(J,V,K+H,M,0.5,0.7,0.85,"#ffd84a"),RZ(J,V,K-H,M,0.5,0.7,0.85,"#ffd84a")}}J.chargeTime=0,J.shotCD=0.22,DJ(2+V*4),JZ(0.04,0.7+V*0.3),h(N.x+I(K)*22,N.y+F(K)*22,"#fff",8,140)}var K1={dagger:t0,sword:J1,bow:Q1},z1={bow:V1};function q1(J){if(J.charging){let $=W(J.chargeTime/J.maxCharge,0,1),Q=18+$*10,V=N.angle,K=N.x+I(V)*(Q+2),q=N.y+F(V)*(Q+2),z=V+G/2;Z.save();let R=K+I(V)*(5+$*3),M=q+F(V)*(5+$*3),L=K+I(z)*(2+$*1.5),_=q+F(z)*(2+$*1.5),H=K-I(z)*(2+$*1.5),O=q-F(z)*(2+$*1.5);Z.beginPath(),Z.moveTo(R,M),Z.lineTo(L,_),Z.lineTo(H,O),Z.closePath(),Z.fillStyle="#ff0",Z.globalAlpha=0.35+0.4*$,Z.shadowColor="#ff0",Z.shadowBlur=8+10*$,Z.fill(),Z.beginPath(),Z.arc(N.x,N.y,Q,0,v),Z.strokeStyle="#ffd84a",Z.lineWidth=1.2+$*1.2,Z.globalAlpha=0.3+$*0.5,Z.stroke(),Z.beginPath(),Z.arc(N.x,N.y,Q*0.55,0,v),Z.strokeStyle="#fff",Z.lineWidth=0.9+$*0.9,Z.globalAlpha=0.25+$*0.45,Z.stroke(),Z.restore()}}function j1(J,$){if(L1($),J.timer-=$*(1-C.cdReduction),J.timer<=0){let Q=J.range,V=J.chains+[0,3,3][J.lv.a],K=[1,2,3][J.lv.b]||1,q=J.lv.c,z=!1;if(LJ.each((M)=>{if(M.active&&A(N.x,N.y,M.x,M.y)<Q)z=!0}),!z)return;J.timer=0.8,J._zigzags=[],J._targets=[];let R=new Set;for(let M=0;M<K;M++){let L=new Set,_=[],H={x:N.x,y:N.y};if(M>0){let D=v/K*M;H={x:N.x+I(D)*15,y:N.y+F(D)*15}}for(let D=0;D<V;D++){let Y=null,U=Q+(D>0?100:0);if(LJ.each((E)=>{if(!E.active||L.has(E)||R.has(E))return;let T=A(H.x,H.y,E.x,E.y);if(T<U)U=T,Y=E}),!Y)break;if(L.add(Y),R.add(Y),_.push({x:Y.x,y:Y.y}),h(Y.x,Y.y,"#a0f",3,80),Y.active=!1,q>0){let E=[0,3,5][q],T=[0,25,40][q];R1(Y.x,Y.y,E,T)}H={x:Y.x,y:Y.y}}J._targets=J._targets.concat(_);let O=M>0?{x:N.x+I(v/K*M)*15,y:N.y+F(v/K*M)*15}:{x:N.x,y:N.y};for(let D of _){let Y=M1(O.x,O.y,D.x,D.y,8);J._zigzags.push(Y),O={x:D.x,y:D.y}}}J._arcTimer=0.45}if(J._arcTimer>0)J._arcTimer-=$}if(!window._staticFields)window._staticFields=[];var AZ=200;function R1(J,$,Q,V){if(window._staticFields.length>=AZ)return;let K=3+Math.floor(Math.random()*3);for(let q=0;q<K;q++){if(window._staticFields.length>=AZ)break;let z=Math.random()*v,R=Math.random()*V;window._staticFields.push({x:J+I(z)*R,y:$+F(z)*R,life:Q,maxLife:Q,r:V,stunDur:0.15,vx:(Math.random()-0.5)*20,vy:(Math.random()-0.5)*20,size:2+Math.random()*3})}}function L1(J){let $=window._staticFields;for(let Q=$.length-1;Q>=0;Q--){let V=$[Q];if(V.life-=J,V.x+=V.vx*J,V.y+=V.vy*J,V.vx*=0.95,V.vy*=0.95,V.vx+=(Math.random()-0.5)*40*J,V.vy+=(Math.random()-0.5)*40*J,V.life<=0){$.splice(Q,1);continue}if(V._checkT=(V._checkT||0)-J,V._checkT>0)continue;V._checkT=0.2,m.each((K)=>{if(!K.active)return;if(A(V.x,V.y,K.x,K.y)<K.r+8){if(j.time-(K._lastStaticStun||0)<3)return;let q=K.isBoss?0.2:1;K.cc.stunT=B(K.cc.stunT,V.stunDur*q),K._lastStaticStun=j.time}})}}function N1(){for(let J of window._staticFields){let $=W(J.life/J.maxLife,0,1);Z.save(),Z.globalAlpha=$*0.8,Z.beginPath(),Z.arc(J.x,J.y,J.size*$,0,v),Z.fillStyle="#c6f",Z.fill(),Z.beginPath(),Z.arc(J.x,J.y,J.size*$*2,0,v),Z.fillStyle="#a0f",Z.globalAlpha=$*0.15,Z.fill(),Z.restore()}}function M1(J,$,Q,V,K){let q=[{x:J,y:$}],z=Q-J,R=V-$,M=b(z*z+R*R),L=-R/M,_=z/M;for(let H=1;H<K;H++){let O=H/K,D=J+z*O,Y=$+R*O,U=(Math.random()-0.5)*M*0.18;q.push({x:D+L*U,y:Y+_*U})}return q.push({x:Q,y:V}),q}function F1(J){if(J._arcTimer>0&&J._zigzags){let $=W(J._arcTimer/0.45,0,1);Z.save();for(let Q of J._zigzags){Z.beginPath(),Z.moveTo(Q[0].x,Q[0].y);for(let K=1;K<Q.length;K++)Z.lineTo(Q[K].x,Q[K].y);Z.strokeStyle="#a0f",Z.lineWidth=6,Z.globalAlpha=$*0.25,Z.shadowColor="#a0f",Z.shadowBlur=15,Z.stroke(),Z.beginPath(),Z.moveTo(Q[0].x,Q[0].y);for(let K=1;K<Q.length;K++)Z.lineTo(Q[K].x,Q[K].y);Z.strokeStyle="#c6f",Z.lineWidth=3,Z.globalAlpha=$*0.6,Z.shadowBlur=8,Z.stroke(),Z.beginPath(),Z.moveTo(Q[0].x,Q[0].y);for(let K=1;K<Q.length;K++)Z.lineTo(Q[K].x,Q[K].y);Z.strokeStyle="#eaf",Z.lineWidth=1.5,Z.globalAlpha=$,Z.shadowBlur=4,Z.stroke();let V=Q[Q.length-1];Z.beginPath(),Z.arc(V.x,V.y,4*$,0,v),Z.fillStyle="#fff",Z.globalAlpha=$*0.8,Z.shadowBlur=10,Z.fill()}Z.restore()}}function _1(J,$){if(J.timer-=$*(1-C.cdReduction),J.timer<=0){J.timer=2.2;let Q=null,V=9999;m.each((z)=>{if(!z.active)return;let R=A(N.x,N.y,z.x,z.y);if(R<V)V=R,Q=z});let K;if(Q)K=k(Q.y-N.y,Q.x-N.x);else K=N.angle;let q=350;gJ.spawn((z)=>{z.x=N.x+I(K)*16,z.y=N.y+F(K)*16,z.vx=I(K)*q,z.vy=F(K)*q,z.r=6,z.life=5,z.maxLife=5,z.type="normal",z.color="#f80",z.spawnTime=j.time,z.damage=0,z.pierce=0,z.reflected=!1,z.split=!1,z.echoed=!1,z.baseSpeed=q,z.curve=0,z.pulseAmp=0,z.src="rocket",z._homing=!0,z._homingDelay=0}),J.lastFired=j.time}gJ.each((Q)=>{if(!Q.active||Q.src!=="rocket"&&Q.src!=="rocket_mini"||!Q._homing)return;if(Q._homingDelay>0){Q._homingDelay-=$;return}let V=null,K=800;if(m.each((q)=>{if(!q.active)return;let z=A(Q.x,Q.y,q.x,q.y);if(z<K)K=z,V=q}),V){let q=k(V.y-Q.y,V.x-Q.x),z=k(Q.vy,Q.vx),R=DZ(q-z),M=Q.src==="rocket_mini"?4:3.5,L=W(R,-M*$,M*$),_=z+L,H=b(Q.vx*Q.vx+Q.vy*Q.vy);Q.vx=I(_)*H,Q.vy=F(_)*H}})}function I1(J){}function H1(J,$){let Q=j.weapons.find((z)=>z.id==="rocket");if(!Q)return;let V=Q.blastR+[0,30,50][Q.lv.c],K=Q.kbForce+[0,40,80,120][Q.lv.a],q=[0.5,0.8,1.2,1.5][Q.lv.a]||0.5;if(h(J,$,"#f80",25,250),h(J,$,"#ff4",15,180),DJ(8),!j._rocketRings)j._rocketRings=[];if(j._rocketRings.push({x:J,y:$,r:V,life:0.3,maxLife:0.3}),LJ.each((z)=>{if(!z.active)return;if(A(J,$,z.x,z.y)<V)z.active=!1,h(z.x,z.y,"#f80",2,60)}),m.each((z)=>{if(!z.active)return;if(A(J,$,z.x,z.y)<V+z.r){MJ(z,1,"rocket");let M=z.isBoss?0.4:1,L=k(z.y-$,z.x-J);z.cc.kbVx=I(L)*K*M,z.cc.kbVy=F(L)*K*M,z.cc.disorientT=q*M}}),Q.lv.b>0){let z=[0,5,7][Q.lv.b];for(let R=0;R<z;R++){let M=v/z*R;gJ.spawn((L)=>{L.x=J+I(M)*10,L.y=$+F(M)*10,L.vx=I(M)*220,L.vy=F(M)*220,L.r=3,L.life=2,L.maxLife=2,L.type="normal",L.color="#fa0",L.spawnTime=j.time,L.damage=1,L.pierce=0,L.reflected=!1,L.split=!1,L.echoed=!1,L.baseSpeed=220,L.curve=0,L.pulseAmp=0,L.src="rocket_mini",L._homing=!0,L._homingDelay=0.35})}}}function O1(J,$){let Q=J.droneCount+[0,1,2][J.lv.a],V=J.droneRange,K=[1.5,2.5,3.5][J.lv.b],q=[0,0.2,0.4][J.lv.c]||0,z=[1.5,0.9,0.7][J.lv.d]||1.5;while(J._drones.length<Q)J._drones.push({angle:v/Q*J._drones.length,orbitR:60+J._drones.length*15,pulseT:0,x:N.x,y:N.y});let R=250;for(let M=0;M<J._drones.length;M++){let L=J._drones[M];if(!L.x)L.x=N.x;if(!L.y)L.y=N.y;L.pulseT=B(0,L.pulseT-$);let _=null,H=400;m.each((Y)=>{if(!Y.active)return;let U=A(L.x,L.y,Y.x,Y.y);if(U<H)H=U,_=Y});let O=80;if(_){let Y=k(_.y-L.y,_.x-L.x);L.x+=I(Y)*O*$,L.y+=F(Y)*O*$}else{L.angle+=$*(2.5-M*0.3);let Y=N.x+I(L.angle)*L.orbitR,U=N.y+F(L.angle)*L.orbitR;L.x=x(L.x,Y,4*$),L.y=x(L.y,U,4*$)}let D=A(L.x,L.y,N.x,N.y);if(D>R){let Y=k(N.y-L.y,N.x-L.x);L.x+=I(Y)*(D-R)*3*$,L.y+=F(Y)*(D-R)*3*$}if(LJ.each((Y)=>{if(!Y.active)return;if(A(L.x,L.y,Y.x,Y.y)<V){let E=b(Y.vx*Y.vx+Y.vy*Y.vy);if(E>50){let T=k(Y.vy,Y.vx),n=E*(1-0.4*$*3);Y.vx=I(T)*n,Y.vy=F(T)*n}}}),L._fireT=(L._fireT||0)-$*(1-C.cdReduction),L._fireT<=0){L._fireT=z;let Y=!1;m.each((U)=>{if(!U.active||Y)return;if(A(L.x,L.y,U.x,U.y)<V+U.r){let E=U.isBoss?0.3:1;if(!U.isBoss)U.cc.silenceT=B(U.cc.silenceT,K*E);if(q>0)U.cc.slowAmt=B(U.cc.slowAmt,q),U.cc.slowT=B(U.cc.slowT,K*E);MJ(U,1,"drone"),Y=!0,L.pulseT=0.3,h(L.x,L.y,"#0aa",5,80)}})}}J.timer=J._drones[0]?J._drones[0]._fireT:0}function D1(J){for(let $ of J._drones){Z.save();let Q=$.pulseT>0?1+$.pulseT*2:1;if(Z.beginPath(),Z.arc($.x,$.y,6*Q,0,v),Z.fillStyle="#0aa",Z.globalAlpha=0.6,Z.fill(),Z.strokeStyle="#0ff",Z.lineWidth=1.5,Z.globalAlpha=0.8,Z.stroke(),Z.beginPath(),Z.arc($.x,$.y,3*Q,0,v),Z.fillStyle="#fff",Z.globalAlpha=0.5,Z.fill(),Z.beginPath(),Z.arc($.x,$.y,J.droneRange,0,v),Z.strokeStyle="#0aa",Z.lineWidth=0.5,Z.globalAlpha=0.1,Z.stroke(),$.pulseT>0){let V=J.droneRange*(1-$.pulseT/0.3);Z.beginPath(),Z.arc($.x,$.y,V,0,v),Z.strokeStyle="#0ff",Z.lineWidth=2,Z.globalAlpha=$.pulseT/0.3*0.4,Z.stroke()}Z.restore()}}function Y1(J,$){let Q=J.count+[0,1,2][J.lv.a],V=[0.3,0.45,0.6][J.lv.b],K=[3,5,7][J.lv.c],q=J.bounces+[0,2,2,2][J.lv.d];if(J.timer-=$*(1-C.cdReduction),J.timer<=0){J.timer=1.2;for(let z=0;z<Q;z++){let R=null,M=1/0;if(m.each((_)=>{if(!_.active)return;let H=A(N.x,N.y,_.x,_.y);if(!J._shurikens.some((D)=>D.target===_)||!R){if(H<M)M=H,R=_}}),!R)break;let L=k(R.y-N.y,R.x-N.x);J._shurikens.push({x:N.x,y:N.y,vx:I(L)*1400,vy:F(L)*1400,target:R,life:4,markAmp:V,markDur:K,angle:0,bouncesLeft:q,hitSet:new Set})}}for(let z=J._shurikens.length-1;z>=0;z--){let R=J._shurikens[z];if(R.life-=$,R.angle+=$*12,R.life<=0){J._shurikens.splice(z,1);continue}if(R.target&&R.target.active){let M=k(R.target.y-R.y,R.target.x-R.x),L=k(R.vy,R.vx),_=DZ(M-L),H=W(_,-12*$,12*$),O=L+H,D=b(R.vx*R.vx+R.vy*R.vy);R.vx=I(O)*D,R.vy=F(O)*D}else{let M=null,L=1/0;if(m.each((_)=>{if(!_.active||R.hitSet.has(_))return;let H=A(R.x,R.y,_.x,_.y);if(H<L)L=H,M=_}),M)R.target=M}R.x+=R.vx*$,R.y+=R.vy*$,m.each((M)=>{if(!M.active||R.hitSet.has(M))return;if(A(R.x,R.y,M.x,M.y)<M.r+6){R.hitSet.add(M);let L=M.isBoss?0.4:1;if(M.cc.markT=B(M.cc.markT,R.markDur*L),M.cc.markAmp=B(M.cc.markAmp,R.markAmp),MJ(M,1,"shuriken"),h(R.x,R.y,"#bbb",5,80),R.bouncesLeft>0){R.bouncesLeft--;let _=null,H=1/0;if(m.each((O)=>{if(!O.active||R.hitSet.has(O))return;let D=A(R.x,R.y,O.x,O.y);if(D<H)H=D,_=O}),_){R.target=_;let O=k(_.y-R.y,_.x-R.x),D=b(R.vx*R.vx+R.vy*R.vy);R.vx=I(O)*D,R.vy=F(O)*D,R.life=B(R.life,2)}else J._shurikens.splice(z,1)}else J._shurikens.splice(z,1)}})}}function v1(J){for(let $ of J._shurikens){Z.save(),Z.translate($.x,$.y),Z.rotate($.angle),Z.beginPath();for(let Q=0;Q<4;Q++){let V=v/4*Q;Z.moveTo(0,0),Z.lineTo(I(V)*8,F(V)*8),Z.lineTo(I(V+0.4)*4,F(V+0.4)*4)}Z.strokeStyle="#bbb",Z.lineWidth=2,Z.globalAlpha=0.8,Z.stroke(),Z.beginPath(),Z.arc(0,0,2,0,v),Z.fillStyle="#fff",Z.fill(),Z.restore()}}var dZ={regen:{name:"REGENERATION",color:"#4f4",maxLv:3,desc:["Heal 1HP/14s","1HP/8s","1HP/8s + emergency heal"]},speed:{name:"SPEED BOOST",color:"#4f4",maxLv:3,desc:["+15% speed","+30%","+40% + 8% dodge"]},cooldown:{name:"COOLDOWN REDUCTION",color:"#48f",maxLv:3,desc:["-12% all CDs","-20%","-25% + faster weapons"]},shield:{name:"ENERGY SHIELD",color:"#4af",maxLv:2,desc:["Shield recharges 12s","8s recharge"]},damage:{name:"POWER SURGE",color:"#f44",maxLv:2,desc:["+30% damage","+50% damage"]}},a1=Object.keys(dZ),U1=["regen","speed","cooldown","shield","damage"],B1=["#f66","#f8c","#c8f","#8cf","#a0f","#ff8"],X1=["circle","square","triangle"],W1=["radial","wall","curve_ring","spread","laser_fan","dash_strike"],E1=["shield_nodes","rage","twin_link","warp_portals","summoner"],k1=["shield_nodes","warp_portals","summoner","rage"],T1=["Void","Astral","Iron","Crimson","Aether","Obsidian","Radiant","Grim"],PZ=["Warden","Revenant","Harbinger","Sentinel","Seraph","Tyrant","Overseer","Monarch"],S1=["Prime","Ascendant","Omega","the Hollow","the Unbound","of Ruin","of Echoes","Mk-II"],C1={radial(J){$Z.bossRadial(J)},wall(J){$Z.bossWall(J)},curve_ring(J){for(let $=0;$<5;$++){let Q=J.angle+v/5*$;hJ(J.x,J.y,I(Q)*205,F(Q)*205,4,J.color,"loop",3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:Q})}},spread(J){let $=k(N.y-J.y,N.x-J.x);for(let Q=-3;Q<=3;Q++)hJ(J.x,J.y,I($+Q*0.11)*220,F($+Q*0.11)*220,4,J.color,"normal",2.6)},laser_fan(J,$){$.laserSpin+=0.36;let Q=$.enraged?5:3;for(let V=0;V<Q;V++){let K=$.laserSpin+v/Q*V;D0({owner:J,angle:K,length:B(g,l)*1.9,width:$.enraged?28:22,life:$.enraged?2.1:1.8,color:J.color,rotSpeed:$.enraged?0.75:0.45,warn:$.enraged?1.15:1,warnColor:"#ff9f66"})}},dash_strike(J,$){if($._dashStrike)return;let Q=k(N.y-J.y,N.x-J.x),V=W(A(J.x,J.y,N.x,N.y)+52+($.enraged?20:0),180,360);$._dashStrike={phase:"tele",t:1,maxT:1,sx:J.x,sy:J.y,ex:J.x+I(Q)*V,ey:J.y+F(Q)*V,a:Q,burst:!1},h(J.x,J.y,J.color,8,130)}};function A1(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}function P1(J,$){let Q=J.slice();for(let V=Q.length-1;V>0;V--){let K=UJ(0,V);[Q[V],Q[K]]=[Q[K],Q[V]]}return Q.slice(0,$)}function u1(J){for(let $=J.length-1;$>0;$--){let Q=UJ(0,$);[J[$],J[Q]]=[J[Q],J[$]]}return J}function h1(){if(!j._bossModQueue||j._bossModQueue.length===0)j._bossModQueue=u1(k1.slice());return j._bossModQueue.pop()}function f1(J){if(J.includes("twin_link"))return"Twin "+NJ(PZ)+" "+NJ(["Apex","Prime","Ascendant"]);return NJ(T1)+" "+NJ(PZ)+" "+NJ(S1)}function G1(J,$,Q){let V=RJ()+Q*G,K=B(X,P)+100;J.x=N.x+I(V)*K,J.y=N.y+F(V)*K,J.shape=$.shape,J.color=$.color,J.tier="boss",J.isBoss=!0,J.bossKind="generated",J.bossShape=$.shape,J.bossAccessory=$.accessory,J.bossName=$.name,J.bossMods=$.mods,J.bossAttacks=$.attacks,J.r=$.r,J.hp=$.hp,J.maxHp=$.hp,J.fireCD=$.fireCD,J.fireTimer=0.45+Q*0.2,J.hitFlash=0,J.angle=0,J.spawnTime=j.time,J.moveParams={speed:$.moveSpeed},J.fireParams={count:10,offset:0},J.cc=A1(),J.shieldHP=0,J._dashInvuln=0,J._role=$.mods.includes("twin_link")&&Q===1?"melee":"ranged",J._twinIdx=Q,J._twinPartner=null,J.moveType="chaser",J.firePattern="bossAimed"}function g1(J){return{timer:0,attackIdx:0,laserSpin:RJ(),shieldNodes:[],enraged:!1,linkBeam:!1,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,update($,Q){if(this.timer+=Q,$.angle+=Q*(this.enraged?1.8:1.1),this._dashStrike){let z=this._dashStrike;if(z.phase==="tele"){if(z.t-=Q,$._dashInvuln=B($._dashInvuln,0.1),$._dashTele={t:z.t,maxT:z.maxT,tx:z.ex,ty:z.ey},z.t<=0)z.phase="dash",z.t=0.32,z.maxT=0.32,z.sx=$.x,z.sy=$.y,$._dashTele=null}else{z.t-=Q;let R=W(1-z.t/z.maxT,0,1),M=1-(1-R)*(1-R);if($.x=x(z.sx,z.ex,M),$.y=x(z.sy,z.ey,M),$._dashInvuln=B($._dashInvuln,0.3),(this.timer*45|0)%2===0)h($.x,$.y,$.color,2,70);if(z.t<=0){if($.x=z.ex,$.y=z.ey,!z.burst){z.burst=!0,h($.x,$.y,$.color,10,160);for(let L=0;L<10;L++){let _=v/10*L+z.a*0.35;hJ($.x,$.y,I(_)*230,F(_)*230,4,$.color,"normal",0.9)}}this._dashStrike=null}}return}let V=k(N.y-$.y,N.x-$.x),K=A($.x,$.y,N.x,N.y),q=$.moveParams.speed;if($._role==="melee"){let z=170+$._twinIdx*20;if(K>z+25)$.x+=I(V)*q*Q,$.y+=F(V)*q*Q;else{let R=V+($._twinIdx===0?G/2:-G/2);$.x+=I(R)*q*0.7*Q,$.y+=F(R)*q*0.7*Q}}else $.x+=I(V)*q*0.35*Q,$.y+=F(V)*q*0.35*Q;if(J.mods.includes("shield_nodes")&&$.hp<$.maxHp*0.6&&this.shieldNodes.length===0){for(let z=0;z<4;z++)this.shieldNodes.push({angle:v/4*z,hp:12,lastHit:j.time});j.bannerTimer=0.9,j.bannerText="BOSS SHIELD NODES",j.bannerColor=$.color,j.waveModTimer=4,j.waveModText="SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed."}for(let z of this.shieldNodes)z.angle+=Q*0.7;if(J.mods.includes("rage")&&$.hp<$.maxHp*0.35&&!this.enraged){if(this.enraged=!0,$.fireCD*=0.72,!$._baseColor)$._baseColor=$.color;$.color="#f33",j.bannerTimer=1.1,j.bannerText="BOSS ENRAGED",j.bannerColor=$.color}if(J.mods.includes("twin_link"))this.linkTimer+=Q,this.linkBeam=this.linkTimer%3.6<2.2;if(J.mods.includes("warp_portals")){if(this._warpTele){if(this._warpTele.t-=Q,this._warpTele.t<=0){let z=this._warpTele;this._warpTele=null;let{x:R,y:M}=$;$.x=z.toX,$.y=z.toY;for(let L=0;L<8;L++){let _=v/8*L;hJ(R,M,I(_)*150,F(_)*150,4,$.color,"normal",2.8)}this._portals.push({x1:R,y1:M,x2:z.toX,y2:z.toY,life:0.25}),h(R,M,$.color,10,120),h(z.toX,z.toY,$.color,10,120)}}else if(this.warpTimer+=Q,this.warpTimer>this.warpCD){this.warpTimer=0;let z=RJ(),R=e(120,240);this._warpTele={toX:N.x+I(z)*R,toY:N.y+F(z)*R,t:1,maxT:1}}}for(let z=this._portals.length-1;z>=0;z--)if(this._portals[z].life-=Q,this._portals[z].life<=0)this._portals.splice(z,1);if(J.mods.includes("summoner")){if(this.summonTimer+=Q,this.summonTimer>(this.enraged?6:8)){this.summonTimer=0;let z=this.enraged?2:1;for(let R=0;R<z;R++){let M=RJ(),L=e(90,170);lZ("small",{x:$.x+I(M)*L,y:$.y+F(M)*L,moveType:"converge",moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:$.color})}}}},fire($){if($._role==="melee")return;let Q=J.attacks[this.attackIdx%J.attacks.length];this.attackIdx++;let V=C1[Q];if(V)V($,this);if(J.mods.includes("warp_portals")&&this._portals.length&&Q!=="laser_fan")for(let K of this._portals)for(let q=0;q<5;q++){let z=v/5*q;hJ(K.x1,K.y1,I(z)*130,F(z)*130,3.5,$.color,"curve",2.6,{curve:0.3})}}}}function m1(){let J=[h1()],$=["twin_link","warp_portals"],Q=r(4,1+qJ(B(0,j.wave-1)/4));while(J.length<Q){let O=E1.filter((D)=>!J.includes(D));if(J.some((D)=>$.includes(D)))O=O.filter((D)=>!$.includes(D));if(!O.length)break;J.push(NJ(O))}let V=P1(W1,J.includes("twin_link")?2:3),K=NJ(X1),q=NJ(B1),z=UJ(0,2),R=qJ((190+j.wave*85+j.wave*j.wave*22+UJ(-40,60))*0.5),M=UJ(34,48),L=e(0.9,1.45)*B(0.52,1-j.wave*0.02),_=e(70,105)+j.wave*1.3,H=f1(J);return{mods:J,attacks:V,shape:K,color:q,accessory:z,hp:R,r:M,fireCD:L,moveSpeed:_,name:H}}function y1(){let J=m1();if(!J.mods.includes("summoner"))m.each((V)=>{if(V.active&&!V.isBoss)V.active=!1}),LJ.clear();let $=J.mods.includes("twin_link"),Q=[];for(let V=0;V<($?2:1);V++)m.spawn((K)=>{G1(K,J,V),K.bossAI=g1(J),Q.push(K)});if(Q.length===2)Q[0]._twinPartner=Q[1],Q[1]._twinPartner=Q[0],j._twinBoss=Q;else j._twinBoss=null;j.bossEntity=Q[0],j.bannerTimer=2,j.bannerText="BOSS: "+J.name,j.bannerColor=J.color}var cJ=0;function w1(J){if(j.waveState==="spawning"){if(cJ-=J,cJ<=0){let $=6+j.wave*2.4+j.difficulty*1.2;if(m.count()<$)lZ(Math.random()<0.1+j.wave*0.02?"elite":"small");cJ=B(0.16,1.65-j.wave*0.11-j.difficulty*0.1-j.wave*j.wave*0.0015)}if(j.waveKills>=j.waveQuota)j.waveState="encounter",j._bossSpawnPending=!0,j.killFlash=B(j.killFlash,0.16),setTimeout(()=>{y1(),j._bossSpawnPending=!1},120)}else if(j.waveState==="encounter"){if(j._bossSpawnPending)return;let $=!0;if(m.each((Q)=>{if(Q.isBoss)$=!1}),$)j.waveState="clear",LJ.clear(),h(N.x,N.y,"#fff",30,250),DJ(10),JZ(0.3,0.3),j.bannerTimer=2,j.bannerText="WAVE "+j.wave+" CLEAR!",j.bannerColor="#0ff",setTimeout(()=>pZ(),2000)}if(j.frozen){if(j.freezeTimer-=J,j.freezeTimer<=0)j.frozen=!1}if(p)p.tick(J)}function pZ(){if(j.wave++,j.waveKills=0,j.waveQuota=r(16,4+j.wave*2),j.difficulty=0.8+j.wave*0.5+j.wave*j.wave*0.02,j.waveState="spawning",p)p.unapply();h0(u0()),j.waveBannerTimer=2,j.waveBannerText="WAVE "+j.wave,j.waveBannerSub=p?p.name:"",j.waveModTimer=3,j.waveModText=p?p.desc:""}function MJ(J,$,Q,V){if(!J.active)return;if(J._dashInvuln>0)return;let K=$,q=Q==="shuriken";if(q)K=1;if(!q&&J.cc.markAmp>0)K*=1+J.cc.markAmp;let z=V||!1;if(!q&&!z&&C.critChance>0&&Math.random()<C.critChance)z=!0,K*=C.critMult;if(!q)K*=C.dmgMult;if(!q&&J.cc.markT>0)K*=1+J.cc.markAmp;if(J.isBoss&&J.bossAI&&J.bossAI.shieldNodes&&J.bossAI.shieldNodes.some((R)=>R.hp>0)){let R=null,M=1/0,L=0,_=0;for(let H of J.bossAI.shieldNodes){if(H.hp<=0)continue;if(H.hp<M)M=H.hp,R=H}if(R){L=J.x+I(R.angle)*(J.r+24),_=J.y+F(R.angle)*(J.r+24);let H=B(1,K*0.9);if(R.hp=B(0,R.hp-H),R.lastHit=j.time,h(L,_,"#9ef",8,140),EZ(L,_,H|0,!1),!J.bossAI.shieldNodes.some((O)=>O.hp>0))j.bannerTimer=1.2,j.bannerText="SHIELD BROKEN",j.bannerColor="#9ef"}return}if(J.hp-=K,J.hitFlash=1,EZ(J.x,J.y,K|0,z),h(J.x,J.y,J.color,3,80),J.hp<=0)rZ(J)}function rZ(J){if(!J.active)return;J.active=!1;let $=15,Q=450,K=(J.isBoss?Q:J.tier==="elite"?55:$)*C.xpMult;j.xp+=K;while(j.xp>=j.xpToNext&&j.xpToNext>0)j.xp-=j.xpToNext,j.level++,j.xpToNext=qJ((100+j.level*100)*GZ),j.levelUpQueue++;if(j.totalKills++,j.waveKills++,J.isBoss||J.tier==="elite")j.killFlash=0.05;if(J.shape==="circle")for(let q=0;q<12;q++){let z=v/12*q;bJ(J.x,J.y,I(z)*200,F(z)*200,J.color,0.3,2)}else if(J.shape==="square")for(let q=0;q<8;q++){let z=G/4+v/8*q;bJ(J.x+I(z)*J.r,J.y+F(z)*J.r,I(z)*150,F(z)*150,J.color,0.3,3)}else for(let q=0;q<3;q++){let z=v/3*q;for(let R=0;R<4;R++)bJ(J.x,J.y,I(z+e(-0.3,0.3))*(100+R*50),F(z+e(-0.3,0.3))*(100+R*50),J.color,0.3,2)}if(J.isBoss)if(h(J.x,J.y,"#fff",40,300),h(J.x,J.y,J.color,30,250),DJ(15),JZ(0.5,0.3),j._twinBoss&&J._twinIdx!==void 0){let q=J._twinPartner;if(q&&q.active)j.bossEntity=q;else j.bossEntity=null,j._twinBoss=null}else j.bossEntity=null;else h(J.x,J.y,J.color,15,180),DJ(J.tier==="elite"?8:3),JZ(0.06,0.5)}function o1(){if(!N.alive)return;if(gJ.each((J)=>{if(!J.active)return;m.each(($)=>{if(!$.active)return;if($.isBoss&&$.bossAI&&$.bossAI.shieldNodes&&$.bossAI.shieldNodes.some((Q)=>Q.hp>0))for(let Q of $.bossAI.shieldNodes){if(Q.hp<=0)continue;let V=$.x+I(Q.angle)*($.r+24),K=$.y+F(Q.angle)*($.r+24);if(A(J.x,J.y,V,K)<J.r+10){Q.hp=B(0,Q.hp-B(1,J.damage*1.1)),Q.lastHit=j.time,h(V,K,"#f99",6,120),J.active=!1;return}}if(A(J.x,J.y,$.x,$.y)<J.r+$.r){if(J.src==="rocket"){J.active=!1,H1(J.x,J.y);return}if(J.src==="rocket_mini"){J.active=!1,h(J.x,J.y,"#fa0",8,100),DJ(2),m.each((Q)=>{if(!Q.active)return;if(A(J.x,J.y,Q.x,Q.y)<40+Q.r){MJ(Q,1,"rocket");let V=k(Q.y-J.y,Q.x-J.x);Q.cc.kbVx+=I(V)*80,Q.cc.kbVy+=F(V)*80}});return}if(MJ($,J.damage,J.src||"bullet"),J.pierce>0)J.pierce--;else if(!j.pierce)J.active=!1}})}),N.invuln<=0)LJ.each((J)=>{if(!J.active)return;if(A(J.x,J.y,N.x,N.y)<J.r+N.r){if(C.dodgeChance>0&&Math.random()<C.dodgeChance)return;J.active=!1,QZ()}}),m.each((J)=>{if(!J.active)return;if(A(J.x,J.y,N.x,N.y)<J.r+N.r)QZ()})}function QZ(){if(N.invuln>0||!N.alive)return;if(N.shieldUp){N.shieldUp=!1,N.shieldCD=C.shieldRecharge,N.invuln=0.3,h(N.x,N.y,"#4af",12,150),DJ(4);return}if(N.hp--,N.invuln=VJ.invulnDur,N.hitFlash=0.3,DJ(10),h(N.x,N.y,"#0ff",15,200),N.hp<=0)N.alive=!1,h(N.x,N.y,"#0ff",40,300),h(N.x,N.y,"#fff",20,250),DJ(15),OZ.clear(),VZ=!1,KZ=!1,s=null,j.gameOverFade=0,d="gameover"}var TJ=[];function BZ(){let J=[];for(let V of j.weapons){let K=fJ[V.id];if(!K)continue;for(let q of K.upgrades)if(V.lv[q.id]<q.maxLv)J.push({type:"weaponUpg",weaponId:V.id,upgId:q.id,def:q,wdef:K,curLv:V.lv[q.id]})}if(j.weapons.filter((V)=>fJ[V.id].type==="cc").length<2){let V=j.weapons.map((K)=>K.id);for(let K of i0)if(!V.includes(K))J.push({type:"newWeapon",weaponId:K,wdef:fJ[K]})}let Q=Object.keys(j.passives).filter((V)=>j.passives[V]>0).length;for(let V of U1){let K=j.passives[V]||0,q=dZ[V];if(!q)continue;if(K>0&&K<q.maxLv)J.push({type:"passiveUpg",passiveId:V,def:q,curLv:K});else if(K===0&&Q<3)J.push({type:"newPassive",passiveId:V,def:q})}for(let V=J.length-1;V>0;V--){let K=UJ(0,V);[J[V],J[K]]=[J[K],J[V]]}if(TJ=J.slice(0,5),TJ.length<5){let V=[{stat:"dmgMult",name:"+2% Damage",amt:0.02,color:"#f44"},{stat:"moveSpeed",name:"+2% Speed",amt:0.02,color:"#4f4"},{stat:"xpMult",name:"+5% XP Gain",amt:0.05,color:"#ff0"},{stat:"dodgeChance",name:"+1% Dodge",amt:0.01,color:"#4af"},{stat:"cdReduction",name:"+3% Cooldown",amt:0.03,color:"#48f"}];for(let q=V.length-1;q>0;q--){let z=UJ(0,q);[V[q],V[z]]=[V[z],V[q]]}let K=0;while(TJ.length<5){let q=V[K%V.length];K++,TJ.push({type:"microBuff",stat:q.stat,name:q.name,amt:q.amt,color:q.color})}}}function mJ(J){let $=TJ[J];if(!$)return;if($.type==="weaponUpg"){let Q=j.weapons.find((V)=>V.id===$.weaponId);if(Q)Q.lv[$.upgId]++}else if($.type==="newWeapon")j.weapons.push(bZ($.weaponId));else if($.type==="newPassive")j.passives[$.passiveId]=1;else if($.type==="passiveUpg")j.passives[$.passiveId]++;else if($.type==="microBuff"){if(!j._microBuffs)j._microBuffs={};j._microBuffs[$.stat]=(j._microBuffs[$.stat]||0)+$.amt}if(gZ(),j.levelUpQueue--,j.levelUpQueue>0)BZ(),d="levelUp",j.refreshAvailable=1;else d="playing"}function n1(J){J=J||1;let $=P-140-80*(1-J);Z.save(),Z.globalAlpha=J,f("LEVEL UP!  Choose an upgrade",X,$,20,"#ff0","center","middle"),Z.restore();let Q=r(5,TJ.length),V=150,K=140,q=12,z=V*Q+q*(Q-1),R=X-z/2,M=P-60;for(let L=0;L<Q;L++){let _=TJ[L],H=L*0.06,O=W((J-H)/(1-H),0,1),D=O<1?1-Math.pow(1-O,3):1,Y=60*(1-D),U=R+L*(V+q),E=M+Y,T=wJ>=U&&wJ<=U+V&&oJ>=E&&oJ<=E+K,n="#0ff",i="",y="",a=!1,w="",t=0,JJ=0;if(_.type==="weaponUpg")n=_.wdef.color,i=_.wdef.name+": "+_.def.name,y=_.def.desc[_.curLv]||"",t=_.def.maxLv,JJ=_.curLv+1;else if(_.type==="newWeapon"){if(n=_.wdef.color,i=_.wdef.name,y=_.wdef.desc,a=!0,_.wdef.cc)y="CC: "+_.wdef.cc+" — "+y}else if(_.type==="newPassive")n=_.def.color,i=_.def.name,y=_.def.desc[0],a=!0;else if(_.type==="passiveUpg")n=_.def.color,i=_.def.name,y=_.def.desc[_.curLv],t=_.def.maxLv,JJ=_.curLv+1;else if(_.type==="microBuff")n=_.color,i="MINOR BOOST",y=_.name,a=!1;let vJ=T?"#fff":n;if(Z.save(),Z.globalAlpha=(T?1:0.75)*D,Z.fillStyle=T?"rgba(30,60,80,0.9)":"rgba(8,16,24,0.85)",Z.fillRect(U,E,V,K),Z.strokeStyle=vJ,Z.lineWidth=T?2.5:1.5,Z.shadowColor=vJ,Z.shadowBlur=T?15:5,Z.strokeRect(U,E,V,K),Z.restore(),a)Z.save(),Z.fillStyle="#ff0",Z.font="bold 9px monospace",Z.fillText("NEW!",U+V-30,E+12),Z.restore();f(i,U+V/2,E+20,9,vJ,"center","middle"),Z.save(),Z.font="9px monospace",Z.fillStyle="#aaa",Z.textAlign="center",Z.textBaseline="middle";let KJ=y.split(" "),ZJ="",zJ=E+42;for(let S of KJ){let u=ZJ+S+" ";if(Z.measureText(u).width>V-12)Z.fillText(ZJ.trim(),U+V/2,zJ),zJ+=11,ZJ=S+" ";else ZJ=u}if(Z.fillText(ZJ.trim(),U+V/2,zJ),Z.restore(),t>0){let S=E+K-18;for(let u=0;u<t;u++){let o=U+V/2-t*6+u*12+6;Z.save(),Z.beginPath(),Z.arc(o,S,3,0,v),Z.fillStyle=u<JJ?n:"#333",Z.fill(),Z.restore()}}f("["+(L+1)+"]",U+V/2,E+K-8,12,"#555","center","middle")}if(j.refreshAvailable>0){let L=M+K+20,_="#4f4",H=0.7+F(j.time*4)*0.3;Z.save(),Z.globalAlpha=J*H,f("[R] Reroll ("+j.refreshAvailable+" left)",X,L,14,"#4f4","center","middle"),Z.restore()}else{let L=M+K+20;Z.save(),Z.globalAlpha=J*0.3,f("[R] No rerolls left",X,L,12,"#555","center","middle"),Z.restore()}}function iJ(){Z.save(),Z.fillStyle="#000",Z.globalAlpha=0.04;for(let J=0;J<l;J+=4)Z.fillRect(0,J,g,1);Z.restore()}function l1(){let J=Z.createRadialGradient(X,P,r(g,l)*0.3,X,P,r(g,l)*0.7);J.addColorStop(0,"rgba(0,0,0,0)");let $=N.hp<=1&&N.alive;J.addColorStop(1,$?"rgba(80,0,0,0.5)":"rgba(0,0,0,0.35)"),Z.save(),Z.fillStyle=J,Z.fillRect(0,0,g,l),Z.restore()}function b1(){let J=g<900||l<620,$=J?10:14,Q=r(J?g-20:560,g-$*2),V=J?54:56,K=X-Q/2,q=$,z=j.time/60|0,R=j.time%60|0,M=W(N.hp/B(1,N.maxHp),0,1),L=M>0.5?"#00e5ff":M>0.25?"#ffd24a":"#ff4a4a",_=W(j.xp/j.xpToNext,0,1);Z.save(),Z.fillStyle="rgba(0,0,0,0.56)",Z.fillRect(K,q,Q,V),Z.strokeStyle="rgba(255,255,255,0.16)",Z.lineWidth=1,Z.strokeRect(K,q,Q,V),Z.restore();let H=J?22:26,O=K+12+H+6,D=q+9,Y=Q-(12+H+6)-12,U=J?12:13,E=10,T=2,n=(Y-T*(E-1))/E;Z.save();for(let S=0;S<E;S++){let u=O+S*(n+T),o=W(M*E-S,0,1);if(Z.fillStyle="rgba(18,18,18,.95)",Z.fillRect(u,D,n,U),o>0)Z.fillStyle=L,Z.globalAlpha=0.92,Z.fillRect(u,D,n*o,U);Z.strokeStyle="rgba(255,255,255,.25)",Z.globalAlpha=0.7,Z.lineWidth=1,Z.strokeRect(u,D,n,U)}Z.restore();let i=O,y=D+U+6,a=Y,w=J?9:10;Z.save(),Z.fillStyle="rgba(18,18,18,.95)",Z.fillRect(i,y,a,w),Z.fillStyle="#ffdf4a",Z.globalAlpha=0.82,Z.fillRect(i,y,a*_,w),Z.strokeStyle="rgba(255,223,74,.3)",Z.lineWidth=1,Z.globalAlpha=0.75,Z.strokeRect(i,y,a,w),Z.restore(),f("HP",K+12,D+(J?0:-1),J?10:11,"#dff"),f("XP",K+12,y-1,J?10:11,"#ffdf4a");let t=q+V-(J?13:12);if(f("TIME "+z+":"+(R<10?"0":"")+R,K+12,t,J?9:10,"#8ea"),p)f(p.name,K+Q-12,t,J?9:10,p.color,"right");let JJ=q+V+8;if(j.bossEntity&&j.bossEntity.active){let S=j.bossEntity,u=r(J?g-70:460,g-120),o=J?10:12,$J=X-u/2,QJ=JJ,FJ=S.bossName||"BOSS";f(FJ,X,QJ+o+4,J?10:12,S.color,"center","top"),Z.save(),Z.fillStyle="#222",Z.fillRect($J,QJ,u,o);let _J=10,SJ=u/_J;for(let HJ=0;HJ<_J;HJ++){let BJ=(HJ+1)/_J;if(S.hp/S.maxHp>=BJ-1/_J)Z.fillStyle=S.hp/S.maxHp>BJ?"#f44":"#a22",Z.fillRect($J+HJ*SJ+1,QJ+1,SJ-2,o-2)}Z.strokeStyle="#f44",Z.lineWidth=1,Z.globalAlpha=0.55,Z.strokeRect($J,QJ,u,o),Z.restore();let IJ=S.x-c.x+X,rJ=S.y-c.y+P;if(IJ<-10||IJ>g+10||rJ<-10||rJ>l+10){let HJ=k(rJ-P,IJ-X),BJ=X+I(HJ)*r(X-40,P-40),xJ=P+F(HJ)*r(X-40,P-40);Z.save(),Z.translate(BJ,xJ),Z.rotate(HJ),Z.beginPath(),Z.moveTo(12,0),Z.lineTo(-6,-7),Z.lineTo(-6,7),Z.closePath(),Z.fillStyle=S.color,Z.globalAlpha=0.6+F(j.time*5)*0.3,Z.shadowColor=S.color,Z.shadowBlur=8,Z.fill(),Z.restore()}}else if(j.waveState==="spawning"){let S=r(J?g-80:340,g-140),u=X-S/2,o=JJ+1,$J=W(j.waveKills/j.waveQuota,0,1);if(Z.save(),Z.fillStyle="rgba(20,20,20,.92)",Z.fillRect(u,o,S,6),Z.fillStyle="#0ff",Z.globalAlpha=0.65,Z.fillRect(u,o,S*$J,6),Z.strokeStyle="rgba(0,255,255,.3)",Z.lineWidth=1,Z.globalAlpha=0.8,Z.strokeRect(u,o,S,6),Z.restore(),!J)f(j.waveKills+"/"+j.waveQuota,X,o+9,10,"#8ab","center","top")}let vJ={chain:0.8,rocket:2.2,drone:1.5,shuriken:1.2},KJ=J?50:58,ZJ=B(1,j.weapons.length)*KJ,zJ=X-ZJ/2+KJ/2;for(let S=0;S<j.weapons.length;S++){let u=j.weapons[S],o=fJ[u.id],$J=zJ+S*KJ,QJ=l-(J?46:56),FJ=J?38:44,_J=J?26:30;Z.save(),Z.fillStyle="rgba(0,0,0,0.5)",Z.fillRect($J-FJ/2,QJ-_J/2,FJ,_J),Z.strokeStyle=o.color,Z.lineWidth=1,Z.globalAlpha=0.55,Z.strokeRect($J-FJ/2,QJ-_J/2,FJ,_J),Z.restore(),f(o.name.charAt(0),$J,QJ-1,J?12:14,o.color,"center","middle");let SJ=vJ[u.id];if(SJ&&u.timer!==void 0){let IJ=FJ,HJ=$J-FJ/2,BJ=QJ+_J/2+2,xJ=W(1-u.timer/SJ,0,1);if(Z.save(),Z.fillStyle="rgba(0,0,0,.55)",Z.fillRect(HJ,BJ,IJ,4),xJ>=1)Z.fillStyle=o.color,Z.globalAlpha=0.45+0.25*GJ(F(j.time*6));else Z.fillStyle=o.color,Z.globalAlpha=0.45;Z.fillRect(HJ,BJ,IJ*xJ,4),Z.strokeStyle=o.color,Z.globalAlpha=0.22,Z.lineWidth=0.5,Z.strokeRect(HJ,BJ,IJ,4),Z.restore()}}if(j.bannerTimer>0)j.bannerTimer-=0.016666666666666666,Z.save(),Z.globalAlpha=r(1,j.bannerTimer*2),f(j.bannerText,X,P-60,24,j.bannerColor,"center","middle"),Z.restore();if(j.waveBannerTimer>0){j.waveBannerTimer-=0.016666666666666666;let S=r(1,j.waveBannerTimer);Z.save(),Z.globalAlpha=S;let u=30+20*(1-S);if(f(j.waveBannerText,X,P-30,u,"#fff","center","middle"),j.waveBannerSub)f(j.waveBannerSub,X,P+10,16,p?p.color:"#888","center","middle");Z.restore()}if(j.waveModTimer>0&&j.waveModText){j.waveModTimer-=0.016666666666666666;let S=W(j.waveModTimer/3,0,1),u=r(g-40,J?560:760),o=J?46:54,$J=X-u/2,QJ=l-(J?120:150);Z.save(),Z.globalAlpha=0.24*S,Z.fillStyle="#000",Z.fillRect($J,QJ,u,o),Z.globalAlpha=0.4*S,Z.strokeStyle=p?p.color:"#aaa",Z.lineWidth=1.4,Z.strokeRect($J,QJ,u,o),Z.restore(),f("MODIFIER: "+j.waveModText,X,QJ+(J?14:17),J?14:18,p?p.color:"#9ab","center","top")}}var LZ=0;function i1(J){if(LZ+=J,Z.fillStyle="rgba(0,0,0,"+VJ.trailAlpha+")",Z.fillRect(0,0,g,l),Math.random()<0.3){let $=Math.random()*v,Q=r(g,l)*0.3,V=["#0ff","#f0f","#ff0","#4f4"];bJ(X+I($)*Q,P+F($)*Q,I($+G/2)*30,F($+G/2)*30,V[Math.random()*4|0],1,2)}_Z(J),IZ(),Z.save(),Z.strokeStyle="#111d28",Z.lineWidth=0.5,Z.globalAlpha=0.3,Z.beginPath();for(let $=0;$<g;$+=80)Z.moveTo($,0),Z.lineTo($,l);for(let $=0;$<l;$+=80)Z.moveTo(0,$),Z.lineTo(g,$);if(Z.stroke(),Z.restore(),Z.save(),Z.globalAlpha=0.7+F(LZ*3)*0.3,f("NEON PHASES",X,P-80,42,"#0ff","center","middle"),Z.restore(),f("v2 — Waves + Weapons",X,P-40,13,"#888","center","middle"),(LZ*2|0)%2)f("Press ENTER to Start",X,P+10,16,"#fff","center","middle");f("WASD=Move  Mouse=Aim",X,P+50,10,"#888","center","middle"),iJ()}function d1(){Z.fillStyle="rgba(0,0,0,0.85)",Z.fillRect(0,0,g,l),f("CHOOSE YOUR WEAPON",X,60,24,"#0ff","center","middle");let J=pJ.length,$=180,Q=200,V=20,K=$*J+V*(J-1),q=X-K/2,z=P-70;for(let R=0;R<J;R++){let M=pJ[R],L=fJ[M],_=q+R*($+V),H=z,O=wJ>=_&&wJ<=_+<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════
// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};
// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}
// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();
// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}
// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  reflect:false,gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,decay:false,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  shield:[['shieldRecharge','set',[0,12,8]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
const MICRO_EFFECT_MODE={dmgMult:'add',moveSpeed:'mul1',xpMult:'add',dodgeChance:'add',cdReduction:'add_cap'};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}
// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1,shieldRecharge:0};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;stats.shieldRecharge=0;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  // Apply accumulated micro-buffs
  const mb=G._microBuffs;
  if(mb)for(const k in mb)applyStat(k,MICRO_EFFECT_MODE[k]||'add',mb[k]);
}
// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}
// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,reflected:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);
// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}
// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}
// == DAMAGING TRAILS ==
const trails=[];
const MAX_TRAILS=150;
function spawnTrail(x,y,color,dmg,life,radius){
  if(trails.length>=MAX_TRAILS)return;
  if(!Number.isFinite(x)||!Number.isFinite(y))return;
  const trailDmg=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const trailLife=Number.isFinite(life)&&life>0?life:1;
  const trailRadius=Number.isFinite(radius)&&radius>0?radius:10;
  trails.push({x,y,color,dmg:trailDmg,life:trailLife,maxLife:trailLife,r:trailRadius,dmgCD:new Map()});
}
function updateTrails(dt){
  for(let i=trails.length-1;i>=0;i--){
    const t=trails[i];t.life-=dt;
    if(!Number.isFinite(t.life)||!Number.isFinite(t.maxLife)||t.maxLife<=0||!Number.isFinite(t.r)||t.r<=0||!Number.isFinite(t.dmg)||t.dmg<=0){
      trails.splice(i,1);continue;
    }
    if(!(t.dmgCD instanceof Map))t.dmgCD=new Map();
    if(t.life<=0){trails.splice(i,1);continue}
    // Throttle damage check: only check every 0.15s per trail to reduce O(n*m) cost
    t._checkT=(t._checkT||0)-dt;
    if(t._checkT>0)continue;
    t._checkT=.15;
    // Damage enemies touching this trail segment
    enemies.each(e=>{if(!e.active)return;
      if(dist(t.x,t.y,e.x,e.y)<t.r+e.r){
        const lastHit=t.dmgCD.get(e)||0;
        if(G.time-lastHit>.25){// hit every 0.25s
          t.dmgCD.set(e,G.time);
          dealDamage(e,t.dmg,'trail');
        }
      }
    });
  }
}
function drawTrails(){
  for(const t of trails){
    const a=clamp(t.life/t.maxLife,0,1);
    const r=t.r*(.6+a*.4);
    ctx.save();
    // Scattered lingering particles (like death particles)
    const seed=(t.x*7+t.y*13)|0;
    const n=6+((seed&7));
    for(let i=0;i<n;i++){
      const pa=TAU/n*i+sin(G.time*3+i)*0.4;
      const pr=r*(0.3+((seed+i*17)%100)/100*0.7);
      const px=t.x+cos(pa)*pr,py=t.y+sin(pa)*pr;
      const sz=(1.5+((seed+i*31)%100)/100*2)*a;
      ctx.beginPath();ctx.arc(px,py,sz,0,TAU);
      ctx.fillStyle=t.color;ctx.globalAlpha=a*(.4+((seed+i*7)%100)/100*.4);ctx.fill();
    }
    // Central dim glow
    ctx.beginPath();ctx.arc(t.x,t.y,r*.6,0,TAU);
    ctx.fillStyle=t.color;ctx.globalAlpha=a*.08;ctx.fill();
    ctx.restore();
  }
}
// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=24;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  if(!Number.isFinite(x1)||!Number.isFinite(y1)||!Number.isFinite(x2)||!Number.isFinite(y2))return;
  const w=Number.isFinite(width)&&width>0?width:30;
  const d=Number.isFinite(dmg)&&dmg>0?dmg:1;
  const l=Number.isFinite(life)&&life>0?life:.8;
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.08;
    enemies.each(e=>{
      if(!e.active)return;
      const d=pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2);
      if(d<=s.width*.5+e.r){
        if(!e._swordAfterT||G.time-e._swordAfterT>.18){
          e._swordAfterT=G.time;
          dealDamage(e,s.dmg,'sword_aftershock');
        }
      }
    });
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,dl=sqrt(dx*dx+dy*dy)||1;
    const ux=dx/dl,uy=dy/dl,nx=-uy,ny=ux;
    const w=max(6,s.width*(.7+.25*a));
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.5,'rgba(255,120,255,'+(.12+.18*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    // Tapered pointed ribbon to avoid flat edge cutoffs.
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    // Soft core streak
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    // Lightning-like spark particles on top.
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=160+32*(w.lv.a||0);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0))*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}
// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      const burnLv=clamp(w.lv.c|0,0,2);
      if(burnLv>0){
        e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
        e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle()});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    const outerW=b.width*(.8+.4*a)*pulse;
    const midW=max(3,b.width*.3*(.8+.3*a));
    const coreW=max(2,b.width*.12);
    ctx.save();
    ctx.lineCap='round';
    // Smooth in near the player-facing end to avoid abrupt cutoff.
    const gradOuter=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradOuter.addColorStop(0,'rgba(255,216,74,0)');
    gradOuter.addColorStop(0.08,'rgba(255,216,74,'+(.12+.14*a)+')');
    gradOuter.addColorStop(1,'rgba(255,216,74,'+(.08+.2*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradOuter;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=b.color;ctx.shadowBlur=20;ctx.stroke();
    const gradMid=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradMid.addColorStop(0,'rgba(255,255,255,0)');
    gradMid.addColorStop(0.08,'rgba(255,255,255,'+(.16+.2*a)+')');
    gradMid.addColorStop(1,'rgba(255,216,74,'+(.2+.4*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradMid;ctx.lineWidth=midW;ctx.globalAlpha=1;ctx.shadowBlur=12;ctx.stroke();
    const gradCore=ctx.createLinearGradient(b.x1,b.y1,b.x2,b.y2);
    gradCore.addColorStop(0,'rgba(255,255,255,0)');
    gradCore.addColorStop(0.1,'rgba(255,255,255,'+(.25+.25*a)+')');
    gradCore.addColorStop(1,'rgba(255,255,255,'+(.35+.45*a)+')');
    ctx.beginPath();ctx.moveTo(b.x1,b.y1);ctx.lineTo(b.x2,b.y2);
    ctx.strokeStyle=gradCore;ctx.lineWidth=coreW;ctx.globalAlpha=1;ctx.shadowBlur=8;ctx.stroke();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}
// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:opts.color||'#f66',
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    const outerW=l.width*(1+.35*a),midW=max(4,l.width*.45*(.85+.25*a)),coreW=max(2.5,l.width*.2);
    ctx.save();ctx.lineCap='round';
    const g1=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g1.addColorStop(0,'rgba(255,255,255,0)');g1.addColorStop(.08,'rgba(255,216,74,'+(.12+.14*a)+')');g1.addColorStop(1,'rgba(255,120,120,'+(.1+.22*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g1;ctx.lineWidth=outerW;ctx.globalAlpha=1;ctx.shadowColor=l.color;ctx.shadowBlur=18;ctx.stroke();
    const g2=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g2.addColorStop(0,'rgba(255,255,255,0)');g2.addColorStop(.1,'rgba(255,255,255,'+(.15+.2*a)+')');g2.addColorStop(1,'rgba(255,180,180,'+(.2+.38*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g2;ctx.lineWidth=midW;ctx.shadowBlur=10;ctx.stroke();
    const g3=ctx.createLinearGradient(l.x1,l.y1,x2,y2);
    g3.addColorStop(0,'rgba(255,255,255,0)');g3.addColorStop(.12,'rgba(255,255,255,'+(.25+.25*a)+')');g3.addColorStop(1,'rgba(255,255,255,'+(.3+.4*a)+')');
    ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);ctx.strokeStyle=g3;ctx.lineWidth=coreW;ctx.shadowBlur=6;ctx.stroke();
    ctx.restore();
  }
}
// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function getObstacles(cx,cy){
  const k=cx+','+cy;
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // ~30% less than prior density of 7
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function reflectOff(b,o){let nx,ny;if(o.type==='pillar'){const dx=b.x-o.x,dy=b.y-o.y,d=sqrt(dx*dx+dy*dy)||1;nx=dx/d;ny=dy/d;b.x=o.x+nx*(o.r+b.r+1);b.y=o.y+ny*(o.r+b.r+1)}else{const nearX=clamp(b.x,o.x,o.x+o.w),nearY=clamp(b.y,o.y,o.y+o.h);nx=b.x-nearX;ny=b.y-nearY;const d=sqrt(nx*nx+ny*ny)||1;nx/=d;ny/=d;b.x=nearX+nx*(b.r+1);b.y=nearY+ny*(b.r+1)}const dot=b.vx*nx+b.vy*ny;b.vx-=2*dot*nx;b.vy-=2*dot*ny}
function drawGround(){const gs=100,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs,sx=floor(l/gs)*gs,sy=floor(t/gs)*gs;ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.5;ctx.beginPath();for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}ctx.stroke();ctx.restore()}
function drawObstacles(){const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){const obs=getObstacles(cx,cy);for(let i=0;i<obs.length;i++){const o=obs[i];if(o.type==='pillar'){ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();glowCircle(o.x,o.y,o.r,'#1a4a6a',2)}else{ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2)}}}}
// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.shieldUp=false;player.shieldCD=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
  // Shield recharge
  if(stats.shieldRecharge>0&&!player.shieldUp){
    player.shieldCD=(player.shieldCD||0)-dt;
    if(player.shieldCD<=0){player.shieldUp=true;burstParticles(player.x,player.y,'#4af',6,80)}
  }
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
  // Shield ring
  if(player.shieldUp){ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r+6,0,TAU);ctx.strokeStyle='#4af';ctx.lineWidth=2;ctx.globalAlpha=.5+sin(G.time*4)*.2;ctx.shadowColor='#4af';ctx.shadowBlur=8;ctx.stroke();ctx.restore()}
}
// == PHASES ==
const PHASES=[
  {name:'MIRROR',color:'#f0f',desc:'Bullets reflect off obstacles',apply(){G.reflect=true},unapply(){G.reflect=false},tick(){}},
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'DECAY',color:'#4f4',desc:'Bullets slow down and pop',apply(){G.decay=true},unapply(){G.decay=false},tick(){}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}
// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}collideObs(e)},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt;collideObs(e)},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt);collideObs(e)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
    collideObs(e);
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt;collideObs(e)},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt;collideObs(e)},
  // Boss movement
  stationary(e,dt){collideObs(e)},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt;collideObs(e)},
};
// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=c||'#f44';b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.reflected=false;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){fireEB(x,y,vx,vy,r,c,t,l,Object.assign({},p||{},makeBossBulletFx()))}
// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];
function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=opts&&opts.color||rPick(ECOLORS);
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt;collideObs(e)}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt;collideObs(e)}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0;collideObs(e)}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const t=G.time,r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,6);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,6);
  else glowCircle(0,0,r,col,6);
  // Random accessory pack
  const acc=e.bossAccessory|0;
  if(acc===0){
    for(let i=0;i<4;i++){const a=t*1.7+TAU/4*i;ctx.beginPath();ctx.arc(cos(a)*r*.8,sin(a)*r*.8,2.5,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.55;ctx.fill();}
  }else if(acc===1){
    ctx.rotate(t*1.4);ctx.beginPath();
    for(let i=0;i<8;i++){const a=TAU/8*i,rr=i%2===0?r+8:r*.6;const px=cos(a)*rr,py=sin(a)*rr;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
    ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.globalAlpha=.5;ctx.stroke();
  }else{
    for(let i=0;i<3;i++){const a=t*1.1+i*2.1;const d=r*.55+i*6;ctx.beginPath();ctx.arc(cos(a)*d,sin(a)*d,3,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.4;ctx.fill();}
  }
  // Core
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(t*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){
    const ia=clamp(e._dashInvuln/.3,0,1);
    ctx.beginPath();ctx.arc(0,0,r+8+sin(t*16)*2,0,TAU);
    ctx.strokeStyle='#ffd0ff';ctx.lineWidth=2.4;ctx.globalAlpha=.28+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=12;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,r+3,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=1.2;ctx.globalAlpha=.18+.25*ia;ctx.shadowBlur=7;ctx.stroke();
  }
  ctx.restore();
  // Shield node visuals (modifier-driven)
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
      const sa=sn.angle+PI/2,pr=10;
      const pts=[];
      for(let i=0;i<6;i++){const a=sa+TAU/6*i;pts.push({x:nx+cos(a)*pr,y:ny+sin(a)*pr})}
      ctx.save();
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);ctx.closePath();
      ctx.fillStyle='rgba(235,245,255,.22)';ctx.strokeStyle=col;ctx.lineWidth=2;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,pr+5,sn.angle-.65,sn.angle+.65);ctx.strokeStyle='rgba(255,255,255,.45)';ctx.lineWidth=2.2;ctx.shadowBlur=6;ctx.stroke();
      ctx.beginPath();ctx.arc(nx,ny,3.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.9;ctx.fill();
      ctx.restore();
    }
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase;
  const a=clamp(lifeNorm,0,1);
  const pulse=.84+sin(t*5)*.2;
  const r=72*pulse;
  ctx.save();ctx.translate(x,y);
  // Outer distort ring
  ctx.beginPath();ctx.arc(0,0,r+18,0,TAU);
  ctx.strokeStyle='rgba(120,70,220,'+(.3*a)+')';ctx.lineWidth=10;ctx.shadowColor='#8a5dff';ctx.shadowBlur=20;ctx.stroke();
  // Mid rotating polygon ring
  ctx.save();ctx.rotate(t*1.2);
  const n=10;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const ang=TAU/n*i;
    const rr=(i%2===0?r+8:r-2)+sin(t*7+i)*2;
    const px=cos(ang)*rr,py=sin(ang)*rr;
    if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(198,150,255,'+(.62*a)+')';ctx.lineWidth=3.6;ctx.shadowBlur=12;ctx.stroke();
  ctx.restore();
  // Interior vortex rings
  for(let i=0;i<3;i++){
    const rr=r*(.72-i*.18);
    ctx.beginPath();ctx.arc(0,0,rr+sin(t*6+i*1.8)*2.5,0,TAU);
    ctx.strokeStyle=i===0?'rgba(230,215,255,'+(.7*a)+')':'rgba(176,128,255,'+(.52*a)+')';
    ctx.lineWidth=2.4-i*.35;ctx.shadowBlur=10-i*2;ctx.stroke();
  }
  // Radial shards
  const shards=14;
  for(let i=0;i<shards;i++){
    const ang=t*1.4+TAU/shards*i;
    const r1=r*.38+sin(t*8+i)*3,r2=r+10+sin(t*5+i*1.7)*4;
    const x1=cos(ang)*r1,y1=sin(ang)*r1,x2=cos(ang)*r2,y2=sin(ang)*r2;
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(215,182,255,'+(.42*a)+')';ctx.lineWidth=1.6;ctx.shadowBlur=8;ctx.stroke();
  }
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const dtl=e._dashTele;
  const prog=1-clamp(dtl.t/max(.0001,dtl.maxT),0,1);
  const tx=dtl.tx,ty=dtl.ty;
  const da=atan2(ty-e.y,tx-e.x);
  const ax=e.x+cos(da)*(e.r+12),ay=e.y+sin(da)*(e.r+12);
  ctx.save();
  ctx.beginPath();ctx.arc(e.x,e.y,e.r+9+sin(G.time*18)*2,0,TAU);
  ctx.strokeStyle='rgba(255,235,140,'+(.24+.42*prog)+')';ctx.lineWidth=2.3;ctx.shadowColor='#ffea8a';ctx.shadowBlur=10;ctx.stroke();
  ctx.translate(ax,ay);ctx.rotate(da);
  const ts=7+prog*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*prog)+')';ctx.shadowColor='#fff0a0';ctx.shadowBlur=8;ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    const cc=e.cc;
    let col=e.hitFlash>0?'#fff':e.color;
    if(cc.fearT>0)col='#ddd'; // pale when feared
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
    const gn=e.isBoss?6:e.tier==='elite'?5:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    // Dash telegraph indicator (invuln + target marker)
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    // HP bar for elites/bosses
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.save();ctx.fillStyle='#333';ctx.globalAlpha=.7;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);
      ctx.fillStyle=e.color;ctx.globalAlpha=.9;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);ctx.restore();
    }
    // CC indicators
    if(cc.stunT>0){ctx.save();ctx.globalAlpha=.6+Math.random()*.4;ctx.beginPath();ctx.arc(e.x+(Math.random()-.5)*4,e.y+(Math.random()-.5)*4,e.r+3,0,TAU);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();ctx.restore()}
    if(cc.silenceT>0){ctx.save();ctx.globalAlpha=.6;ctx.strokeStyle='#0aa';ctx.lineWidth=2;const s=e.r*.4;ctx.beginPath();ctx.moveTo(e.x-s,e.y-s);ctx.lineTo(e.x+s,e.y+s);ctx.moveTo(e.x+s,e.y-s);ctx.lineTo(e.x-s,e.y+s);ctx.stroke();ctx.restore()}
    if(cc.rootT>0){ctx.save();ctx.strokeStyle='#4f4';ctx.lineWidth=2;ctx.globalAlpha=.6;for(let i=0;i<3;i++){ctx.beginPath();ctx.arc(e.x,e.y+e.r*.3,e.r*.6+i*4,0,TAU);ctx.stroke()}ctx.restore()}
    if(cc.slowT>0){ctx.save();ctx.strokeStyle='#f4f';ctx.lineWidth=1.5;ctx.globalAlpha=.5;ctx.beginPath();const sp=G.time*3;for(let i=0;i<3;i++){const a=sp+TAU/3*i;ctx.moveTo(e.x+cos(a)*e.r,e.y+sin(a)*e.r);ctx.lineTo(e.x+cos(a+.5)*(e.r+8),e.y+sin(a+.5)*(e.r+8))}ctx.stroke();ctx.restore()}
    if(cc.markT>0){ctx.save();ctx.fillStyle='#ccc';ctx.globalAlpha=.8;const sz=5;ctx.beginPath();ctx.moveTo(e.x,e.y-e.r-10-sz);ctx.lineTo(e.x+sz,e.y-e.r-10);ctx.lineTo(e.x,e.y-e.r-10+sz);ctx.lineTo(e.x-sz,e.y-e.r-10);ctx.closePath();ctx.fill();ctx.restore()}
    if(cc.fearT>0){ctx.save();drawText('!',e.x,e.y-e.r-14,12,'#ff0','center','middle');ctx.restore()}
    if(cc.bleedT>0){ctx.save();ctx.fillStyle='#f00';ctx.globalAlpha=.5;for(let i=0;i<3;i++){const a=G.time*5+TAU/3*i;ctx.beginPath();ctx.arc(e.x+cos(a)*e.r*.6,e.y+sin(a)*e.r*.6,2,0,TAU);ctx.fill()}ctx.restore()}
  });
}
// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.decay){const s=b.baseSpeed*max(.2,1-(1-b.life/b.maxLife)*.8),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.reflected=false;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    const ho=bulletHitsObs(b);
    if(ho){if(G.reflect&&!b.reflected&&!isP){reflectOff(b,ho);b.reflected=true}else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}}
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}
    if(G.decay&&!isP)burstParticles(b.x,b.y,b.color,4,60)}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  if(b.src==='rocket'||b.src==='rocket_mini'){
    // Draw rocket shape (elongated with tail)
    const sz=b.src==='rocket_mini'?.6:1;
    const ang=atan2(b.vy,b.vx);const pa=ang+PI/2;
    const nose={x:b.x+cos(ang)*10*sz,y:b.y+sin(ang)*10*sz};
    const bl={x:b.x-cos(ang)*6*sz+cos(pa)*4*sz,y:b.y-sin(ang)*6*sz+sin(pa)*4*sz};
    const br={x:b.x-cos(ang)*6*sz-cos(pa)*4*sz,y:b.y-sin(ang)*6*sz-sin(pa)*4*sz};
    ctx.beginPath();ctx.moveTo(nose.x,nose.y);ctx.lineTo(bl.x,bl.y);ctx.lineTo(br.x,br.y);ctx.closePath();
    ctx.fillStyle=b.src==='rocket_mini'?'#fa0':'#f80';ctx.fill();ctx.strokeStyle='#fa0';ctx.lineWidth=1;ctx.stroke();
    // Exhaust flame
    const ex=b.x-cos(ang)*8*sz,ey=b.y-sin(ang)*8*sz;
    ctx.beginPath();ctx.arc(ex,ey,(3+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#ff4';ctx.globalAlpha=a*.7;ctx.fill();
    ctx.beginPath();ctx.arc(ex-cos(ang)*3*sz,ey-sin(ang)*3*sz,(2+Math.random()*2)*sz,0,TAU);ctx.fillStyle='#f80';ctx.globalAlpha=a*.4;ctx.fill();
  }else{glowDot(b.x,b.y,b.r,b.color)}
  if(b.bossFx&&b.bossFx!=='normal'){
    ctx.beginPath();ctx.arc(b.x,b.y,b.r+2.2,0,TAU);
    ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';
    ctx.lineWidth=1.2;ctx.globalAlpha=.45*a;ctx.stroke();
  }
  ctx.restore()})}
// == WEAPON SYSTEM ==
// Weapon state per slot
const WEAPON_INIT_FN={
  dagger:s=>Object.assign(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>Object.assign(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>Object.assign(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>Object.assign(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>Object.assign(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  drone:s=>Object.assign(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
  shuriken:s=>Object.assign(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}
// Weapon definitions
const WDEFS={
  dagger:{name:'MAGIC DAGGER',color:'#0ff',type:'starter',desc:'Click to throw. Click again to redirect.',
    upgrades:[
      {id:'a',name:'PIERCING THROW',maxLv:3,desc:['+50% speed','90% + homing','120% + homing']},
      {id:'b',name:'SPECTRAL COPY',maxLv:3,desc:['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']},
      {id:'d',name:'DAGGER STORM',maxLv:2,desc:['0.8s spin 35px','1.2s 50px']},
    ]},
  sword:{name:'PLASMA SWORD',color:'#f0f',type:'starter',desc:'Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.',
    upgrades:[
      {id:'a',name:'LUNGE REACH',maxLv:3,desc:['160px lunge','200px','250px']},
      {id:'b',name:'WIDE CLEAVE',maxLv:3,desc:['50px wide','60px','75px']},
      {id:'c',name:'AFTERSHOCK',maxLv:2,desc:['Trail 2dmg 1.8s','3dmg 2.5s']},
    ]},
  bow:{name:'VOLT BOW',color:'#ff0',type:'starter',desc:'Hold to charge, release a piercing beam.',
    upgrades:[
      {id:'a',name:'PRISM SPLIT',maxLv:2,desc:['1 side pair','2 side pairs']},
      {id:'b',name:'QUICK DRAW',maxLv:3,desc:['1.0s charge','0.8s','0.6s']},
      {id:'c',name:'PLASMA BURN',maxLv:2,desc:['Applies burn','Stronger burn']},
    ]},
  chain:{name:'CHAIN LIGHTNING',color:'#a0f',type:'cc',cc:'BULLET CLEAR',desc:'Arcs lightning to destroy enemy bullets.',
    upgrades:[
      {id:'a',name:'EXTRA CHAINS',maxLv:2,desc:['+3 chains (7)','+3 (10)']},
      {id:'b',name:'MULTI STRIKE',maxLv:2,desc:['2 bolts at once','3 bolts']},
      {id:'c',name:'STATIC FIELD',maxLv:2,desc:['3s lingering stun zone','5s zone + wider']},
    ]},
  rocket:{name:'ROCKET LAUNCHER',color:'#f80',type:'cc',cc:'KNOCKBACK',desc:'Homing rockets knock enemies back, clear bullets.',
    upgrades:[
      {id:'a',name:'CONCUSSIVE BLAST',maxLv:3,desc:['+60 knockback','+120 kb','+200 kb']},
      {id:'b',name:'CLUSTER BOMB',maxLv:2,desc:['5 homing mini-rockets','7']},
      {id:'c',name:'BLAST RADIUS',maxLv:2,desc:['130px','160px']},
    ]},
  // CC weapon stubs
  drone:{name:'PULSE DRONE',color:'#0aa',type:'cc',cc:'SILENCE',desc:'Drone silences enemies, slows bullets.',upgrades:[{id:'a',name:'EXTRA DRONE',maxLv:2,desc:['+1 drone','+1 (3 total)']},{id:'b',name:'EXT SILENCE',maxLv:2,desc:['2.5s','3.5s']},{id:'c',name:'DISRUPTION',maxLv:2,desc:['20% slow','40%']},{id:'d',name:'OVERDRIVE',maxLv:2,desc:['0.9s cd','0.7s']}]},
  shuriken:{name:'SHURIKEN',color:'#bbb',type:'cc',cc:'MARK',desc:'Bouncing shurikens mark enemies for bonus damage.',upgrades:[{id:'a',name:'EXTRA SHURIKEN',maxLv:2,desc:['+1','+1 (3 total)']},{id:'b',name:'DEEP MARK',maxLv:2,desc:['45% bonus dmg','60%']},{id:'c',name:'EXT MARK',maxLv:2,desc:['5s','7s']},{id:'d',name:'EXTRA BOUNCES',maxLv:3,desc:['+2 bounces (4)','+2 (6)','+2 (8)']}]},
};
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','drone','shuriken'];
const IMPLEMENTED_CC=['chain','rocket','drone','shuriken'];
// Weapon update/draw dispatch
const WEAPON_UPDATE_FN={dagger:updateDagger,sword:updateSword,bow:updateBow,chain:updateChain,rocket:updateRocket,drone:updateDrone,shuriken:updateShuriken};
const WEAPON_DRAW_FN={dagger:drawDagger,sword:drawSword,bow:drawBow,chain:drawChain,rocket:drawRocket,drone:drawDrone,shuriken:drawShuriken};
function updateWeapons(dt){
  for(const w of G.weapons){
    const fn=WEAPON_UPDATE_FN[w.id];
    if(fn)fn(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    const fn=WEAPON_DRAW_FN[w.id];
    if(fn)fn(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}
// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}
// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8;const bladeReach=70;
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // AFTERSHOCK trail
    if(w.lv.c>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.c|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a];
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60,bladeW=6;
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Draw cleave zone as a soft tapered slash field (no hard rectangle)
    ctx.save();
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Draw motion lines along lunge
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Slash trail: softer, ribbon-like, and dynamic.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}
// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
const WEAPON_DOWN_FN={dagger:onDaggerClick,sword:onSwordClick,bow:onBowDown};
const WEAPON_UP_FN={bow:onBowUp};
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    ctx.beginPath();ctx.arc(player.x,player.y,r,0,TAU);
    ctx.strokeStyle='#ffd84a';ctx.lineWidth=1.2+pct*1.2;ctx.globalAlpha=.3+pct*.5;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,r*.55,0,TAU);
    ctx.strokeStyle='#fff';ctx.lineWidth=.9+pct*.9;ctx.globalAlpha=.25+pct*.45;ctx.stroke();
    ctx.restore();
  }
}
// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    // Only target enemy bullets
    let anyNearby=false;
    enemyBullets.each(b=>{if(b.active&&dist(player.x,player.y,b.x,b.y)<range)anyNearby=true});
    if(!anyNearby){return}
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    let globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      let hitBullets=new Set(),targets=[],last={x:player.x,y:player.y};
      // Offset start for multi-bolt spread
      if(bolt>0){const oa=TAU/bolts*bolt;last={x:player.x+cos(oa)*15,y:player.y+sin(oa)*15}}
      for(let c=0;c<maxChains;c++){
        let bestObj=null,bestD=range+(c>0?100:0);
        enemyBullets.each(b=>{if(!b.active||hitBullets.has(b)||globalHit.has(b))return;
          const d=dist(last.x,last.y,b.x,b.y);if(d<bestD){bestD=d;bestObj=b}});
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        // Static field: spawn lingering stun particles at each hit point
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        last={x:bestObj.x,y:bestObj.y};
      }
      w._targets=w._targets.concat(targets);
      let prev=bolt>0?{x:player.x+cos(TAU/bolts*bolt)*15,y:player.y+sin(TAU/bolts*bolt)*15}:{x:player.x,y:player.y};
      for(const t of targets){
        const pts=generateLightningPath(prev.x,prev.y,t.x,t.y,8);
        w._zigzags.push(pts);
        prev={x:t.x,y:t.y};
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    ctx.save();
    for(const pts of w._zigzags){
      // Outer glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#a0f';ctx.lineWidth=6;ctx.globalAlpha=alpha*.25;
      ctx.shadowColor='#a0f';ctx.shadowBlur=15;ctx.stroke();
      // Mid glow
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#c6f';ctx.lineWidth=3;ctx.globalAlpha=alpha*.6;ctx.shadowBlur=8;ctx.stroke();
      // Core
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle='#eaf';ctx.lineWidth=1.5;ctx.globalAlpha=alpha;ctx.shadowBlur=4;ctx.stroke();
      // Flash dots at endpoints
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}
// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    // Find nearest enemy
    let best=null,bestD=9999;
    enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    let a;
    if(best){a=atan2(best.y-player.y,best.x-player.x)}
    else{a=player.angle}
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;b.reflected=false;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    let best=null,bestD=800;
    enemies.each(e=>{if(!e.active)return;const d=dist(b.x,b.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
    if(best){
      const desired=atan2(best.y-b.y,best.x-b.x);
      const cur=atan2(b.vy,b.vx);
      const diff=normAng(desired-cur);
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const turn=clamp(diff,-turnRate*dt,turnRate*dt);
      const na=cur+turn;
      const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
      b.vx=cos(na)*spd;b.vy=sin(na)*spd;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}
// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.reflected=false;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}
// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    // Find nearest enemy to seek
    let nearE=null,nearD=400;
    enemies.each(e=>{if(!e.active)return;const dd=dist(d.x,d.y,e.x,e.y);if(dd<nearD){nearD=dd;nearE=e}});
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      let hit=false;
      enemies.each(e=>{if(!e.active||hit)return;
        if(dist(d.x,d.y,e.x,e.y)<range+e.r){
          const bossMult=e.isBoss?.3:1;
          if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
          if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
          dealDamage(e,1,'drone');hit=true;
          d.pulseT=.3;
          burstParticles(d.x,d.y,'#0aa',5,80);
        }
      });
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    ctx.strokeStyle='#0ff';ctx.lineWidth=1.5;ctx.globalAlpha=.8;ctx.stroke();
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    ctx.beginPath();ctx.arc(d.x,d.y,w.droneRange,0,TAU);
    ctx.strokeStyle='#0aa';ctx.lineWidth=.5;ctx.globalAlpha=.1;ctx.stroke();
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      ctx.beginPath();ctx.arc(d.x,d.y,pr,0,TAU);
      ctx.strokeStyle='#0ff';ctx.lineWidth=2;ctx.globalAlpha=d.pulseT/.3*.4;ctx.stroke();
    }
    ctx.restore();
  }
}
// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  // Update active shurikens
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    // Strong seeking - always active
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx);const diff=normAng(desired-cur);
      const turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn;const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      // Retarget if current target dead
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    // Hit check
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        // Bounce
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x);
            const spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);// extend life on bounce
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}
// == PASSIVES ==
const PASSIVE_DEFS={
  regen:{name:'REGENERATION',color:'#4f4',maxLv:3,desc:['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']},
  speed:{name:'SPEED BOOST',color:'#4f4',maxLv:3,desc:['+15% speed','+30%','+40% + 8% dodge']},
  cooldown:{name:'COOLDOWN REDUCTION',color:'#48f',maxLv:3,desc:['-12% all CDs','-20%','-25% + faster weapons']},
  shield:{name:'ENERGY SHIELD',color:'#4af',maxLv:2,desc:['Shield recharges 12s','8s recharge']},
  damage:{name:'POWER SURGE',color:'#f44',maxLv:2,desc:['+30% damage','+50% damage']},
};
const PASSIVE_KEYS=Object.keys(PASSIVE_DEFS);
const IMPL_PASSIVES=['regen','speed','cooldown','shield','damage'];
// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const BOSS_ATTACK_POOL=['radial','wall','curve_ring','spread','laser_fan','dash_strike'];
const BOSS_MOD_POOL=['shield_nodes','rage','twin_link','warp_portals','summoner'];
const BOSS_CORE_MODS=['shield_nodes','warp_portals','summoner','rage'];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN={
  radial(en){EFIRE.bossRadial(en)},
  wall(en){EFIRE.bossWall(en)},
  curve_ring(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  spread(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  laser_fan(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  dash_strike(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
};
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods.includes('twin_link'))return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=cfg.color;e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=(cfg.mods.includes('twin_link')&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if(cfg.mods.includes('shield_nodes')&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if(cfg.mods.includes('rage')&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods.includes('twin_link')){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods.includes('warp_portals')){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if(cfg.mods.includes('summoner')){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if(cfg.mods.includes('warp_portals')&&this._portals.length&&atk!=='laser_fan'){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  const mods=[nextBossCoreMod()];
  const EXCLUSIVE_GIMMICKS=['twin_link','warp_portals'];
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  while(mods.length<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!mods.includes(m));
    if(mods.some(m=>EXCLUSIVE_GIMMICKS.includes(m)))pool=pool.filter(m=>!EXCLUSIVE_GIMMICKS.includes(m));
    if(!pool.length)break;
    mods.push(rPick(pool));
  }
  const attacks=pickUnique(BOSS_ATTACK_POOL,mods.includes('twin_link')?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((190+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  if(!cfg.mods.includes('summoner')){
    enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
    enemyBullets.clear();
  }
  const pair=cfg.mods.includes('twin_link');
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}
// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}
function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}
// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  // Mark amplifier
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  // Global crit
  let isCrit=forceCrit||false;
  if(!isShuriken&&!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  // Mark amplification
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}
function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  // Shield absorbs hit
  if(player.shieldUp){player.shieldUp=false;player.shieldCD=stats.shieldRecharge;player.invuln=.3;
    burstParticles(player.x,player.y,'#4af',12,150);addShake(4);return}
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    OZ.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='gameover';
  }
}
// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  const passiveCount=Object.keys(G.passives).filter(k=>G.passives[k]>0).length;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, fill with micro-buffs
  if(upgradeChoices.length<5){
    const microTypes=[
      {stat:'dmgMult',name:'+2% Damage',amt:.02,color:'#f44'},
      {stat:'moveSpeed',name:'+2% Speed',amt:.02,color:'#4f4'},
      {stat:'xpMult',name:'+5% XP Gain',amt:.05,color:'#ff0'},
      {stat:'dodgeChance',name:'+1% Dodge',amt:.01,color:'#4af'},
      {stat:'cdReduction',name:'+3% Cooldown',amt:.03,color:'#48f'},
    ];
    for(let i=microTypes.length-1;i>0;i--){const j=ri(0,i);[microTypes[i],microTypes[j]]=[microTypes[j],microTypes[i]]}
    let mi=0;
    while(upgradeChoices.length<5){
      const mb=microTypes[mi%microTypes.length];mi++;
      upgradeChoices.push({type:'microBuff',stat:mb.stat,name:mb.name,amt:mb.amt,color:mb.color});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='microBuff'){
    if(!G._microBuffs)G._microBuffs={};
    G._microBuffs[c.stat]=(G._microBuffs[c.stat]||0)+c.amt;
  }
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  // Title slides down from top
  const titleY=CY-140-80*(1-ease);
  ctx.save();ctx.globalAlpha=ease;
  drawText('LEVEL UP!  Choose an upgrade',CX,titleY,20,'#ff0','center','middle');
  ctx.restore();
  const nc=min(5,upgradeChoices.length);
  const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<nc;i++){
    const c=upgradeChoices[i];
    // Each card slides up with stagger
    const cardDelay=i*.06;
    const cardEase=clamp((ease-cardDelay)/(1-cardDelay),0,1);
    const ce=cardEase<1?1-Math.pow(1-cardEase,3):1;
    const cardOffY=60*(1-ce);
    const cx=sx+i*(cw+gap),cy=sy+cardOffY;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    let col='#0ff',name='',desc='',isNew=false,pips='',maxPips=0,curPips=0;
    if(c.type==='weaponUpg'){
      col=c.wdef.color;name=c.wdef.name+': '+c.def.name;
      desc=c.def.desc[c.curLv]||'';maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='newWeapon'){
      col=c.wdef.color;name=c.wdef.name;desc=c.wdef.desc;isNew=true;
      if(c.wdef.cc)desc='CC: '+c.wdef.cc+' — '+desc;
    }else if(c.type==='newPassive'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[0];isNew=true;
    }else if(c.type==='passiveUpg'){
      col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv];maxPips=c.def.maxLv;curPips=c.curLv+1;
    }else if(c.type==='microBuff'){
      col=c.color;name='MINOR BOOST';desc=c.name;isNew=false;
    }
    const bc=hover?'#fff':col;
    ctx.save();ctx.globalAlpha=(hover?1:.75)*ce;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    if(isNew){ctx.save();ctx.fillStyle='#ff0';ctx.font='bold 9px monospace';ctx.fillText('NEW!',cx+cw-30,cy+12);ctx.restore()}
    drawText(name,cx+cw/2,cy+20,9,bc,'center','middle');
    // Word wrap desc
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=desc.split(' ');let line='',ly=cy+42;
    for(const w of words){const test=line+w+' ';if(ctx.measureText(test).width>cw-12){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=11;line=w+' '}else line=test}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    // Level pips
    if(maxPips>0){
      const pipY=cy+ch-18;
      for(let p=0;p<maxPips;p++){
        const px=cx+cw/2-maxPips*6+p*12+6;
        ctx.save();ctx.beginPath();ctx.arc(px,pipY,3,0,TAU);
        ctx.fillStyle=p<curPips?col:'#333';ctx.fill();ctx.restore();
      }
    }
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-8,12,'#555','center','middle');
  }
  // Reroll indicator
  if(G.refreshAvailable>0){
    const ry=sy+ch+20;
    const rCol='#4f4';const pulse=.7+sin(G.time*4)*.3;
    ctx.save();ctx.globalAlpha=ease*pulse;
    drawText('[R] Reroll ('+G.refreshAvailable+' left)',CX,ry,14,rCol,'center','middle');
    ctx.restore();
  }else{
    const ry=sy+ch+20;
    ctx.save();ctx.globalAlpha=ease*.3;
    drawText('[R] No rerolls left',CX,ry,12,'#555','center','middle');
    ctx.restore();
  }
}
// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}
// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const mobile=W<900||H<620;
  const margin=mobile?10:14;
  const topW=min(mobile?W-20:560,W-margin*2);
  const topH=mobile?54:56;
  const topX=CX-topW/2,topY=margin;
  const m=(G.time/60)|0,s=(G.time%60)|0;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1);
  const hpCol=hpProg>.5?'#00e5ff':hpProg>.25?'#ffd24a':'#ff4a4a';
  const xpProg=clamp(G.xp/G.xpToNext,0,1);
  // Minimal, single container for primary UI.
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.56)';ctx.fillRect(topX,topY,topW,topH);
  ctx.strokeStyle='rgba(255,255,255,0.16)';ctx.lineWidth=1;ctx.strokeRect(topX,topY,topW,topH);
  ctx.restore();
  const labelW=mobile?22:26;
  const hpX=topX+12+labelW+6,hpY=topY+9,hpW=topW-(12+labelW+6)-12,hpH=mobile?12:13;
  const hpSegs=10,hpGap=2,hpSegW=(hpW-hpGap*(hpSegs-1))/hpSegs;
  ctx.save();
  for(let i=0;i<hpSegs;i++){
    const sx=hpX+i*(hpSegW+hpGap);
    const fill=clamp(hpProg*hpSegs-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(sx,hpY,hpSegW,hpH);
    if(fill>0){
      ctx.fillStyle=hpCol;ctx.globalAlpha=.92;ctx.fillRect(sx,hpY,hpSegW*fill,hpH);
    }
    ctx.strokeStyle='rgba(255,255,255,.25)';ctx.globalAlpha=.7;ctx.lineWidth=1;ctx.strokeRect(sx,hpY,hpSegW,hpH);
  }
  ctx.restore();
  const xpX=hpX,xpY=hpY+hpH+6,xpW=hpW,xpH=mobile?9:10;
  ctx.save();
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(xpX,xpY,xpW,xpH);
  ctx.fillStyle='#ffdf4a';ctx.globalAlpha=.82;ctx.fillRect(xpX,xpY,xpW*xpProg,xpH);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.lineWidth=1;ctx.globalAlpha=.75;ctx.strokeRect(xpX,xpY,xpW,xpH);
  ctx.restore();
  // Simple labels.
  drawText('HP',topX+12,hpY+(mobile?0:-1),mobile?10:11,'#dff');
  drawText('XP',topX+12,xpY-1,mobile?10:11,'#ffdf4a');
  const footerY=topY+topH-(mobile?13:12);
  drawText('TIME '+m+':'+(s<10?'0':'')+s,topX+12,footerY,mobile?9:10,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,footerY,mobile?9:10,currentPhase.color,'right');
  // Secondary strip: boss HP or wave progress
  const progY=topY+topH+8;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity;
    const bw=min(mobile?W-70:460,W-120),bh=mobile?10:12,bx=CX-bw/2,by=progY;
    const bossName=e.bossName||'BOSS';
    drawText(bossName,CX,by+bh+4,mobile?10:12,e.color,'center','top');
    ctx.save();ctx.fillStyle='#222';ctx.fillRect(bx,by,bw,bh);
    const segs=10,segW=bw/segs;
    for(let i=0;i<segs;i++){
      const segHP=(i+1)/segs;
      if(e.hp/e.maxHp>=segHP-1/segs){
        ctx.fillStyle=e.hp/e.maxHp>segHP?'#f44':'#a22';
        ctx.fillRect(bx+i*segW+1,by+1,segW-2,bh-2);
      }
    }
    ctx.strokeStyle='#f44';ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(bx,by,bw,bh);ctx.restore();
    const bsx=e.x-cam.x+CX,bsy=e.y-cam.y+CY;
    if(bsx<-10||bsx>W+10||bsy<-10||bsy>H+10){
      const ba=atan2(bsy-CY,bsx-CX);
      const ax=CX+cos(ba)*min(CX-40,CY-40),ay=CY+sin(ba)*min(CX-40,CY-40);
      ctx.save();ctx.translate(ax,ay);ctx.rotate(ba);
      ctx.beginPath();ctx.moveTo(12,0);ctx.lineTo(-6,-7);ctx.lineTo(-6,7);ctx.closePath();
      ctx.fillStyle=e.color;ctx.globalAlpha=.6+sin(G.time*5)*.3;ctx.shadowColor=e.color;ctx.shadowBlur=8;ctx.fill();ctx.restore();
    }
  }else if(G.waveState==='spawning'){
    const bw=min(mobile?W-80:340,W-140),bx=CX-bw/2,by=progY+1;
    const prog=clamp(G.waveKills/G.waveQuota,0,1);
    ctx.save();
    ctx.fillStyle='rgba(20,20,20,.92)';ctx.fillRect(bx,by,bw,6);
    ctx.fillStyle='#0ff';ctx.globalAlpha=.65;ctx.fillRect(bx,by,bw*prog,6);
    ctx.strokeStyle='rgba(0,255,255,.3)';ctx.lineWidth=1;ctx.globalAlpha=.8;ctx.strokeRect(bx,by,bw,6);
    ctx.restore();
    if(!mobile)drawText(G.waveKills+'/'+G.waveQuota,CX,by+9,10,'#8ab','center','top');
  }
  // Weapon slots (bottom center)
  const CC_MAX_CD={chain:.8,rocket:2.2,drone:1.5,shuriken:1.2};
  const slotW=mobile?50:58,totalSlotsW=max(1,G.weapons.length)*slotW;
  const slotStartX=CX-totalSlotsW/2+slotW/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],def=WDEFS[w.id];
    const wx=slotStartX+i*slotW,wy=H-(mobile?46:56);
    const boxW=mobile?38:44,boxH=mobile?26:30;
    ctx.save();ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(wx-boxW/2,wy-boxH/2,boxW,boxH);
    ctx.strokeStyle=def.color;ctx.lineWidth=1;ctx.globalAlpha=.55;ctx.strokeRect(wx-boxW/2,wy-boxH/2,boxW,boxH);ctx.restore();
    drawText(def.name.charAt(0),wx,wy-1,mobile?12:14,def.color,'center','middle');
    // Cooldown bar for auto-fire (CC) weapons
    const maxCD=CC_MAX_CD[w.id];
    if(maxCD&&w.timer!==undefined){
      const barW=boxW,barH=4,barX=wx-boxW/2,barY=wy+boxH/2+2;
      const cdProg=clamp(1-w.timer/maxCD,0,1);
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(barX,barY,barW,barH);
      if(cdProg>=1){
        ctx.fillStyle=def.color;ctx.globalAlpha=.45+.25*abs(sin(G.time*6));
      }else{
        ctx.fillStyle=def.color;ctx.globalAlpha=.45;
      }
      ctx.fillRect(barX,barY,barW*cdProg,barH);
      ctx.strokeStyle=def.color;ctx.globalAlpha=.22;ctx.lineWidth=.5;ctx.strokeRect(barX,barY,barW,barH);
      ctx.restore();
    }
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,mobile?560:760),boxH=mobile?46:54,boxX=CX-boxW/2,boxY=H-(mobile?120:150);
    ctx.save();
    ctx.globalAlpha=.24*a;ctx.fillStyle='#000';ctx.fillRect(boxX,boxY,boxW,boxH);
    ctx.globalAlpha=.4*a;ctx.strokeStyle=currentPhase?currentPhase.color:'#aaa';ctx.lineWidth=1.4;ctx.strokeRect(boxX,boxY,boxW,boxH);
    ctx.restore();
    drawText('MODIFIER: '+G.waveModText,CX,boxY+(mobile?14:17),mobile?14:18,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}
// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  if(Math.random()<.3){const a=Math.random()*TAU,r=min(W,H)*.3;const cs=['#0ff','#f0f','#ff0','#4f4'];
    spawnParticle(CX+cos(a)*r,CY+sin(a)*r,cos(a+PI/2)*30,sin(a+PI/2)*30,cs[(Math.random()*4)|0],1,2)}
  updateParticles(dt);drawParticles();
  ctx.save();ctx.strokeStyle='#111d28';ctx.lineWidth=.5;ctx.globalAlpha=.3;ctx.beginPath();
  for(let x=0;x<W;x+=80){ctx.moveTo(x,0);ctx.lineTo(x,H)}for(let y=0;y<H;y+=80){ctx.moveTo(0,y);ctx.lineTo(W,y)}ctx.stroke();ctx.restore();
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  drawText('v2 — Waves + Weapons',CX,CY-40,13,'#888','center','middle');
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+10,16,'#fff','center','middle');
  drawText('WASD=Move  Mouse=Aim',CX,CY+50,10,'#888','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    ctx.save();ctx.globalAlpha=hover?1:.7;
    ctx.fillStyle=hover?'rgba(30,60,80,0.9)':'rgba(8,16,24,0.85)';ctx.fillRect(cx,cy,cw,ch);
    ctx.strokeStyle=bc;ctx.lineWidth=hover?2.5:1.5;ctx.shadowColor=bc;ctx.shadowBlur=hover?15:5;ctx.strokeRect(cx,cy,cw,ch);ctx.restore();
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    // Simple weapon preview
    const pcx=cx+cw/2,pcy=cy+80;
    if(wid==='dagger'){glowPoly([{x:pcx,y:pcy-15},{x:pcx-8,y:pcy+10},{x:pcx+8,y:pcy+10}],def.color,true,3)}
    if(wid==='sword'){drawGlowArc(pcx,pcy,25,-PI/4,PI/4,def.color,2)}
    if(wid==='bow'){glowCircle(pcx,pcy,20,def.color,2);glowLine(pcx,pcy-8,pcx,pcy+8,def.color,2)}
    // Description
    ctx.save();ctx.font='9px monospace';ctx.fillStyle='#aaa';ctx.textAlign='center';ctx.textBaseline='middle';
    const words=def.desc.split(' ');let line='',ly=cy+120;
    for(const w of words){const t=line+w+' ';if(ctx.measureText(t).width>cw-16){ctx.fillText(line.trim(),cx+cw/2,ly);ly+=12;line=w+' '}else line=t}
    ctx.fillText(line.trim(),cx+cw/2,ly);ctx.restore();
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  const m=(G.time/60)|0,s=(G.time%60)|0;
  drawText('Time: '+m+':'+(s<10?'0':'')+s+'  |  Wave: '+G.wave+'  |  Level: '+G.level,CX,CY-18,12,'#aaa','center','middle');
  // Weapons
  let wy=CY+20;
  drawText('Weapons:',CX,wy,11,'#888','center','middle');wy+=16;
  for(const w of G.weapons){const d=WDEFS[w.id];drawText(d.name,CX,wy,10,d.color,'center','middle');wy+=14}
  wy+=20;
  drawText('[R] Restart',CX,wy,12,'#888','center','middle');
}
// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();dmgNums.length=0;trails.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.reflect=false;G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;G.decay=false;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;
  G.weapons=[];G.passives={};G._microBuffs={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}
// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});
// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_DOWN_FN[w.id];if(fn)fn(w,wx,wy);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  const fn=WEAPON_UP_FN[w.id];if(fn)fn(w);
}
// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;
  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='gameover'){
    G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
    ctx.fillStyle='rgba(0,0,0,'+(0.25+0.75*G.gameOverFade)+')';ctx.fillRect(0,0,W,H);
    updateParticles(dt);drawParticles();drawScanlines();drawGameOver();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.5*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }
  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);
  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}
  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);
  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateTrails(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  updateDirector(dt);
  drawTrails();drawSwordAftershocks();drawSwordBossSlashes();
  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}
  ctx.restore();
  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}
requestAnimationFrame(frame);
</script>&oJ>=H&&oJ<=H+Q,D=O?"#fff":L.color;Z.save(),Z.globalAlpha=O?1:0.7,Z.fillStyle=O?"rgba(30,60,80,0.9)":"rgba(8,16,24,0.85)",Z.fillRect(_,H,$,Q),Z.strokeStyle=D,Z.lineWidth=O?2.5:1.5,Z.shadowColor=D,Z.shadowBlur=O?15:5,Z.strokeRect(_,H,$,Q),Z.restore(),f(L.name,_+$/2,H+25,13,D,"center","middle");let Y=_+$/2,U=H+80;if(M==="dagger")YJ([{x:Y,y:U-15},{x:Y-8,y:U+10},{x:Y+8,y:U+10}],L.color,!0,3);if(M==="sword")wZ(Y,U,25,-G/4,G/4,L.color,2);if(M==="bow")zZ(Y,U,20,L.color,2),eZ(Y,U-8,Y,U+8,L.color,2);Z.save(),Z.font="9px monospace",Z.fillStyle="#aaa",Z.textAlign="center",Z.textBaseline="middle";let E=L.desc.split(" "),T="",n=H+120;for(let i of E){let y=T+i+" ";if(Z.measureText(y).width>$-16)Z.fillText(T.trim(),_+$/2,n),n+=12,T=i+" ";else T=y}Z.fillText(T.trim(),_+$/2,n),Z.restore(),f("["+(R+1)+"]",_+$/2,H+Q-20,14,"#555","center","middle")}iJ()}function tJ(J){if(J<0||J>=pJ.length)return;j.weapons=[bZ(pJ[J])],d="playing",pZ()}function p1(){Z.save(),Z.fillStyle="rgba(0,0,0,.5)",Z.fillRect(0,0,g,l),Z.restore(),f("PAUSED",X,P-20,36,"#0ff","center","middle"),f("Press ESC to Resume",X,P+30,16,"#888","center","middle")}function r1(){Z.save(),Z.fillStyle="rgba(0,0,0,.6)",Z.fillRect(0,0,g,l),Z.restore(),f("GAME OVER",X,P-110,36,"#f44","center","middle");let J=B(0,j.wave-1);f("Waves Survived: "+J,X,P-66,17,"#fff","center","middle"),f("Enemies Killed: "+j.totalKills,X,P-44,14,"#9cf","center","middle");let $=j.time/60|0,Q=j.time%60|0;f("Time: "+$+":"+(Q<10?"0":"")+Q+"  |  Wave: "+j.wave+"  |  Level: "+j.level,X,P-18,12,"#aaa","center","middle");let V=P+20;f("Weapons:",X,V,11,"#888","center","middle"),V+=16;for(let K of j.weapons){let q=fJ[K.id];f(q.name,X,V,10,q.color,"center","middle"),V+=14}V+=20,f("[R] Restart",X,V,12,"#888","center","middle")}function uZ(){YZ(),C0(),gZ(),LJ.clear(),gJ.clear(),jZ.clear(),m.clear(),sJ.clear(),PJ.length=0,yJ.length=0,c.x=0,c.y=0,j.time=0,j.difficulty=0.8,j.wave=0,j.waveKills=0,j.waveQuota=0,j.waveState="clear",j.xp=0,j.level=1,j.xpToNext=qJ(200*GZ),j.levelUpQueue=0,j.totalKills=0,j.frozen=!1,j.freezeTimer=0,j.killFlash=0,j.bannerTimer=0,j.waveBannerTimer=0,j.waveModTimer=0,j.waveModText="",j.reflect=!1,j.gravity=0,j.windX=0,j.windY=0,j.pulseTimer=0,j.pulseSpeed=0,j.decay=!1,j.reversed=!1,j.reverseTimer=0,j.reverseCD=0,j.pierce=!1,j.echo=!1,j.weapons=[],j.passives={},j._microBuffs={},j.bossEntity=null,j._twinBoss=null,j._rocketRings=[],j._upgradeTransition=1,j.refreshAvailable=0,j._bossLaserHitCD=0,j._bossModQueue=[],j._bossSpawnPending=!1,j.gameOverFade=0,AJ.length=0,window._staticFields=[],kJ.length=0,uJ.length=0,EJ.length=0,p=null,HZ=-1,cJ=1,eJ=0,d="weaponSelect"}addEventListener("keydown",(J)=>{if(vZ.add(J.code),["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(J.code))J.preventDefault();let $=J.code;if($==="Escape"){if(d==="playing")d="paused";else if(d==="paused")d="playing"}if($==="Enter"&&d==="title")uZ();if($==="KeyR"&&d==="gameover")uZ();if(d==="weaponSelect"){if($==="Digit1")tJ(0);if($==="Digit2")tJ(1);if($==="Digit3")tJ(2)}if(d==="levelUp"&&(j._upgradeTransition||0)>=0.9){if($==="Digit1")mJ(0);if($==="Digit2")mJ(1);if($==="Digit3")mJ(2);if($==="Digit4")mJ(3);if($==="Digit5")mJ(4);if($==="KeyR"&&j.refreshAvailable>0)j.refreshAvailable--,BZ()}if($==="KeyR"&&d==="playing"){let Q=j.weapons.find((V)=>V.id==="dagger");if(Q&&Q.state!=="idle")Q.state="returning"}});function x1(J,$,Q){let V=iZ(J);if(!V)return;let K=K1[V.id];if(K)K(V,$,Q)}function hZ(J){let $=iZ(J);if(!$)return;let Q=z1[$.id];if(Q)Q($)}var fZ=performance.now();function xZ(J){requestAnimationFrame(xZ);let $=W((J-fZ)/1000,0,0.05);if(fZ=J,d==="title"){i1($);return}if(d==="paused"){p1();return}if(d==="weaponSelect"){if(s){let Q=pJ.length,V=180,K=200,q=20,z=180*Q+20*(Q-1),R=X-z/2,M=P-70;for(let L=0;L<Q;L++){let _=R+L*200;if(s.x>=_&&s.x<=_+180&&s.y>=M&&s.y<=M+200){tJ(L);break}}s=null}d1();return}if(d==="gameover"){j.gameOverFade=r(1,(j.gameOverFade||0)+$*2.8),Z.fillStyle="rgba(0,0,0,"+(0.25+0.75*j.gameOverFade)+")",Z.fillRect(0,0,g,l),_Z($),IZ(),iJ(),r1();return}if(d==="levelUp"){if(j._upgradeTransition===void 0)j._upgradeTransition=1;j._upgradeTransition=r(1,j._upgradeTransition+$*4);let Q=j._upgradeTransition,V=Q<1?1-Math.pow(1-Q,3):1;if(Z.fillStyle="rgba(0,0,0,"+0.5*V+")",Z.fillRect(0,0,g,l),s&&Q>=0.9){let K=r(5,TJ.length),q=150,z=140,R=12,M=150*K+12*(K-1),L=X-M/2,_=P-60;for(let H=0;H<K;H++){let O=L+H*162;if(s.x>=O&&s.x<=O+150&&s.y>=_&&s.y<=_+140){mJ(H);break}}s=null}else if(s)s=null;n1(V),iJ();return}if(s&&d==="playing"){let Q=NZ();x1(s.btn,Q.x,Q.y),s=null}if(!VZ)hZ(0);if(!KZ)hZ(2);if(eJ>0)eJ-=$,$*=mZ;if(j.time+=$,j.killFlash=B(0,j.killFlash-$),j.levelUpQueue>0&&d==="playing"){BZ(),d="levelUp",j._upgradeTransition=0,j.refreshAvailable=1;return}if(c.x=x(c.x,N.x,8*$),c.y=x(c.y,N.y,8*$),Z.fillStyle="rgba(0,0,0,"+VJ.trailAlpha+")",Z.fillRect(0,0,g,l),cZ(),Z.save(),Z.translate(-c.x+X+MZ,-c.y+P+FZ),T0(),S0(),A0($),r0($),w0($),Y0($),TZ(LJ,$,!1),TZ(gJ,$,!0),_Z($),$0($),V0($),j0($),F0($),H0($),o1(),w1($),K0(),R0(),_0(),v0(),SZ(LJ),SZ(gJ),l0(),P0(),x0(),O0(),N1(),IZ(),Q0(),j._twinBoss){let Q=j._twinBoss;if(Q[0]&&Q[0].active&&Q[1]&&Q[1].active&&Q[0].bossAI.linkBeam){Z.save();let V=W(0.4+F(j.time*5)*0.2,0,1);Z.beginPath(),Z.moveTo(Q[0].x,Q[0].y),Z.lineTo(Q[1].x,Q[1].y),Z.strokeStyle="#f4a",Z.lineWidth=6,Z.globalAlpha=V*0.3,Z.shadowColor="#f4a",Z.shadowBlur=15,Z.stroke(),Z.beginPath(),Z.moveTo(Q[0].x,Q[0].y),Z.lineTo(Q[1].x,Q[1].y),Z.strokeStyle="#fff",Z.lineWidth=2,Z.globalAlpha=V*0.5,Z.shadowBlur=8,Z.stroke();let K=Q[1].x-Q[0].x,q=Q[1].y-Q[0].y,z=b(K*K+q*q);if(z>0){let R=-q/z,M=K/z,L=N.x-Q[0].x,_=N.y-Q[0].y,H=L*K/z+_*q/z,O=GJ(L*R+_*M);if(H>0&&H<z&&O<20)QZ()}Z.restore()}else if(Q[0]&&!Q[0].active&&Q[1]&&Q[1].active)j.bossEntity=Q[1]}if(m.each((Q)=>{if(!Q.active||!Q.isBoss||!Q.bossAI||!Q.bossAI._portals)return;for(let V of Q.bossAI._portals){let K=W(V.life/0.25,0,1);aJ(V.x1,V.y1,K,0),aJ(V.x2,V.y2,K,1.1)}}),m.each((Q)=>{if(!Q.active||!Q.isBoss||!Q.bossAI||!Q.bossAI._warpTele)return;let V=Q.bossAI._warpTele,K=1-W(V.t/B(0.0001,V.maxT),0,1);aJ(V.toX,V.toY,0.35+0.65*K,1.6),aJ(Q.x,Q.y,0.25+0.45*K,0.35)}),j._rocketRings)for(let Q=j._rocketRings.length-1;Q>=0;Q--){let V=j._rocketRings[Q];if(V.life-=$,V.life<=0){j._rocketRings.splice(Q,1);continue}let K=1-V.life/V.maxLife;Z.save(),Z.beginPath(),Z.arc(V.x,V.y,V.r*K,0,v),Z.strokeStyle="#f80",Z.lineWidth=3*(1-K),Z.globalAlpha=(1-K)*0.6,Z.shadowColor="#f80",Z.shadowBlur=10,Z.stroke(),Z.beginPath(),Z.arc(V.x,V.y,V.r*K*0.6,0,v),Z.strokeStyle="#ff4",Z.lineWidth=2*(1-K),Z.globalAlpha=(1-K)*0.4,Z.stroke(),Z.restore()}if(Z.restore(),j.killFlash>0)Z.save(),Z.fillStyle="#fff",Z.globalAlpha=j.killFlash*3,Z.fillRect(0,0,g,l),Z.restore();if(j.frozen)Z.save(),Z.fillStyle="rgba(50,100,200,0.08)",Z.fillRect(0,0,g,l),Z.restore();l1(),b1(),iJ(),s=null}requestAnimationFrame(xZ);})();</script></body></html>