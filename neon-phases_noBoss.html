<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>NEON PHASES</title>
<style>*{margin:0;padding:0}body{background:#000;overflow:hidden}canvas{display:block;cursor:crosshair}</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════

// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  cullDist:1400,
};

// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}

// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
const PLAYER_COLOR='#0ff',HOSTILE_COLOR_FALLBACK='#0cf';
function hostileColor(c){
  if(typeof c==='string'&&c.toLowerCase()===PLAYER_COLOR)return HOSTILE_COLOR_FALLBACK;
  return c||'#f44';
}

// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();

// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}

// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Banner
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',
  gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}

// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  const sl=p._speedLoop|0,dl=p._damageLoop|0;
  if(sl)stats.moveSpeed*=1+sl*.15;
  if(dl)stats.dmgMult*=1+dl*.3;
}

// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}

// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function strokeRing(x,y,r,c,w,a){ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=w||1;if(a!==undefined)ctx.globalAlpha=a;ctx.stroke()}
function drawPanel(x,y,w,h,f,s,sw,a){ctx.save();if(a!==undefined)ctx.globalAlpha=a;if(f){ctx.fillStyle=f;ctx.fillRect(x,y,w,h)}if(s){ctx.strokeStyle=s;ctx.lineWidth=sw||1;ctx.strokeRect(x,y,w,h)}ctx.restore()}

// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,baseSpeed:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);

// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}

// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}

// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function drawBeamBody(x1,y1,x2,y2,w,a,col,hot){
  const outer=w*(hot?(1+.35*a):(.8+.4*a));
  const mid=max(hot?4:3,w*(hot?.45:.3)*(hot?(.85+.25*a):(.8+.3*a)));
  const core=max(hot?2.5:2,w*(hot?.2:.12));
  ctx.save();ctx.lineCap='round';
  const g1=ctx.createLinearGradient(x1,y1,x2,y2);
  g1.addColorStop(0,'rgba(255,255,255,0)');
  g1.addColorStop(.08,hot?('rgba(255,216,74,'+(.12+.14*a)+')'):('rgba(255,216,74,'+(.12+.14*a)+')'));
  g1.addColorStop(1,hot?('rgba(255,120,120,'+(.1+.22*a)+')'):('rgba(255,216,74,'+(.08+.2*a)+')'));
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g1;ctx.lineWidth=outer;ctx.globalAlpha=1;ctx.shadowColor=col;ctx.shadowBlur=hot?18:20;ctx.stroke();
  const g2=ctx.createLinearGradient(x1,y1,x2,y2);
  g2.addColorStop(0,'rgba(255,255,255,0)');
  g2.addColorStop(hot?.1:.08,'rgba(255,255,255,'+(hot?(.15+.2*a):(.16+.2*a))+')');
  g2.addColorStop(1,hot?('rgba(255,180,180,'+(.2+.38*a)+')'):('rgba(255,216,74,'+(.2+.4*a)+')'));
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g2;ctx.lineWidth=mid;ctx.shadowBlur=hot?10:12;ctx.stroke();
  const g3=ctx.createLinearGradient(x1,y1,x2,y2);
  g3.addColorStop(0,'rgba(255,255,255,0)');
  g3.addColorStop(hot?.12:.1,'rgba(255,255,255,'+(hot?(.25+.25*a):(.25+.25*a))+')');
  g3.addColorStop(1,'rgba(255,255,255,'+(hot?(.3+.4*a):(.35+.45*a))+')');
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g3;ctx.lineWidth=core;ctx.shadowBlur=hot?6:8;ctx.stroke();
  ctx.restore();
}
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active)return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      if(w.id==='bow'){
        const burnLv=clamp(w.lv.c|0,0,2);
        if(burnLv>0){
          e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
          e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
        }
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle(),hot:false});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    drawBeamBody(b.x1,b.y1,b.x2,b.y2,b.width*pulse,a,b.color,false);
    ctx.save();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}

// == GROUND ==
function drawGround(){
  const gs=100,ms=50,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs;
  const sx=floor(l/gs)*gs,sy=floor(t/gs)*gs,mx=floor(l/ms)*ms,my=floor(t/ms)*ms;
  ctx.save();
  ctx.strokeStyle='#2a5f82';ctx.lineWidth=.9;ctx.globalAlpha=.62;ctx.beginPath();
  for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}
  for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}
  ctx.stroke();
  ctx.strokeStyle='#18344a';ctx.lineWidth=.6;ctx.globalAlpha=.38;ctx.beginPath();
  for(let x=mx;x<=r;x+=ms){ctx.moveTo(x,t);ctx.lineTo(x,bt)}
  for(let y=my;y<=bt;y+=ms){ctx.moveTo(l,y);ctx.lineTo(r,y)}
  ctx.stroke();
  ctx.fillStyle='#58b7ff';ctx.globalAlpha=.22;
  for(let x=mx;x<=r;x+=ms)for(let y=my;y<=bt;y+=ms)ctx.fillRect(x-1.5,y-1.5,3,3);
  ctx.restore();
}
// == MENU BACKGROUND ==
const MENU_COLORS=['#f44','#f84','#fd4','#f6f','#9f6','#f95'];
const menuBg={t:0,enemies:[],bullets:[]};
function spawnMenuEnemy(e){
  e=e||{};
  e.x=rr(0,W);e.y=rr(0,H);
  const a=rAngle(),s=rr(35,95);
  e.vx=cos(a)*s;e.vy=sin(a)*s;
  e.r=rr(8,16);e.shape=rPick(['circle','triangle']);
  e.color=rPick(MENU_COLORS);e.fire=rr(.2,1.1);
  return e;
}
function menuShoot(e){
  const a=atan2(CY-e.y,CX-e.x)+rr(-.9,.9),s=rr(120,220);
  menuBg.bullets.push({x:e.x,y:e.y,vx:cos(a)*s,vy:sin(a)*s,life:rr(1.2,2.6),r:2.4,color:e.color});
}
function updateMenuBg(dt){
  if(!menuBg.enemies.length)for(let i=0;i<10;i++)menuBg.enemies.push(spawnMenuEnemy({}));
  menuBg.t+=dt;
  for(const e of menuBg.enemies){
    e.fire-=dt;
    e.x+=e.vx*dt;e.y+=e.vy*dt;
    if(e.x<-20||e.x>W+20||e.y<-20||e.y>H+20)spawnMenuEnemy(e);
    if(e.fire<=0){menuShoot(e);e.fire=rr(.25,1.2)}
  }
  for(let i=menuBg.bullets.length-1;i>=0;i--){
    const b=menuBg.bullets[i];
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    if(b.life<=0||b.x<-30||b.y<-30||b.x>W+30||b.y>H+30)menuBg.bullets.splice(i,1);
  }
}
function drawMenuBg(dt,shade){
  updateMenuBg(dt||0);
  ctx.fillStyle='#02060b';ctx.fillRect(0,0,W,H);
  const gs=100,ms=50,ox=(menuBg.t*30)%gs,oy=(menuBg.t*16)%gs,mox=(menuBg.t*46)%ms,moy=(menuBg.t*26)%ms;
  ctx.save();
  ctx.strokeStyle='#2a5f82';ctx.lineWidth=.9;ctx.globalAlpha=.5;ctx.beginPath();
  for(let x=-ox;x<=W+gs;x+=gs){ctx.moveTo(x,0);ctx.lineTo(x,H)}
  for(let y=-oy;y<=H+gs;y+=gs){ctx.moveTo(0,y);ctx.lineTo(W,y)}
  ctx.stroke();
  ctx.strokeStyle='#18344a';ctx.lineWidth=.6;ctx.globalAlpha=.35;ctx.beginPath();
  for(let x=-mox;x<=W+ms;x+=ms){ctx.moveTo(x,0);ctx.lineTo(x,H)}
  for(let y=-moy;y<=H+ms;y+=ms){ctx.moveTo(0,y);ctx.lineTo(W,y)}
  ctx.stroke();
  ctx.fillStyle='#58b7ff';ctx.globalAlpha=.14;
  for(let x=-mox;x<=W+ms;x+=ms)for(let y=-moy;y<=H+ms;y+=ms)ctx.fillRect(x-1,y-1,2,2);
  ctx.restore();
  for(const b of menuBg.bullets){ctx.save();ctx.globalAlpha=.45*clamp(b.life/2,0,1);glowDot(b.x,b.y,b.r,b.color);ctx.restore()}
  for(const e of menuBg.enemies){
    ctx.save();ctx.globalAlpha=.55;
    if(e.shape==='circle')glowCircle(e.x,e.y,e.r,e.color,3);
    else glowPoly(triPts(e.x,e.y,e.r,menuBg.t*1.2),e.color,true,3);
    ctx.restore();
  }
  if(shade){ctx.fillStyle='rgba(0,0,0,'+shade+')';ctx.fillRect(0,0,W,H)}
}

// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
}

// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt},
  stationary(e,dt){},
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt},
};

// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
};
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=hostileColor(c||'#f44');b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx)})}

// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];

function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=hostileColor(opts&&opts.color||rPick(ECOLORS));
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;if(EFIRE[e.firePattern])EFIRE[e.firePattern](e)}
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist)e.active=false;
  });
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const d=e._dashTele,p=1-clamp(d.t/max(.0001,d.maxT),0,1),a=atan2(d.ty-e.y,d.tx-e.x),ax=e.x+cos(a)*(e.r+12),ay=e.y+sin(a)*(e.r+12);
  ctx.save();
  strokeRing(e.x,e.y,e.r+8+sin(G.time*18)*2,'rgba(255,235,140,'+(.24+.42*p)+')',2.1);
  ctx.translate(ax,ay);ctx.rotate(a);const ts=7+p*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*p)+')';ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    let col=e.hitFlash>0?'#fff':e.color;
    const cc=e.cc;
    if(cc.fearT>0)col='#ddd';
    const r=e.r+(e.hitFlash>0?2:0);
    const gn=e.tier==='elite'?4:3;
    if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
    else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
    else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    if(e._dashTele&&e.moveType==='dasher')drawDashTelegraph(e);
    if(e.tier==='elite'&&e.hp<e.maxHp){
      const bw=e.r*2;ctx.fillStyle='#333';ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);ctx.fillStyle=e.color;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);
    }
    if(cc.markT>0){ctx.beginPath();ctx.arc(e.x,e.y-e.r-10,3,0,TAU);ctx.fillStyle='#ccc';ctx.fill()}
    if(cc.stunT>0||cc.rootT>0||cc.slowT>0||cc.bleedT>0){
      ctx.beginPath();ctx.arc(e.x,e.y,e.r+3,0,TAU);ctx.strokeStyle='rgba(255,255,255,.4)';ctx.lineWidth=1.2;ctx.stroke();
    }
    if(cc.silenceT>0){
      const sr=e.r+5;
      ctx.beginPath();ctx.moveTo(e.x-sr,e.y-sr);ctx.lineTo(e.x+sr,e.y+sr);
      ctx.moveTo(e.x+sr,e.y-sr);ctx.lineTo(e.x-sr,e.y+sr);
      ctx.strokeStyle='#0aa';ctx.lineWidth=2.2;ctx.globalAlpha=.85;ctx.stroke();
    }
  });
}

// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  const rc=b.src==='rocket'||b.src==='rocket_mini'?(b.src==='rocket_mini'?'#fa0':'#f80'):b.color;
  glowDot(b.x,b.y,b.r,rc);
  ctx.restore()})}

// == WEAPON SYSTEM ==
// Weapon state per slot
const initFields=(s,o)=>{for(const k in o)s[k]=o[k]};
const WEAPON_INIT_FN={
  dagger:s=>initFields(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>initFields(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>initFields(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>initFields(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>initFields(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}

// Weapon definitions (packed rows -> hydrated objects for smaller source footprint)
const WDATA=[
  ['dagger','MAGIC DAGGER','#0ff','starter','Click to throw. Click again to redirect.','',[
    ['a','PIERCING THROW',3,['+50% speed','90% + homing','120% + homing']],
    ['b','SPECTRAL COPY',3,['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']],
    ['d','DAGGER STORM',2,['0.8s +75% radius','1.2s +150% radius']],
  ]],
  ['sword','PLASMA SWORD','#f0f','starter','Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.','',[
    ['a','LUNGE REACH',3,['+33% range','+67%','+108%']],
    ['b','WIDE CLEAVE',3,['+25% size','+50%','+88%']],
    ['c','EDGE CHARGE',2,['+15% length +2 dmg','+30% length +4 dmg']],
  ]],
  ['bow','VOLT BOW','#ff0','starter','Hold to charge, release a piercing beam.','',[
    ['a','PRISM SPLIT',2,['1 side pair','2 side pairs']],
    ['b','QUICK DRAW',3,['1.0s charge','0.8s','0.6s']],
    ['c','PLASMA BURN',2,['Applies burn','Stronger burn']],
  ]],
  ['chain','CHAIN LIGHTNING','#a0f','cc','Auto-zaps bullets, chains targets, leaves stun fields.','BULLET CLEAR',[
    ['a','EXTRA CHAINS',2,['+3 chains','+6 chains']],
    ['b','MULTI STRIKE',2,['2 bolts at once','3 bolts']],
    ['c','STATIC FIELD',2,['3s stun zone','5s wider zone']],
  ]],
  ['rocket','ROCKET LAUNCHER','#f80','cc','Homing rockets explode for knockback and bullet clearing.','KNOCKBACK',[
    ['a','CONCUSSIVE BLAST',3,['+60 kb','+120 kb','+200 kb']],
    ['b','CLUSTER BOMB',2,['5 homing minis','7']],
    ['c','BLAST RADIUS',2,['+44%','+78%']],
  ]],
];
const WDEFS={};
for(const w of WDATA){
  const ups=[];
  for(let i=0;i<w[6].length;i++){const u=w[6][i];ups.push({id:u[0],name:u[1],maxLv:u[2],desc:u[3]})}
  const d={name:w[1],color:w[2],type:w[3],desc:w[4],upgrades:ups};
  if(w[5])d.cc=w[5];
  WDEFS[w[0]]=d;
}
const STARTER_KEYS=['dagger','sword','bow'];
const IMPLEMENTED_CC=['chain','rocket'];

// Weapon update/draw dispatch
function updateWeapons(dt){
  for(const w of G.weapons){
    if(w.id==='dagger')updateDagger(w,dt);
    else if(w.id==='sword')updateSword(w,dt);
    else if(w.id==='bow')updateBow(w,dt);
    else if(w.id==='chain')updateChain(w,dt);
    else if(w.id==='rocket')updateRocket(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    if(w.id==='dagger')drawDagger(w);
    else if(w.id==='sword')drawSword(w);
    else if(w.id==='bow')drawBow(w);
    else if(w.id==='chain')drawChain(w);
    else if(w.id==='rocket')drawRocket(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}

// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}

// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8+[0,2,4][w.lv.c];
    const bladeReach=70*(1+[0,.15,.3][w.lv.c]);
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a]*(1+[0,.15,.3][w.lv.c]);
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60*(1+[0,.15,.3][w.lv.c]);
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    const sx=w.lungeStartX,sy=w.lungeStartY,ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const mx=(sx+ex)*.5,my=(sy+ey)*.5,sw=max(10,ld*prog);
    ctx.save();
    ctx.translate(mx,my);ctx.rotate(a);
    ctx.fillStyle='rgba(255,120,255,.14)';ctx.fillRect(-sw*.5,-cleaveW*.45,sw,cleaveW*.9);
    ctx.strokeStyle='rgba(255,170,255,.22)';ctx.lineWidth=1;ctx.strokeRect(-sw*.5,-cleaveW*.45,sw,cleaveW*.9);
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}

// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    strokeRing(player.x,player.y,r,'#ffd84a',1.2+pct*1.2,.3+pct*.5);
    strokeRing(player.x,player.y,r*.55,'#fff',.9+pct*.9,.25+pct*.45);
    ctx.restore();
  }
}

function nearestEnemy(x,y,maxD,skip){
  let best=null,bestD=maxD===undefined?Infinity:maxD;
  enemies.each(e=>{
    if(!e.active)return;
    if(skip&&(skip.has?skip.has(e):skip(e)))return;
    const d=dist(x,y,e.x,e.y);
    if(d<bestD){bestD=d;best=e}
  });
  return best;
}
function nearestEnemyBullet(x,y,maxD,skipA,skipB){
  let best=null,bestD=maxD===undefined?Infinity:maxD;
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(skipA&&(skipA.has?skipA.has(b):skipA(b)))return;
    if(skipB&&(skipB.has?skipB.has(b):skipB(b)))return;
    const d=dist(x,y,b.x,b.y);
    if(d<bestD){bestD=d;best=b}
  });
  return best;
}
function steerVelocity(vx,vy,targetX,targetY,x,y,turnRate,dt){
  const desired=atan2(targetY-y,targetX-x);
  const cur=atan2(vy,vx);
  const turn=clamp(normAng(desired-cur),-turnRate*dt,turnRate*dt);
  const na=cur+turn;
  const spd=sqrt(vx*vx+vy*vy);
  return{vx:cos(na)*spd,vy:sin(na)*spd};
}

// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    if(!nearestEnemyBullet(player.x,player.y,range))return;
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    const globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      const hitBullets=new Set(),targets=[];
      let sx=player.x,sy=player.y;
      if(bolt>0){const oa=TAU/bolts*bolt;sx=player.x+cos(oa)*15;sy=player.y+sin(oa)*15}
      for(let c=0;c<maxChains;c++){
        const bestObj=nearestEnemyBullet(sx,sy,range+(c>0?100:0),hitBullets,globalHit);
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        sx=bestObj.x;sy=bestObj.y;
      }
      let px=bolt>0?player.x+cos(TAU/bolts*bolt)*15:player.x;
      let py=bolt>0?player.y+sin(TAU/bolts*bolt)*15:player.y;
      for(const t of targets){
        const pts=generateLightningPath(px,py,t.x,t.y,8);
        w._zigzags.push(pts);
        w._targets.push(t);
        px=t.x;py=t.y;
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        e.cc.stunT=max(e.cc.stunT,f.stunDur);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    const drawArcLayer=(pts,col,lw,a,blur)=>{
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle=col;ctx.lineWidth=lw;ctx.globalAlpha=a;ctx.shadowColor=col;ctx.shadowBlur=blur;ctx.stroke();
    };
    ctx.save();
    for(const pts of w._zigzags){
      drawArcLayer(pts,'#a0f',6,alpha*.25,15);
      drawArcLayer(pts,'#c6f',3,alpha*.6,8);
      drawArcLayer(pts,'#eaf',1.5,alpha,4);
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}

// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    const best=nearestEnemy(player.x,player.y,9999);
    const a=best?atan2(best.y-player.y,best.x-player.x):player.angle;
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;
      b.split=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    const best=nearestEnemy(b.x,b.y,800);
    if(best){
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const nv=steerVelocity(b.vx,b.vy,best.x,best.y,b.x,b.y,turnRate,dt);
      b.vx=nv.vx;b.vy=nv.vy;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}

// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce;e.cc.kbVy=sin(a)*kbForce;
      e.cc.disorientT=disorient;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.split=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}

// == PASSIVES ==
const PASSIVE_ROWS=[
  ['regen','REGENERATION','#4f4',3,['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']],
  ['speed','SPEED BOOST','#4f4',3,['+15% speed','+30%','+40% + 8% dodge']],
  ['cooldown','COOLDOWN REDUCTION','#48f',3,['-12% all CDs','-20%','-25% + faster weapons']],
  ['damage','POWER SURGE','#f44',2,['+30% damage','+50% damage']],
];
const PASSIVE_DEFS={};
for(let i=0;i<PASSIVE_ROWS.length;i++){const p=PASSIVE_ROWS[i];PASSIVE_DEFS[p[0]]={name:p[1],color:p[2],maxLv:p[3],desc:p[4]}}
const IMPL_PASSIVES=PASSIVE_ROWS.map(p=>p[0]);

// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE)spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small');
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    if(G.waveKills>=G.waveQuota){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(2,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
}

function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
}

// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  if(e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  let isCrit=forceCrit||false;
  if(!isCrit&&stats.critChance>0&&Math.random()<stats.critChance){isCrit=true;dmg*=stats.critMult}
  dmg*=stats.dmgMult;
  if(e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  let xpBase=e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult;
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5);
}

function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    keys.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='dying';
  }
}

// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  let passiveCount=0;
  for(let i=0;i<IMPL_PASSIVES.length;i++)if((G.passives[IMPL_PASSIVES[i]]|0)>0)passiveCount++;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, loop stage-1 speed/damage upgrades.
  if(upgradeChoices.length<5){
    while(upgradeChoices.length<5){
      const id=(upgradeChoices.length&1)?'speed':'damage';
      upgradeChoices.push({type:'loopPassive',passiveId:id,def:PASSIVE_DEFS[id]});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='loopPassive'){const k=c.passiveId==='speed'?'_speedLoop':'_damageLoop';G.passives[k]=(G.passives[k]|0)+1}
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  ctx.save();ctx.globalAlpha=ease;drawText('LEVEL UP',CX,CY-140,22,'#ff0','center','middle');ctx.restore();
  const n=min(5,upgradeChoices.length),cw=150,ch=140,g=12,total=cw*n+g*(n-1),sx=CX-total/2,sy=CY-60;
  for(let i=0;i<n;i++){
    const c=upgradeChoices[i],x=sx+i*(cw+g),y=sy;
    const hov=mouseX>=x&&mouseX<=x+cw&&mouseY>=y&&mouseY<=y+ch;
    let col='#0ff',name='',desc='';
    if(c.type==='weaponUpg'){col=c.wdef.color;name=c.wdef.name+': '+c.def.name;desc=c.def.desc[c.curLv]||''}
    else if(c.type==='newWeapon'){col=c.wdef.color;name='NEW '+c.wdef.name;desc=c.wdef.cc?('CC: '+c.wdef.cc):c.wdef.desc}
    else if(c.type==='newPassive'){col=c.def.color;name='NEW '+c.def.name;desc=c.def.desc[0]}
    else if(c.type==='passiveUpg'){col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv]||''}
    else if(c.type==='loopPassive'){col=c.def.color;name=c.def.name;desc=c.def.desc[0]}
    drawPanel(x,y,cw,ch,'rgba(8,16,24,.9)',hov?'#fff':col,hov?2:1.2,hov?1:.78);
    drawText(name,x+cw/2,y+24,10,hov?'#fff':col,'center','middle');
    drawText(desc,x+cw/2,y+70,9,'#9aa','center','middle');
    drawText('['+(i+1)+']',x+cw/2,y+ch-14,12,'#666','center','middle');
  }
  drawText(G.refreshAvailable>0?('[R] Reroll ('+G.refreshAvailable+')'):'[R] No rerolls',CX,sy+ch+20,13,G.refreshAvailable>0?'#4f4':'#666','center','middle');
}

// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}

// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const topW=min(W-16,560),topH=54,topX=CX-topW/2,topY=10;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1),xpProg=clamp(G.xp/G.xpToNext,0,1);
  const hpCol=hpProg>.5?'#0ef':hpProg>.25?'#fd4':'#f55';
  drawPanel(topX,topY,topW,topH,'rgba(0,0,0,.55)','rgba(255,255,255,.15)',1);
  const hpX=topX+42,hpY=topY+9,hpW=topW-54,hpH=12,seg=10,gap=2,segW=(hpW-gap*(seg-1))/seg;
  for(let i=0;i<seg;i++){
    const x=hpX+i*(segW+gap),fill=clamp(hpProg*seg-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(x,hpY,segW,hpH);
    if(fill>0){ctx.fillStyle=hpCol;ctx.fillRect(x,hpY,segW*fill,hpH)}
    ctx.strokeStyle='rgba(255,255,255,.24)';ctx.strokeRect(x,hpY,segW,hpH);
  }
  const xpY=hpY+hpH+6;
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(hpX,xpY,hpW,9);
  ctx.fillStyle='#fd4';ctx.fillRect(hpX,xpY,hpW*xpProg,9);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.strokeRect(hpX,xpY,hpW,9);
  drawText('HP',topX+12,hpY,10,'#dff');drawText('XP',topX+12,xpY-1,10,'#fd4');
  const sec=(G.time%60)|0,minu=(G.time/60)|0;
  drawText('TIME '+minu+':'+(sec<10?'0':'')+sec,topX+12,topY+41,9,'#8ea');
  const by=topY+topH+8,bw=min(W-80,460),bx=CX-bw/2;
  if(G.waveState==='spawning'){
    const p=clamp(G.waveKills/G.waveQuota,0,1);
    drawPanel(bx,by,bw,7,'rgba(20,20,20,.92)','rgba(0,255,255,.32)',1);
    ctx.fillStyle='#0ff';ctx.fillRect(bx,by,bw*p,7);
  }
  const CD={chain:.8,rocket:2.2},sw=52,start=CX-(max(1,G.weapons.length)*sw)/2+sw/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],d=WDEFS[w.id],x=start+i*sw,y=H-46;
    drawPanel(x-18,y-12,36,24,'rgba(0,0,0,.5)',d.color,1);
    drawText(d.name.charAt(0),x,y-1,12,d.color,'center','middle');
    const mc=CD[w.id];if(mc&&w.timer!==undefined){const p=clamp(1-w.timer/mc,0,1);ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(x-18,y+14,36,3);ctx.fillStyle=d.color;ctx.fillRect(x-18,y+14,36*p,3)}
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    ctx.restore()}
}

// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  drawMenuBg(dt,.28);
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  if((titleTime*2|0)%2)drawText('Press ENTER',CX,CY+12,16,'#fff','center','middle');
  drawScanlines();
}
function drawWeaponSelect(){
  ctx.fillStyle='rgba(0,0,0,.75)';ctx.fillRect(0,0,W,H);
  drawText('CHOOSE WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  function drawCardDesc(text,cx,top,w,maxLines){
    ctx.save();ctx.font='bold 9px monospace';
    const words=(text||'').split(/\s+/).filter(Boolean),lines=[];let line='';
    for(let i=0;i<words.length;i++){
      const next=line?line+' '+words[i]:words[i];
      if(ctx.measureText(next).width>w&&line){lines.push(line);line=words[i]}
      else line=next;
    }
    if(line)lines.push(line);
    const shown=lines.slice(0,maxLines);
    if(lines.length>maxLines&&shown.length)shown[shown.length-1]=shown[shown.length-1].replace(/\.*$/,'')+'...';
    ctx.textAlign='center';ctx.textBaseline='top';ctx.fillStyle='#9aa';
    for(let i=0;i<shown.length;i++)ctx.fillText(shown[i],cx,top+i*12);
    ctx.restore();
  }
  for(let i=0;i<n;i++){
    const def=WDEFS[STARTER_KEYS[i]];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    drawPanel(cx,cy,cw,ch,'rgba(8,16,24,0.9)',bc,hover?2:1.2,hover?1:.75);
    drawText(def.name,cx+cw/2,cy+25,13,bc,'center','middle');
    drawText(def.type==='starter'?'PRIMARY':'CC',cx+cw/2,cy+62,10,def.color,'center','middle');
    drawCardDesc(def.desc,cx+cw/2,cy+84,cw-22,4);
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Kills: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  drawText('[R] Restart',CX,CY+30,12,'#888','center','middle');
}
function drawDeathFade(dt,drawFx){
  G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
  if(drawFx){updateParticles(dt);drawParticles()}
  ctx.fillStyle='rgba(0,0,0,'+G.gameOverFade+')';ctx.fillRect(0,0,W,H);
  drawScanlines();
  if(G.gameOverFade>=1)state='gameover';
}

// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  dmgNums.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;
  G.weapons=[];G.passives={};G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G.gameOverFade=0;
  window._staticFields=[];bowBeams.length=0;
  spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}

// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(state==='dying')return;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});

// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  if(w.id==='dagger')onDaggerClick(w,wx,wy);
  else if(w.id==='sword')onSwordClick(w,wx,wy);
  else if(w.id==='bow')onBowDown(w);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  if(w.id==='bow')onBowUp(w);
}

// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;

  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect();return;
  }
  if(state==='dying'){drawDeathFade(dt,true);return}
  if(state==='gameover'){
    ctx.fillStyle='#000';ctx.fillRect(0,0,W,H);
    drawGameOver();drawScanlines();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.65*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }

  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);

  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}

  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);

  drawGround();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateBowBeams(dt);
  checkCollisions();
  if(state==='dying'){
    ctx.restore();
    drawDeathFade(dt,false);
    pendingClick=null;
    return;
  }
  updateDirector(dt);

  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}

  ctx.restore();

  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}

requestAnimationFrame(frame);
</script>
</body>
</html>
