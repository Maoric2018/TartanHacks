<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>NEON PHASES</title>
<style>*{margin:0;padding:0}body{background:#000;overflow:hidden}canvas{display:block;cursor:crosshair}</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
'use strict';
// ═══════════════════════════════════════════════════════════
// NEON PHASES v2 — Wave+XP+Weapons Overhaul
// ═══════════════════════════════════════════════════════════

// == CONFIG ==
const CFG = {
  playerSpeed:240,
  playerHP:10, playerR:12, invulnDur:0.8, trailAlpha:0.18,
  maxEnemies:50, maxEBullets:900, maxPBullets:150, maxParticles:500,
  chunkSize:500, cullDist:1400,
};

// == RNG ==
function rr(a,b){return a+Math.random()*(b-a)} function ri(a,b){return(a+Math.random()*(b-a+1))|0}
function rAngle(){return Math.random()*Math.PI*2} function rPick(a){return a[(Math.random()*a.length)|0]}

// == MATH ==
const PI=Math.PI,TAU=PI*2,{cos,sin,sqrt,abs,min,max,atan2,floor}=Math;
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v}
function lerp(a,b,t){return a+(b-a)*t}
function dist(x1,y1,x2,y2){return sqrt((x1-x2)**2+(y1-y2)**2)}
function pointSegDist(px,py,x1,y1,x2,y2){
  const dx=x2-x1,dy=y2-y1;
  const len2=dx*dx+dy*dy;
  if(len2<=1e-6)return dist(px,py,x1,y1);
  const t=clamp(((px-x1)*dx+(py-y1)*dy)/len2,0,1);
  const qx=x1+dx*t,qy=y1+dy*t;
  return dist(px,py,qx,qy);
}
function normAng(a){while(a>PI)a-=TAU;while(a<-PI)a+=TAU;return a}
function angDiff(a,b){return normAng(b-a)}
function ptInArc(px,py,cx,cy,dir,halfArc,range){
  const d=dist(px,py,cx,cy);if(d>range)return false;
  const a=atan2(py-cy,px-cx);return abs(angDiff(dir,a))<=halfArc;
}
const PLAYER_COLOR='#0ff',HOSTILE_COLOR_FALLBACK='#0cf';
function hostileColor(c){
  if(typeof c==='string'&&c.toLowerCase()===PLAYER_COLOR)return HOSTILE_COLOR_FALLBACK;
  return c||'#f44';
}

// == CANVAS + CAMERA ==
const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
let W,H,CX,CY,dpr;const cam={x:0,y:0};
function resize(){dpr=devicePixelRatio||1;W=innerWidth;H=innerHeight;cvs.width=W*dpr;cvs.height=H*dpr;cvs.style.width=W+'px';cvs.style.height=H+'px';ctx.setTransform(dpr,0,0,dpr,0,0);CX=W/2;CY=H/2}
addEventListener('resize',resize);resize();

// == INPUT ==
const keys=new Set();
let mouseX=CX,mouseY=CY,pendingClick=null,mouseDown=false,rightDown=false;
addEventListener('keyup',e=>keys.delete(e.code));
addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY});
addEventListener('mousedown',e=>{if(e.button===0)mouseDown=true;if(e.button===2)rightDown=true;pendingClick={x:e.clientX,y:e.clientY,btn:e.button}});
addEventListener('mouseup',e=>{if(e.button===0)mouseDown=false;if(e.button===2)rightDown=false});
addEventListener('contextmenu',e=>e.preventDefault());
function kd(c){return keys.has(c)}
function getMoveDir(){let dx=0,dy=0;if(kd('KeyW')||kd('ArrowUp'))dy=-1;if(kd('KeyS')||kd('ArrowDown'))dy=1;if(kd('KeyA')||kd('ArrowLeft'))dx=-1;if(kd('KeyD')||kd('ArrowRight'))dx=1;const l=sqrt(dx*dx+dy*dy);return l>0?{x:dx/l,y:dy/l}:{x:0,y:0}}
function worldMouse(){return{x:mouseX-CX+cam.x,y:mouseY-CY+cam.y}}

// == GAME STATE ==
let state='title';
const G={
  time:0,difficulty:.8,
  // Wave
  wave:0,waveKills:0,waveQuota:0,waveState:'spawning',wavePhaseIdx:-1,
  bossEntity:null,
  // XP
  xp:0,level:1,xpToNext:160,levelUpQueue:0,
  // Kill tracking
  totalKills:0,
  // Frozen (time freeze power-up)
  frozen:false,freezeTimer:0,
  // Phase mutation flags
  bannerTimer:0,bannerText:'',bannerColor:'#fff',
  gravity:0,windX:0,windY:0,
  pulseTimer:0,pulseSpeed:0,
  reversed:false,reverseTimer:0,reverseCD:0,
  pierce:false,echo:false,bounce:false,mirror:false,fragile:false,lucky:false,
  // Weapons & passives
  weapons:[],passives:{},
  // Visual
  killFlash:0,waveBannerTimer:0,waveBannerText:'',waveBannerSub:'',waveModTimer:0,waveModText:'',
  _bossLaserHitCD:0,_bossModQueue:[],_bossSpawnPending:false,gameOverFade:0,
};
const XP_REQ_SCALE=.64;
const PASSIVE_EFFECTS={
  speed:[['moveSpeed','mul',[1,1.15,1.30,1.40]],['dodgeChance','set',[0,0,0,.08]]],
  regen:[['regenInterval','set',[999,14,8,8]]],
  cooldown:[['cdReduction','set',[0,.12,.20,.25]]],
  damage:[['dmgMult','mul',[1,1.3,1.5]]],
};
function applyStat(stat,mode,val){
  if(val===undefined)return;
  if(mode==='mul')stats[stat]*=val;
  else if(mode==='mul1')stats[stat]*=(1+val);
  else if(mode==='add')stats[stat]+=val;
  else if(mode==='add_cap')stats[stat]=min(.5,stats[stat]+val);
  else stats[stat]=val;
}

// Player stats (computed from base + passives)
const stats={moveSpeed:240,critChance:0,critMult:2,xpMult:1,cdReduction:0,regenTimer:0,regenInterval:999,dodgeChance:0,dmgMult:1};
function recomputeStats(){
  stats.moveSpeed=CFG.playerSpeed;
  stats.critChance=0;stats.critMult=2;stats.xpMult=1;stats.cdReduction=0;
  stats.regenInterval=999;stats.dodgeChance=0;stats.dmgMult=1;
  const p=G.passives;
  for(const key in PASSIVE_EFFECTS){
    const lv=p[key]|0;if(!lv)continue;
    const effects=PASSIVE_EFFECTS[key];
    for(let i=0;i<effects.length;i++){
      const ef=effects[i],vals=ef[2];
      applyStat(ef[0],ef[1],vals[min(lv,vals.length-1)]);
    }
  }
  const sl=p._speedLoop|0,dl=p._damageLoop|0;
  if(sl)stats.moveSpeed*=1+sl*.15;
  if(dl)stats.dmgMult*=1+dl*.3;
}

// == SHAKE + SLOWMO ==
let shakeX=0,shakeY=0,shakeI=0,slowTimer=0,slowScale=1;
function addShake(i){shakeI=max(shakeI,i)}
function updateShake(){if(shakeI>0.2){shakeX=(Math.random()-.5)*shakeI*2;shakeY=(Math.random()-.5)*shakeI*2;shakeI*=.87}else shakeX=shakeY=shakeI=0}
function trigSlowMo(d,s){slowTimer=d;slowScale=s}

// == DRAW HELPERS ==
function glowCircle(x,y,r,c,n){n=n||3;ctx.save();for(let i=n;i>0;i--){ctx.beginPath();ctx.arc(x,y,r+i*2.5,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=i*2;ctx.globalAlpha=.07;ctx.stroke()}ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowDot(x,y,r,c){ctx.save();ctx.beginPath();ctx.arc(x,y,r+4,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.12;ctx.fill();ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.fillStyle=c;ctx.globalAlpha=.9;ctx.fill();ctx.restore()}
function glowPoly(pts,c,cl,n){cl=cl!==false;n=n||3;function p(){ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);if(cl)ctx.closePath()}ctx.save();for(let i=n;i>0;i--){p();ctx.strokeStyle=c;ctx.lineWidth=i*2.5;ctx.globalAlpha=.07;ctx.stroke()}p();ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function glowLine(x1,y1,x2,y2,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=(w||1.5)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.strokeStyle=c;ctx.lineWidth=w||1.5;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function triPts(x,y,r,a){const p=[];for(let i=0;i<3;i++){const t=a+TAU/3*i-PI/2;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function sqPts(x,y,r,a){const p=[];for(let i=0;i<4;i++){const t=a+TAU/4*i+PI/4;p.push({x:x+cos(t)*r,y:y+sin(t)*r})}return p}
function drawText(t,x,y,sz,c,al,bl){ctx.save();ctx.font='bold '+sz+'px monospace';ctx.textAlign=al||'left';ctx.textBaseline=bl||'top';ctx.shadowColor=c;ctx.shadowBlur=10;ctx.fillStyle=c;ctx.globalAlpha=.5;ctx.fillText(t,x,y);ctx.shadowBlur=0;ctx.globalAlpha=1;ctx.fillText(t,x,y);ctx.restore()}
function drawGlowArc(cx,cy,r,startA,endA,c,w){ctx.save();for(let i=3;i>0;i--){ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=(w||2)+i*2;ctx.globalAlpha=.06;ctx.stroke()}ctx.beginPath();ctx.arc(cx,cy,r,startA,endA);ctx.strokeStyle=c;ctx.lineWidth=w||2;ctx.globalAlpha=1;ctx.stroke();ctx.restore()}
function strokeRing(x,y,r,c,w,a){ctx.beginPath();ctx.arc(x,y,r,0,TAU);ctx.strokeStyle=c;ctx.lineWidth=w||1;if(a!==undefined)ctx.globalAlpha=a;ctx.stroke()}
function drawPanel(x,y,w,h,f,s,sw,a){ctx.save();if(a!==undefined)ctx.globalAlpha=a;if(f){ctx.fillStyle=f;ctx.fillRect(x,y,w,h)}if(s){ctx.strokeStyle=s;ctx.lineWidth=sw||1;ctx.strokeRect(x,y,w,h)}ctx.restore()}

// == ENTITY POOL ==
function createPool(sz,mk){const p=[];for(let i=0;i<sz;i++){const e=mk();e.active=false;p.push(e)}
p.spawn=function(fn){for(let i=0;i<p.length;i++)if(!p[i].active){p[i].active=true;fn(p[i]);return p[i]}let oi=0,ot=1/0;for(let i=0;i<p.length;i++)if(p[i].spawnTime<ot){ot=p[i].spawnTime;oi=i}p[oi].active=true;fn(p[oi]);return p[oi]};
p.each=function(fn){for(let i=0;i<p.length;i++)if(p[i].active)fn(p[i])};
p.count=function(){let c=0;for(let i=0;i<p.length;i++)if(p[i].active)c++;return c};
p.clear=function(){for(let i=0;i<p.length;i++)p[i].active=false};return p}
function mkBullet(){return{active:false,x:0,y:0,vx:0,vy:0,r:4,life:0,maxLife:3,type:'normal',color:'#f44',spawnTime:0,damage:1,curve:0,pulseAmp:0,pulseFreq:0,split:false,echoed:false,echoTimer:0,baseSpeed:0,pierce:0,src:null,loopAmp:0,loopFreq:0,loopBaseAng:0,bossHomingTurn:0,bossHomingStop:0,_bounced:false}}
function mkParticle(){return{active:false,x:0,y:0,vx:0,vy:0,life:0,maxLife:.4,color:'#fff',r:2,spawnTime:0}}
function mkEnemy(){return{active:false,x:0,y:0,vx:0,vy:0,r:14,hp:2,maxHp:2,shape:'circle',color:'#f44',moveType:'drifter',firePattern:'single',fireTimer:0,fireCD:2,tier:'small',angle:0,hitFlash:0,spiralAngle:0,moveParams:{},fireParams:{},spawnTime:0,
  cc:{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0},
  isBoss:false,bossAI:null,shieldHP:0}}
const enemyBullets=createPool(CFG.maxEBullets,mkBullet);
const playerBullets=createPool(CFG.maxPBullets,mkBullet);
const particles=createPool(CFG.maxParticles,mkParticle);
const enemies=createPool(CFG.maxEnemies,mkEnemy);

// == DAMAGE NUMBERS ==
const dmgNums=[];
function spawnDmgNum(x,y,val,crit){if(dmgNums.length>200)return;dmgNums.push({x:x+(Math.random()-.5)*20,y,vy:-60-Math.random()*30,text:crit?val+'!':''+val,color:crit?'#ff0':'#fff',life:.6,maxLife:.6,scale:crit?1.4:1})}
function updateDmgNums(dt){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.y+=d.vy*dt;d.vy+=100*dt;d.life-=dt;if(d.life<=0)dmgNums.splice(i,1)}}
function drawDmgNums(){for(const d of dmgNums){const a=d.life/d.maxLife;ctx.save();ctx.globalAlpha=a;ctx.font='bold '+(12*d.scale)+'px monospace';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=d.color;ctx.shadowColor=d.color;ctx.shadowBlur=6;ctx.fillText(d.text,d.x,d.y);ctx.restore()}}

// == PARTICLES ==
function spawnParticle(x,y,vx,vy,c,l,r){particles.spawn(p=>{p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.color=c;p.life=l||.4;p.maxLife=l||.4;p.r=r||2;p.spawnTime=G.time})}
function burstParticles(x,y,c,n,s){for(let i=0;i<n;i++){const a=Math.random()*TAU,sp=s*(.3+Math.random()*.7);spawnParticle(x,y,cos(a)*sp,sin(a)*sp,c,.2+Math.random()*.3,1+Math.random()*2)}}
function updateParticles(dt){particles.each(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vx*=.97;p.vy*=.97;p.life-=dt;if(p.life<=0)p.active=false})}
function drawParticles(){particles.each(p=>{const a=clamp(p.life/p.maxLife,0,1);ctx.save();ctx.globalAlpha=a*.8;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,TAU);ctx.fillStyle=p.color;ctx.fill();ctx.restore()})}

// == BOSS CHECK ==
function hasAliveBoss(){
  let alive=false;
  enemies.each(e=>{if(e.isBoss)alive=true});
  return alive;
}

// == SWORD AFTERSHOCKS ==
const swordAftershocks=[];
const MAX_SWORD_AFTERSHOCKS=18;
function spawnSwordAftershock(x1,y1,x2,y2,width,dmg,life){
  if(swordAftershocks.length>=MAX_SWORD_AFTERSHOCKS)return;
  const l=max(.4,life||1),w=max(6,width||40),d=max(1,dmg||1);
  swordAftershocks.push({x1,y1,x2,y2,width:w,dmg:d,life:l,maxLife:l,tickT:0});
}
function updateSwordAftershocks(dt){
  for(let i=swordAftershocks.length-1;i>=0;i--){
    const s=swordAftershocks[i];
    s.life-=dt;
    if(s.life<=0){swordAftershocks.splice(i,1);continue}
    s.tickT-=dt;
    if(s.tickT>0)continue;
    s.tickT=.06;
    const mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5,a=clamp(s.life/s.maxLife,0,1);
    enemies.each(e=>{
      if(!e.active)return;
      if(pointSegDist(e.x,e.y,s.x1,s.y1,s.x2,s.y2)<=s.width*.45+e.r){
        dealDamage(e,s.dmg*a*.6,'sword_aftershock');
      }
    });
    burstParticles(mx,my,'#f6f',2,80);
  }
}
function drawSwordAftershocks(){
  for(const s of swordAftershocks){
    const a=clamp(s.life/s.maxLife,0,1),w=s.width*(.55+.6*a);
    const dx=s.x2-s.x1,dy=s.y2-s.y1,d=max(1,sqrt(dx*dx+dy*dy));
    const nx=-dy/d,ny=dx/d,mx=(s.x1+s.x2)*.5,my=(s.y1+s.y2)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.1+.22*a)+')');
    grad.addColorStop(1,'rgba(255,120,255,0)');
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.quadraticCurveTo(mx+nx*w*.85,my+ny*w*.85,s.x2,s.y2);
    ctx.quadraticCurveTo(mx-nx*w*.85,my-ny*w*.85,s.x1,s.y1);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.shadowColor='#f0f';ctx.shadowBlur=20;ctx.fill();
    const core=ctx.createLinearGradient(s.x1,s.y1,s.x2,s.y2);
    core.addColorStop(0,'rgba(255,255,255,0)');
    core.addColorStop(.5,'rgba(255,255,255,'+(.18+.2*a)+')');
    core.addColorStop(1,'rgba(255,255,255,0)');
    ctx.beginPath();ctx.moveTo(s.x1,s.y1);ctx.lineTo(s.x2,s.y2);
    ctx.strokeStyle=core;ctx.lineWidth=max(1.8,w*.18);ctx.lineCap='round';ctx.shadowBlur=10;ctx.stroke();
    const n=5+((G.time*15+s.x1+s.y1)|0)%4;
    for(let i=0;i<n;i++){
      const t=(i+.5)/n+sin(G.time*9+i*1.7)*.03;
      const px=lerp(s.x1,s.x2,clamp(t,0,1)),py=lerp(s.y1,s.y2,clamp(t,0,1));
      const off=sin(G.time*14+i*2.2)*(w*.22);
      const sx=px+nx*off,sy=py+ny*off;
      ctx.beginPath();ctx.arc(sx,sy,1.2+a*2.2,0,TAU);
      ctx.fillStyle='#f8f';ctx.globalAlpha=.12+.22*a;ctx.fill();
      ctx.beginPath();ctx.arc(sx+nx*1.5,sy+ny*1.5,.9+a*1.4,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.08+.18*a;ctx.fill();
    }
    ctx.restore();
  }
}

// == SWORD BOSS SLASH PROJECTILES ==
const swordBossSlashes=[];
const MAX_SWORD_BOSS_SLASHES=36;
function spawnSwordBossSlash(a,w){
  if(swordBossSlashes.length>=MAX_SWORD_BOSS_SLASHES)return;
  const len=(160+32*(w.lv.a||0))*(1+[0,.15,.3][w.lv.c||0]);
  const width=34+8*(w.lv.b||0);
  const dmg=(8+2*(w.lv.a||0)+[0,2,4][w.lv.c||0])*2;
  const x=player.x+cos(a)*26,y=player.y+sin(a)*26;
  const spd=820;
  swordBossSlashes.push({x,y,vx:cos(a)*spd,vy:sin(a)*spd,a,life:.55,maxLife:.55,len,width,dmg,hitSet:new Set()});
  burstParticles(x,y,'#f6f',7,130);
}
function updateSwordBossSlashes(dt){
  for(let i=swordBossSlashes.length-1;i>=0;i--){
    const s=swordBossSlashes[i];
    s.life-=dt;
    if(s.life<=0){swordBossSlashes.splice(i,1);continue}
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    if(dist(player.x,player.y,s.x,s.y)>max(W,H)*1.35){swordBossSlashes.splice(i,1);continue}
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    enemies.each(e=>{
      if(!e.active||!e.isBoss||s.hitSet.has(e))return;
      if(pointSegDist(e.x,e.y,tx,ty,hx,hy)<=e.r+s.width*.45){
        s.hitSet.add(e);
        dealDamage(e,s.dmg,'sword_boss_slash');
        burstParticles(e.x,e.y,'#f8f',9,170);
      }
    });
  }
}
function drawSwordBossSlashes(){
  for(const s of swordBossSlashes){
    const a=clamp(s.life/s.maxLife,0,1);
    const nx=cos(s.a+PI/2),ny=sin(s.a+PI/2);
    const tx=s.x-cos(s.a)*s.len*.25,ty=s.y-sin(s.a)*s.len*.25;
    const hx=s.x+cos(s.a)*s.len*.75,hy=s.y+sin(s.a)*s.len*.75;
    const w=s.width*(.8+.35*a);
    const mx=(tx+hx)*.5,my=(ty+hy)*.5;
    ctx.save();
    const grad=ctx.createLinearGradient(tx,ty,hx,hy);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.45,'rgba(255,120,255,'+(.2+.22*a)+')');
    grad.addColorStop(1,'rgba(255,255,255,'+(.1+.22*a)+')');
    ctx.beginPath();
    ctx.moveTo(tx,ty);
    ctx.quadraticCurveTo(mx+nx*w*.75,my+ny*w*.75,hx,hy);
    ctx.quadraticCurveTo(mx-nx*w*.75,my-ny*w*.75,tx,ty);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=.95;ctx.shadowColor='#f6f';ctx.shadowBlur=14;ctx.fill();
    ctx.restore();
  }
}

// == BOW BEAMS ==
const bowBeams=[];
const MAX_BOW_BEAMS=18;
function drawBeamBody(x1,y1,x2,y2,w,a,col,hot){
  const outer=w*(hot?(1+.35*a):(.8+.4*a));
  const mid=max(hot?4:3,w*(hot?.45:.3)*(hot?(.85+.25*a):(.8+.3*a)));
  const core=max(hot?2.5:2,w*(hot?.2:.12));
  ctx.save();ctx.lineCap='round';
  const g1=ctx.createLinearGradient(x1,y1,x2,y2);
  g1.addColorStop(0,'rgba(255,255,255,0)');
  g1.addColorStop(.08,hot?('rgba(255,216,74,'+(.12+.14*a)+')'):('rgba(255,216,74,'+(.12+.14*a)+')'));
  g1.addColorStop(1,hot?('rgba(255,120,120,'+(.1+.22*a)+')'):('rgba(255,216,74,'+(.08+.2*a)+')'));
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g1;ctx.lineWidth=outer;ctx.globalAlpha=1;ctx.shadowColor=col;ctx.shadowBlur=hot?18:20;ctx.stroke();
  const g2=ctx.createLinearGradient(x1,y1,x2,y2);
  g2.addColorStop(0,'rgba(255,255,255,0)');
  g2.addColorStop(hot?.1:.08,'rgba(255,255,255,'+(hot?(.15+.2*a):(.16+.2*a))+')');
  g2.addColorStop(1,hot?('rgba(255,180,180,'+(.2+.38*a)+')'):('rgba(255,216,74,'+(.2+.4*a)+')'));
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g2;ctx.lineWidth=mid;ctx.shadowBlur=hot?10:12;ctx.stroke();
  const g3=ctx.createLinearGradient(x1,y1,x2,y2);
  g3.addColorStop(0,'rgba(255,255,255,0)');
  g3.addColorStop(hot?.12:.1,'rgba(255,255,255,'+(hot?(.25+.25*a):(.25+.25*a))+')');
  g3.addColorStop(1,'rgba(255,255,255,'+(hot?(.3+.4*a):(.35+.45*a))+')');
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
  ctx.strokeStyle=g3;ctx.lineWidth=core;ctx.shadowBlur=hot?6:8;ctx.stroke();
  ctx.restore();
}
function fireBowBeam(w,pct,angle,lateralOffset,dmgScale,widthScale,lenScale,color,bossOnly){
  if(bowBeams.length>=MAX_BOW_BEAMS)return;
  const ls=lateralOffset||0,ds=dmgScale||1,ws=widthScale||1,lens=lenScale||1;
  const nx=-sin(angle),ny=cos(angle);
  const ox=player.x+cos(angle)*16+nx*ls;
  const oy=player.y+sin(angle)*16+ny*ls;
  // Fixed long range so beam always extends past the visible screen.
  let length=max(W,H)*1.9*lens;
  let width=lerp(4,26,pct)*ws;
  let dmg=lerp(1.2,11,pct)*ds;
  const powerLv=clamp(w.lv.a|0,0,2);
  length*=1+powerLv*.08;
  width*=1+powerLv*.08;
  dmg*=1+powerLv*.07;
  const ex=ox+cos(angle)*length,ey=oy+sin(angle)*length;
  enemies.each(e=>{
    if(!e.active||(bossOnly&&!e.isBoss))return;
    if(pointSegDist(e.x,e.y,ox,oy,ex,ey)<=width*.5+e.r){
      dealDamage(e,dmg,'bow_beam');
      if(w.id==='bow'){
        const burnLv=clamp(w.lv.c|0,0,2);
        if(burnLv>0){
          e.cc.bleedDmg=max(e.cc.bleedDmg,[0,1.2,2.2][burnLv]);
          e.cc.bleedT=max(e.cc.bleedT,[0,1.5,2.5][burnLv]);
        }
      }
    }
  });
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(pointSegDist(b.x,b.y,ox,oy,ex,ey)<=width*.55+b.r){
      b.active=false;
      burstParticles(b.x,b.y,'#ff0',2,70);
    }
  });
  for(let i=0;i<6;i++){
    const t=.15+i*.15;
    burstParticles(lerp(ox,ex,t),lerp(oy,ey,t),'#ff0',2,60);
  }
  bowBeams.push({x1:ox,y1:oy,x2:ex,y2:ey,width,length,life:.12+pct*.1,maxLife:.12+pct*.1,color:color||'#ff0',phase:rAngle(),hot:false});
}
function updateBowBeams(dt){
  for(let i=bowBeams.length-1;i>=0;i--){
    bowBeams[i].life-=dt;
    if(bowBeams[i].life<=0)bowBeams.splice(i,1);
  }
}
function drawBowBeams(){
  for(const b of bowBeams){
    const a=clamp(b.life/b.maxLife,0,1);
    const pulse=.9+sin((G.time*40)+b.phase)*.1;
    drawBeamBody(b.x1,b.y1,b.x2,b.y2,b.width*pulse,a,b.color,false);
    ctx.save();
    for(let i=0;i<5;i++){
      const t=(i+.5)/5+sin(G.time*10+i+b.phase)*.015;
      const px=lerp(b.x1,b.x2,clamp(t,0,1)),py=lerp(b.y1,b.y2,clamp(t,0,1));
      ctx.beginPath();ctx.arc(px,py,2+a*3,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=.1+.25*a;ctx.fill();
    }
    ctx.restore();
  }
}

// == BOSS LASERS ==
const bossLasers=[];
function spawnBossLaser(opts){
  bossLasers.push({
    owner:opts.owner||null,x1:opts.x1||0,y1:opts.y1||0,angle:opts.angle||0,length:opts.length||800,width:opts.width||20,
    rotSpeed:opts.rotSpeed||0,life:opts.life||.9,maxLife:opts.life||.9,color:hostileColor(opts.color||'#f66'),
    offsetX:opts.offsetX||0,offsetY:opts.offsetY||0,
    warn:opts.warn||0,maxWarn:opts.warn||0,warnColor:opts.warnColor||'#ffcc66',
  });
}
function updateBossLasers(dt){
  G._bossLaserHitCD=max(0,(G._bossLaserHitCD||0)-dt);
  for(let i=bossLasers.length-1;i>=0;i--){
    const l=bossLasers[i];
    if(!l.owner||!l.owner.active){bossLasers.splice(i,1);continue}
    l.angle+=l.rotSpeed*dt;
    l.x1=l.owner.x+l.offsetX;
    l.y1=l.owner.y+l.offsetY;
    if(l.warn>0){l.warn=max(0,l.warn-dt);continue}
    l.life-=dt;
    if(l.life<=0){bossLasers.splice(i,1);continue}
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(player.alive&&player.invuln<=0&&G._bossLaserHitCD<=0){
      if(pointSegDist(player.x,player.y,l.x1,l.y1,x2,y2)<=l.width*.45+player.r){
        G._bossLaserHitCD=.12;
        damagePlayer();
      }
    }
  }
}
function drawBossLasers(){
  for(const l of bossLasers){
    const a=clamp(l.life/l.maxLife,0,1);
    const x2=l.x1+cos(l.angle)*l.length,y2=l.y1+sin(l.angle)*l.length;
    if(l.warn>0){
      const wa=clamp(l.warn/max(0.0001,l.maxWarn),0,1);
      const pulse=.45+.45*abs(sin(G.time*18));
      ctx.save();ctx.lineCap='round';
      ctx.setLineDash([12,10]);
      ctx.beginPath();ctx.moveTo(l.x1,l.y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=l.warnColor;ctx.lineWidth=max(2,l.width*.22);ctx.globalAlpha=(.2+.55*(1-wa))*pulse;
      ctx.shadowColor=l.warnColor;ctx.shadowBlur=10;ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      continue;
    }
    drawBeamBody(l.x1,l.y1,x2,y2,l.width,a,l.color,true);
  }
}

// == GROUND ==
function drawGround(){
  const gs=100,ms=50,l=cam.x-CX-gs,t=cam.y-CY-gs,r=cam.x+CX+gs,bt=cam.y+CY+gs;
  const sx=floor(l/gs)*gs,sy=floor(t/gs)*gs,mx=floor(l/ms)*ms,my=floor(t/ms)*ms;
  ctx.save();
  ctx.strokeStyle='#2a5f82';ctx.lineWidth=.9;ctx.globalAlpha=.62;ctx.beginPath();
  for(let x=sx;x<=r;x+=gs){ctx.moveTo(x,t);ctx.lineTo(x,bt)}
  for(let y=sy;y<=bt;y+=gs){ctx.moveTo(l,y);ctx.lineTo(r,y)}
  ctx.stroke();
  ctx.strokeStyle='#18344a';ctx.lineWidth=.6;ctx.globalAlpha=.38;ctx.beginPath();
  for(let x=mx;x<=r;x+=ms){ctx.moveTo(x,t);ctx.lineTo(x,bt)}
  for(let y=my;y<=bt;y+=ms){ctx.moveTo(l,y);ctx.lineTo(r,y)}
  ctx.stroke();
  ctx.fillStyle='#58b7ff';ctx.globalAlpha=.22;
  for(let x=mx;x<=r;x+=ms)for(let y=my;y<=bt;y+=ms)ctx.fillRect(x-1.5,y-1.5,3,3);
  ctx.restore();
}

// == OBSTACLES ==
const CHUNK=CFG.chunkSize,obsCache=new Map();
const MAP_SALT=(Math.random()*0xffffffff)>>>0;
function chunkHash(cx,cy){let h=((cx*374761393+cy*668265263)^MAP_SALT)>>>0;h=Math.imul(h^(h>>>13),1274126177);return(h^(h>>>16))>>>0}
function chunkKey(cx,cy){return (cx+1048576)*2097152+(cy+1048576)}
function getObstacles(cx,cy){
  const k=chunkKey(cx,cy);
  if(obsCache.has(k))return obsCache.get(k);
  let h=chunkHash(cx,cy);
  const n=()=>{h=(h*1103515245+12345)&0x7fffffff;return h/0x7fffffff};
  const c=floor(n()*5),obs=[]; // light density for open movement
  const pad=12;
  const overlaps=(cand)=>{
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(cand.type==='pillar'&&o.type==='pillar'){
        if(dist(cand.x,cand.y,o.x,o.y)<cand.r+o.r+pad)return true;
      }else{
        const a=cand.type==='pillar'?{x:cand.x-cand.r,y:cand.y-cand.r,w:cand.r*2,h:cand.r*2}:cand;
        const b=o.type==='pillar'?{x:o.x-o.r,y:o.y-o.r,w:o.r*2,h:o.r*2}:o;
        if(a.x<a.x+a.w&&b.x<b.x+b.w){
          const ox=a.x<b.x+b.w&&a.x+a.w>b.x,oy=a.y<b.y+b.h&&a.y+a.h>b.y;
          if(ox&&oy){
            if(!(a.x+a.w+pad<b.x||a.x>b.x+b.w+pad||a.y+a.h+pad<b.y||a.y>b.y+b.h+pad))return true;
          }
        }
      }
    }
    return false;
  };
  for(let i=0;i<c;i++){
    let placed=false;
    for(let t=0;t<10;t++){
      const ox=cx*CHUNK+n()*(CHUNK-120)+60,oy=cy*CHUNK+n()*(CHUNK-120)+60;
      const cand=n()<.5?{type:'pillar',x:ox,y:oy,r:18+n()*32}:{type:'wall',x:ox-(50+n()*110)/2,y:oy-(18+n()*45)/2,w:50+n()*110,h:18+n()*45};
      if(!overlaps(cand)){obs.push(cand);placed=true;break}
    }
    if(!placed)continue;
  }
  obsCache.set(k,obs);
  return obs;
}
function pushCircle(e,ox,oy,or){const dx=e.x-ox,dy=e.y-oy,d=sqrt(dx*dx+dy*dy),m=e.r+or;if(d<m&&d>.01){e.x=ox+dx/d*m;e.y=oy+dy/d*m}}
function pushRect(e,rx,ry,rw,rh){const nx=clamp(e.x,rx,rx+rw),ny=clamp(e.y,ry,ry+rh),dx=e.x-nx,dy=e.y-ny,d=sqrt(dx*dx+dy*dy);if(d<e.r&&d>.01){e.x=nx+dx/d*e.r;e.y=ny+dy/d*e.r}else if(d<=.01&&e.x>=rx&&e.x<=rx+rw&&e.y>=ry&&e.y<=ry+rh){const ds=[e.x-rx,rx+rw-e.x,e.y-ry,ry+rh-e.y],mi=ds.indexOf(min(...ds));if(mi===0)e.x=rx-e.r;else if(mi===1)e.x=rx+rw+e.r;else if(mi===2)e.y=ry-e.r;else e.y=ry+rh+e.r}}
function collideObs(e){const cx=floor(e.x/CHUNK),cy=floor(e.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++)o[i].type==='pillar'?pushCircle(e,o[i].x,o[i].y,o[i].r):pushRect(e,o[i].x,o[i].y,o[i].w,o[i].h)}}
function bulletHitsObs(b){const cx=floor(b.x/CHUNK),cy=floor(b.y/CHUNK);for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){const o=getObstacles(cx+dx,cy+dy);for(let i=0;i<o.length;i++){const ob=o[i];if(ob.type==='pillar'){if(dist(b.x,b.y,ob.x,ob.y)<b.r+ob.r)return ob}else{const nx=clamp(b.x,ob.x,ob.x+ob.w),ny=clamp(b.y,ob.y,ob.y+ob.h);if(dist(b.x,b.y,nx,ny)<b.r)return ob}}}return null}
function drawObstacles(){
  const mn=floor((cam.x-CX)/CHUNK)-1,mx=floor((cam.x+CX)/CHUNK)+1,mny=floor((cam.y-CY)/CHUNK)-1,mxy=floor((cam.y+CY)/CHUNK)+1;
  for(let cx=mn;cx<=mx;cx++)for(let cy=mny;cy<=mxy;cy++){
    const obs=getObstacles(cx,cy);
    for(let i=0;i<obs.length;i++){
      const o=obs[i];
      if(o.type==='pillar'){
        ctx.save();ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,TAU);ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fill();ctx.restore();
        glowCircle(o.x,o.y,o.r,'#1a4a6a',2);
      }else{
        ctx.save();ctx.fillStyle='#0a1520';ctx.globalAlpha=.6;ctx.fillRect(o.x,o.y,o.w,o.h);ctx.restore();
        glowPoly([{x:o.x,y:o.y},{x:o.x+o.w,y:o.y},{x:o.x+o.w,y:o.y+o.h},{x:o.x,y:o.y+o.h}],'#1a4a6a',true,2);
      }
    }
  }
}

// == MENU BACKGROUND ==
const MENU_COLORS=['#f44','#f84','#fd4','#f6f','#9f6','#f95'];
const menuBg={t:0,enemies:[],bullets:[]};
function spawnMenuEnemy(e){
  e=e||{};
  e.x=rr(0,W);e.y=rr(0,H);
  const a=rAngle(),s=rr(35,95);
  e.vx=cos(a)*s;e.vy=sin(a)*s;
  e.r=rr(8,16);e.shape=rPick(['circle','triangle']);
  e.color=rPick(MENU_COLORS);e.fire=rr(.2,1.1);
  return e;
}
function menuShoot(e){
  const a=atan2(CY-e.y,CX-e.x)+rr(-.9,.9),s=rr(120,220);
  menuBg.bullets.push({x:e.x,y:e.y,vx:cos(a)*s,vy:sin(a)*s,life:rr(1.2,2.6),r:2.4,color:e.color});
  if(menuBg.bullets.length>120)menuBg.bullets.splice(0,menuBg.bullets.length-120);
}
function updateMenuBg(dt){
  if(!menuBg.enemies.length)for(let i=0;i<10;i++)menuBg.enemies.push(spawnMenuEnemy({}));
  menuBg.t+=dt;
  for(const e of menuBg.enemies){
    e.fire-=dt;
    e.x+=e.vx*dt;e.y+=e.vy*dt;
    if(e.x<-20||e.x>W+20||e.y<-20||e.y>H+20)spawnMenuEnemy(e);
    if(e.fire<=0){menuShoot(e);e.fire=rr(.25,1.2)}
  }
  for(let i=menuBg.bullets.length-1;i>=0;i--){
    const b=menuBg.bullets[i];
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt;
    if(b.life<=0||b.x<-30||b.y<-30||b.x>W+30||b.y>H+30)menuBg.bullets.splice(i,1);
  }
}
function drawMenuBg(dt,shade){
  updateMenuBg(dt||0);
  ctx.fillStyle='#02060b';ctx.fillRect(0,0,W,H);
  const gs=100,ms=50,ox=(menuBg.t*30)%gs,oy=(menuBg.t*16)%gs,mox=(menuBg.t*46)%ms,moy=(menuBg.t*26)%ms;
  ctx.save();
  ctx.strokeStyle='#2a5f82';ctx.lineWidth=.9;ctx.globalAlpha=.5;ctx.beginPath();
  for(let x=-ox;x<=W+gs;x+=gs){ctx.moveTo(x,0);ctx.lineTo(x,H)}
  for(let y=-oy;y<=H+gs;y+=gs){ctx.moveTo(0,y);ctx.lineTo(W,y)}
  ctx.stroke();
  ctx.strokeStyle='#18344a';ctx.lineWidth=.6;ctx.globalAlpha=.35;ctx.beginPath();
  for(let x=-mox;x<=W+ms;x+=ms){ctx.moveTo(x,0);ctx.lineTo(x,H)}
  for(let y=-moy;y<=H+ms;y+=ms){ctx.moveTo(0,y);ctx.lineTo(W,y)}
  ctx.stroke();
  ctx.fillStyle='#58b7ff';ctx.globalAlpha=.14;
  for(let x=-mox;x<=W+ms;x+=ms)for(let y=-moy;y<=H+ms;y+=ms)ctx.fillRect(x-1,y-1,2,2);
  ctx.restore();
  for(const b of menuBg.bullets){ctx.save();ctx.globalAlpha=.45*clamp(b.life/2,0,1);glowDot(b.x,b.y,b.r,b.color);ctx.restore()}
  for(const e of menuBg.enemies){
    ctx.save();ctx.globalAlpha=.55;
    if(e.shape==='circle')glowCircle(e.x,e.y,e.r,e.color,3);
    else glowPoly(triPts(e.x,e.y,e.r,menuBg.t*1.2),e.color,true,3);
    ctx.restore();
  }
  if(shade){ctx.fillStyle='rgba(0,0,0,'+shade+')';ctx.fillRect(0,0,W,H)}
}

// == PLAYER ==
const player={x:0,y:0,r:CFG.playerR,hp:CFG.playerHP,maxHp:CFG.playerHP,invuln:0,angle:0,hitFlash:0,alive:true,swordIFrame:0};
function resetPlayer(){player.x=0;player.y=0;player.hp=CFG.playerHP;player.maxHp=CFG.playerHP;player.invuln=0;player.hitFlash=0;player.alive=true;player.angle=0;player.swordIFrame=0}
function updatePlayer(dt){
  if(!player.alive)return;
  // Check if sword is lunging — sword handles player position directly
  const swordW=G.weapons.find(w=>w.id==='sword');
  if(swordW&&swordW.lungeTimer>0){
    player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
    player.swordIFrame=max(0,player.swordIFrame-dt);
    const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
    if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
    collideObs(player);
    if(G.passives.regen){stats.regenTimer-=dt;if(stats.regenTimer<=0){stats.regenTimer=stats.regenInterval;if(player.hp<player.maxHp)player.hp++}}
    return;
  }
  const mv=getMoveDir();let mdx=mv.x,mdy=mv.y;
  if(G.reversed){mdx=-mdx;mdy=-mdy}
  const sm=1;
  player.x+=mdx*stats.moveSpeed*sm*dt;player.y+=mdy*stats.moveSpeed*sm*dt;
  if(mdx!==0||mdy!==0){player.x+=G.windX*dt*.3;player.y+=G.windY*dt*.3}
  collideObs(player);
  const wm=worldMouse(),adx=wm.x-player.x,ady=wm.y-player.y;
  if(adx*adx+ady*ady>4)player.angle=atan2(ady,adx);
  player.invuln=max(0,player.invuln-dt);player.hitFlash=max(0,player.hitFlash-dt*5);
  player.swordIFrame=max(0,player.swordIFrame-dt);
  // Regen
  stats.regenTimer=(stats.regenTimer||0)+dt;
  if(stats.regenTimer>=stats.regenInterval&&player.hp<player.maxHp){stats.regenTimer=0;player.hp=min(player.hp+1,player.maxHp)}
}
function drawPlayer(){
  if(!player.alive)return;
  if(player.invuln>0&&player.swordIFrame<=0&&(G.time*20|0)%2===0)return;
  const col=player.hitFlash>0?'#fff':'#0ff';
  glowPoly(triPts(player.x,player.y,player.r,player.angle+PI/2),col,true,4);
  ctx.save();ctx.beginPath();ctx.arc(player.x,player.y,player.r*.4,0,TAU);ctx.fillStyle=col;ctx.globalAlpha=.15;ctx.fill();ctx.restore();
  // Distinct sword i-frame look: magenta-cyan aura instead of normal flicker.
  if(player.swordIFrame>0){
    const ia=clamp(player.swordIFrame/.25,0,1);
    const pr=player.r+8+sin(G.time*18)*2;
    ctx.save();
    ctx.beginPath();ctx.arc(player.x,player.y,pr,0,TAU);
    ctx.strokeStyle='#f6f';ctx.lineWidth=2.2;ctx.globalAlpha=.2+.35*ia;ctx.shadowColor='#f6f';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(player.x,player.y,pr-4,0,TAU);
    ctx.strokeStyle='#8ff';ctx.lineWidth=1.2;ctx.globalAlpha=.15+.25*ia;ctx.shadowColor='#8ff';ctx.shadowBlur=6;ctx.stroke();
    // short directional ghost wisps
    for(let i=0;i<2;i++){
      const t=G.time*14+i*PI;
      const gx=player.x-cos(player.angle)*(8+i*5)+cos(t)*2;
      const gy=player.y-sin(player.angle)*(8+i*5)+sin(t)*2;
      const p=triPts(gx,gy,player.r*.65,player.angle+PI/2);
      ctx.beginPath();ctx.moveTo(p[0].x,p[0].y);ctx.lineTo(p[1].x,p[1].y);ctx.lineTo(p[2].x,p[2].y);ctx.closePath();
      ctx.fillStyle='#f6f';ctx.globalAlpha=.08+.12*ia;ctx.fill();
    }
    ctx.restore();
  }
}

// == PHASES ==
const PHASES=[
  {name:'GRAVITY',color:'#84f',desc:'Bullets strongly curve toward you',apply(){G.gravity=220},unapply(){G.gravity=0},tick(){}},
  {name:'DRIFT',color:'#4ff',desc:'Wind pushes everything',apply(){const a=rAngle();G.windX=cos(a)*80;G.windY=sin(a)*80},unapply(){G.windX=0;G.windY=0},tick(dt){const a=atan2(G.windY,G.windX)+dt*.3,s=sqrt(G.windX**2+G.windY**2);G.windX=cos(a)*s;G.windY=sin(a)*s}},
  {name:'PULSE',color:'#ff0',desc:'Periodic bullet speed bursts',apply(){G.pulseTimer=0;G.pulseSpeed=0},unapply(){G.pulseSpeed=0;G.pulseTimer=0},tick(dt){G.pulseTimer+=dt;if(G.pulseTimer>3){G.pulseTimer=0;G.pulseSpeed=200;addShake(5)}if(G.pulseSpeed>0)G.pulseSpeed=max(0,G.pulseSpeed-400*dt)}},
  {name:'ECHO',color:'#0af',desc:'Bullets spawn ghost copies',apply(){G.echo=true},unapply(){G.echo=false},tick(){}},
  {name:'REVERSE',color:'#f6c',desc:'Controls periodically invert',apply(){G.reversed=false;G.reverseTimer=1.8;G.reverseCD=0},unapply(){G.reversed=false;G.reverseTimer=0;G.reverseCD=0},tick(dt){G.reverseTimer-=dt;if(G.reverseTimer<=0){G.reversed=!G.reversed;G.reverseTimer=G.reversed?2.2:1.6}}},
  {name:'FREEZE',color:'#9cf',desc:'Short enemy time-freeze pulses',apply(){this._t=1.6;G.frozen=false;G.freezeTimer=0},unapply(){G.frozen=false;G.freezeTimer=0;this._t=0},tick(dt){this._t-=dt;if(this._t<=0&&!G.frozen){G.frozen=true;G.freezeTimer=.65;this._t=2.4;addShake(4)}}},
  {name:'PIERCE',color:'#8f8',desc:'Your projectiles pierce targets',apply(){G.pierce=true},unapply(){G.pierce=false},tick(){}},
  {name:'MIRROR',color:'#aff',desc:'Reflect enemy bullets near you',apply(){G.mirror=true},unapply(){G.mirror=false},tick(){}},
  {name:'BOUNCE',color:'#fa8',desc:'Enemy bullets ricochet off obstacles once',apply(){G.bounce=true},unapply(){G.bounce=false},tick(){}},
  {name:'FRAGILE',color:'#f88',desc:'Projectiles decay faster',apply(){G.fragile=true},unapply(){G.fragile=false},tick(){}},
  {name:'LUCKY',color:'#ff8',desc:'Bonus XP and extra crit chance',apply(){G.lucky=true},unapply(){G.lucky=false},tick(){}},
];
let currentPhase=null,lastPhaseIdx=-1;
function selectPhase(){let idx,a=0;do{idx=ri(0,PHASES.length-1);a++}while(idx===lastPhaseIdx&&a<10);lastPhaseIdx=idx;return idx}
function applyPhase(idx){if(currentPhase)currentPhase.unapply();G.wavePhaseIdx=idx;currentPhase=PHASES[idx];currentPhase.apply()}

// == ENEMY MOVEMENT ==
const EMOVE={
  drifter(e,dt){e.x+=e.vx*dt;e.y+=e.vy*dt;const d=dist(e.x,e.y,player.x,player.y);if(d>500){const a=atan2(player.y-e.y,player.x-e.x);e.vx+=cos(a)*40*dt;e.vy+=sin(a)*40*dt}const sp=sqrt(e.vx**2+e.vy**2);if(sp>100){e.vx*=100/sp;e.vy*=100/sp}},
  chaser(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||120;e.vx=lerp(e.vx,cos(a)*s,2*dt);e.vy=lerp(e.vy,sin(a)*s,2*dt);e.x+=e.vx*dt;e.y+=e.vy*dt},
  orbiter(e,dt){const or=e.moveParams.radius||150;e.moveParams.angle=(e.moveParams.angle||0)+(e.moveParams.speed||1.5)*dt;e.x=lerp(e.x,player.x+cos(e.moveParams.angle)*or,3*dt);e.y=lerp(e.y,player.y+sin(e.moveParams.angle)*or,3*dt)},
  dasher(e,dt){
    const mp=e.moveParams;
    if(!mp.state)mp.state='wait';
    if(mp.state==='wait'){
      mp.waitTime=(mp.waitTime||0)+dt;
      const a=atan2(player.y-e.y,player.x-e.x);
      e.x+=cos(a)*20*dt;e.y+=sin(a)*20*dt;
      if(mp.waitTime>1.5){
        const da=atan2(player.y-e.y,player.x-e.x),dd=clamp(dist(e.x,e.y,player.x,player.y)+36,120,260);
        mp.state='telegraph';
        mp.dashTx=e.x+cos(da)*dd;mp.dashTy=e.y+sin(da)*dd;
        mp.teleT=1;mp.teleMax=1;
        e._dashTele={t:1,maxT:1,tx:mp.dashTx,ty:mp.dashTy};
      }
    }else if(mp.state==='telegraph'){
      mp.teleT-=dt;
      e._dashInvuln=max(e._dashInvuln,.1);
      if(e._dashTele)e._dashTele.t=mp.teleT;
      if(mp.teleT<=0){
        mp.state='dashing';
        mp.dashT=.32;mp.dashMax=.32;
        mp.sx=e.x;mp.sy=e.y;mp.ex=mp.dashTx;mp.ey=mp.dashTy;
        e._dashTele=null;
      }
    }else{
      mp.dashT-=dt;
      const p=clamp(1-mp.dashT/mp.dashMax,0,1),ep=1-(1-p)*(1-p);
      e.x=lerp(mp.sx,mp.ex,ep);e.y=lerp(mp.sy,mp.ey,ep);
      e._dashInvuln=max(e._dashInvuln,.3);
      if(mp.dashT<=0){
        e.x=mp.ex;e.y=mp.ey;
        mp.state='wait';mp.waitTime=0;
      }
    }
  },
  sentry(e,dt){const a=atan2(player.y-e.y,player.x-e.x);e.x+=cos(a)*15*dt;e.y+=sin(a)*15*dt;e.angle+=1.5*dt},
  weaver(e,dt){const mp=e.moveParams;mp.t=(mp.t||0)+dt;const ba=atan2(player.y-e.y,player.x-e.x),s=mp.speed||100,f=mp.freq||2,pa=ba+PI/2,w=sin(mp.t*f)*80;e.x+=(cos(ba)*s+cos(pa)*w*f)*dt;e.y+=(sin(ba)*s+sin(pa)*w*f)*dt},
  // Boss movement
  stationary(e,dt){},
  bossChase(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=60;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt},
  // Formation converge
  converge(e,dt){const a=atan2(player.y-e.y,player.x-e.x),s=e.moveParams.speed||150;e.x+=cos(a)*s*dt;e.y+=sin(a)*s*dt},
};

// == ENEMY FIRE PATTERNS ==
const EFIRE={
  single(e){const a=atan2(player.y-e.y,player.x-e.x),s=180+G.difficulty*10;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,4,e.color,'normal',3)},
  triple(e){const a=atan2(player.y-e.y,player.x-e.x),s=170+G.difficulty*8;for(let i=-1;i<=1;i++)fireEB(e.x,e.y,cos(a+i*.2)*s,sin(a+i*.2)*s,3.5,e.color,'normal',2.5)},
  radial(e){const n=e.fireParams.count||8,s=140+G.difficulty*5,off=e.fireParams.offset||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3.5,e.color,'normal',3)}e.fireParams.offset=(off+.15)%TAU},
  spiral(e){const s=160+G.difficulty*6;e.spiralAngle=(e.spiralAngle||0)+.4;fireEB(e.x,e.y,cos(e.spiralAngle)*s,sin(e.spiralAngle)*s,4,e.color,'curve',3.5,{curve:.4})},
  ringpop(e){const n=10,s=200;for(let i=0;i<n;i++){const a=TAU/n*i;fireEB(e.x,e.y,cos(a)*s,sin(a)*s,3,e.color,'pulse',3,{pulseAmp:.7,pulseFreq:3})}},
  wave(e){const a=atan2(player.y-e.y,player.x-e.x),s=160+G.difficulty*5,pa=a+PI/2;for(let i=0;i<5;i++){const off=(i-2)*15;fireEB(e.x+cos(pa)*off,e.y+sin(pa)*off,cos(a)*s,sin(a)*s,3,e.color,'normal',3)}},
  // Boss patterns
  bossRadial(e){const n=16,s=150,off=e.spiralAngle||0;for(let i=0;i<n;i++){const a=TAU/n*i+off;fireBossEB(e.x,e.y,cos(a)*s,sin(a)*s,5,e.color,'normal',4)}e.spiralAngle=(off+.2)%TAU},
  bossWall(e){
    const a=atan2(player.y-e.y,player.x-e.x),pa=a+PI/2,s=220,n=13,gap=30;
    for(let i=0;i<n;i++){
      const off=(i-(n-1)/2)*gap;
      const sx=e.x+cos(pa)*off,sy=e.y+sin(pa)*off;
      fireBossEB(sx,sy,cos(a)*s,sin(a)*s,4.2,e.color,'normal',3.2);
    }
  },
};
function makeBossBulletFx(){
  const t=rPick(['normal','gravity','speed_shift','wind_shift','homing']);
  if(t==='gravity')return{bossFx:'gravity',bossFxPower:360+Math.random()*220};
  if(t==='speed_shift')return{bossFx:'speed_shift',bossFxPower:1.25+Math.random()*.95,bossFxFreq:6+Math.random()*4,bossFxPhase:rAngle()};
  if(t==='wind_shift'){const a=rAngle(),p=260+Math.random()*170;return{bossFx:'wind_shift',bossWindX:cos(a)*p,bossWindY:sin(a)*p,bossFxSpin:.8+Math.random()*1.1}}
  if(t==='homing')return{bossFx:'homing',bossHomingTurn:2.4+Math.random()*1.8,bossHomingStop:150+Math.random()*90};
  return{bossFx:'normal'};
}
function fireEB(x,y,vx,vy,r,c,t,l,p){enemyBullets.spawn(b=>{b.x=x;b.y=y;b.vx=vx;b.vy=vy;b.r=r||4;b.color=hostileColor(c||'#f44');b.type=t||'normal';b.life=l||3;b.maxLife=l||3;b.spawnTime=G.time;b.echoed=false;b.echoTimer=0;b.damage=1;b.curve=p&&p.curve||0;b.pulseAmp=p&&p.pulseAmp||0;b.pulseFreq=p&&p.pulseFreq||0;b.split=p&&p.split||false;b.baseSpeed=sqrt(vx*vx+vy*vy);b.loopAmp=p&&p.loopAmp||0;b.loopFreq=p&&p.loopFreq||0;b.loopBaseAng=p&&p.loopBaseAng!==undefined?p.loopBaseAng:atan2(vy,vx);b.bossFx=p&&p.bossFx||'normal';b.bossFxPower=p&&p.bossFxPower||0;b.bossFxFreq=p&&p.bossFxFreq||0;b.bossFxPhase=p&&p.bossFxPhase||0;b.bossWindX=p&&p.bossWindX||0;b.bossWindY=p&&p.bossWindY||0;b.bossFxSpin=p&&p.bossFxSpin||0;b.bossHomingTurn=p&&p.bossHomingTurn||0;b.bossHomingStop=p&&p.bossHomingStop||0;b._bounced=false})}
function fireBossEB(x,y,vx,vy,r,c,t,l,p){const fx=makeBossBulletFx();if(p)for(const k in p)fx[k]=p[k];fireEB(x,y,vx,vy,r,c,t,l,fx)}

// == ENEMY SPAWN/UPDATE/DRAW ==
const ECOLORS=['#f44','#f84','#ff4','#4f4','#4ff','#f4f','#84f'];
const ESHAPES=['circle','square','triangle'];
const EMTYPES=['drifter','chaser','orbiter','dasher','sentry','weaver'];
const EFTYPES=['single','triple','radial','spiral','ringpop','wave'];

function spawnEnemy(tier,opts){
  tier=tier||'small';const isE=tier==='elite';
  enemies.spawn(e=>{
    const a=rAngle(),sd=max(CX,CY)+50+rr(0,100);
    e.x=opts&&opts.x!==undefined?opts.x:player.x+cos(a)*sd;
    e.y=opts&&opts.y!==undefined?opts.y:player.y+sin(a)*sd;
    e.shape=opts&&opts.shape||rPick(ESHAPES);e.color=hostileColor(opts&&opts.color||rPick(ECOLORS));
    e.moveType=opts&&opts.moveType||rPick(EMTYPES);
    e.firePattern=opts&&opts.firePattern||rPick(EFTYPES);
    e.tier=tier;e.r=isE?22:14;
    const waveScale=1+G.wave*.11+G.wave*G.wave*.003;
    e.hp=(isE?10:3)*waveScale|0;e.maxHp=e.hp;
    e.fireCD=(isE?rr(.8,1.5):rr(1.5,3))/(1+G.difficulty*.08);
    if(opts&&opts.fireMult)e.fireCD/=opts.fireMult;
    e.fireTimer=rr(.5,e.fireCD);e.hitFlash=0;e.angle=rAngle();e.spiralAngle=rAngle();e.spawnTime=G.time;
    e._dashTele=null;e._dashInvuln=0;
    e.moveParams=opts&&opts.moveParams||{};e.fireParams={};
    e.isBoss=false;e.bossAI=null;e.shieldHP=0;
    e.cc={stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0};
    // Init move params
    if(e.moveType==='drifter'){const s=rr(40,80),da=rAngle();e.vx=cos(da)*s;e.vy=sin(da)*s}
    else if(e.moveType==='orbiter'){e.moveParams.radius=e.moveParams.radius||rr(100,200);e.moveParams.speed=e.moveParams.speed||rr(1,2.5)*(Math.random()<.5?1:-1);e.moveParams.angle=e.moveParams.angle||rAngle()}
    else if(e.moveType==='dasher'){e.moveParams.state='wait';e.moveParams.waitTime=0;e.vx=0;e.vy=0}
    else if(e.moveType==='weaver'){e.moveParams.t=0;e.moveParams.speed=e.moveParams.speed||rr(60,120);e.moveParams.freq=e.moveParams.freq||rr(2,5)}
    else if(e.moveType==='chaser'){e.moveParams.speed=e.moveParams.speed||rr(80,140);e.vx=0;e.vy=0}
    else if(e.moveType==='sentry'){e.vx=rr(-20,20);e.vy=rr(-20,20)}
    else if(e.moveType==='converge'){e.moveParams.speed=e.moveParams.speed||150}
    if(e.firePattern==='radial'){e.fireParams.count=isE?ri(10,16):ri(6,10);e.fireParams.offset=rAngle()}
    if(opts&&opts.hpMult){e.hp=e.hp*opts.hpMult|0;e.maxHp=e.hp}
    if(opts&&opts.spdMult)e.moveParams.speed=(e.moveParams.speed||100)*opts.spdMult;
    return e;
  });
}
function updateEnemies(dt){
  if(G.frozen)return; // Time freeze
  enemies.each(e=>{
    const cc=e.cc;
    // Bleed
    if(cc.bleedT>0){cc.bleedT-=dt;e.hp-=cc.bleedDmg*dt;if(e.hp<=0)killEnemy(e)}
    // Stun: skip everything
    if(cc.stunT>0){cc.stunT-=dt;e.hitFlash=.2;collideObs(e);return}
    // CC timers
    if(cc.silenceT>0)cc.silenceT-=dt;
    if(cc.rootT>0)cc.rootT-=dt;
    if(cc.slowT>0)cc.slowT-=dt;else cc.slowAmt=0;
    if(cc.fearT>0){cc.fearT-=dt;const a=atan2(e.y-player.y,e.x-player.x);const fs=(e.moveParams.speed||100)*1.5;e.x+=cos(a)*fs*dt;e.y+=sin(a)*fs*dt}
    else if(cc.disorientT>0){cc.disorientT-=dt;e.x+=(Math.random()-.5)*200*dt;e.y+=(Math.random()-.5)*200*dt}
    else if(cc.kbVx||cc.kbVy){e.x+=cc.kbVx*dt;e.y+=cc.kbVy*dt;cc.kbVx*=.9;cc.kbVy*=.9;if(abs(cc.kbVx)<5)cc.kbVx=0;if(abs(cc.kbVy)<5)cc.kbVy=0}
    else if(cc.rootT<=0){
      // Normal movement with slow
      const spdMult=cc.slowT>0?(1-cc.slowAmt):1;
      const origSpd=e.moveParams.speed;
      if(origSpd)e.moveParams.speed=origSpd*spdMult;
      if(e.isBoss&&e.bossAI)e.bossAI.update(e,dt);
      else if(EMOVE[e.moveType])EMOVE[e.moveType](e,dt);
      if(origSpd)e.moveParams.speed=origSpd;
    }
    if(cc.markT>0)cc.markT-=dt;else cc.markAmp=0;
    // Fire (skip if silenced)
    if(cc.silenceT<=0){
      const frMult=cc.slowT>0?(1-cc.slowAmt*.5):1;
      e.fireTimer-=dt*frMult;
      if(e.fireTimer<=0&&player.alive){e.fireTimer+=e.fireCD;
        if(e.isBoss&&e.bossAI)e.bossAI.fire(e);
        else if(EFIRE[e.firePattern])EFIRE[e.firePattern](e);
      }
    }
    e.angle+=dt*(e.moveType==='sentry'?1.5:.5);
    e.hitFlash=max(0,e.hitFlash-dt*5);
    if(e._dashInvuln>0)e._dashInvuln=max(0,e._dashInvuln-dt);
    collideObs(e);
    if(dist(e.x,e.y,player.x,player.y)>CFG.cullDist&&!e.isBoss)e.active=false;
  });
}
function drawGeneratedBoss(e){
  const r=e.r,col=e.color||'#f6c';
  ctx.save();ctx.translate(e.x,e.y);ctx.rotate(e.angle*.6);
  const sh=e.bossShape||'circle';
  if(sh==='square')glowPoly(sqPts(0,0,r,0),col,true,4);
  else if(sh==='triangle')glowPoly(triPts(0,0,r,0),col,true,4);
  else glowCircle(0,0,r,col,4);
  ctx.beginPath();ctx.arc(0,0,r*.24+sin(G.time*5)*1.2,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.7;ctx.fill();
  if(e._dashInvuln>0){ctx.beginPath();ctx.arc(0,0,r+7+sin(G.time*16)*1.8,0,TAU);ctx.strokeStyle='rgba(255,235,180,.55)';ctx.lineWidth=2;ctx.stroke()}
  ctx.restore();
  if(e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0))for(const sn of e.bossAI.shieldNodes){
    if(sn.hp<=0)continue;
    const nx=e.x+cos(sn.angle)*(e.r+22),ny=e.y+sin(sn.angle)*(e.r+22);
    glowCircle(nx,ny,8,col,2);glowDot(nx,ny,2.5,'#fff');
  }
}
function drawWarperPortal(x,y,lifeNorm,phase){
  const t=G.time+phase,a=clamp(lifeNorm,0,1),r=(60+sin(t*6)*8)*(0.8+.25*a);
  ctx.save();ctx.translate(x,y);ctx.rotate(t*1.2);
  ctx.beginPath();ctx.arc(0,0,r+10,0,TAU);ctx.strokeStyle='rgba(138,93,255,'+(.28*a)+')';ctx.lineWidth=8;ctx.stroke();
  ctx.beginPath();ctx.arc(0,0,r,0,TAU);ctx.strokeStyle='rgba(210,170,255,'+(.55*a)+')';ctx.lineWidth=3;ctx.stroke();
  for(let i=0;i<8;i++){const ang=TAU/8*i+t*.8;ctx.beginPath();ctx.moveTo(cos(ang)*(r*.45),sin(ang)*(r*.45));ctx.lineTo(cos(ang)*(r+8),sin(ang)*(r+8));ctx.strokeStyle='rgba(220,190,255,'+(.35*a)+')';ctx.lineWidth=1.4;ctx.stroke()}
  ctx.restore();
}
function drawDashTelegraph(e){
  if(!e._dashTele)return;
  const d=e._dashTele,p=1-clamp(d.t/max(.0001,d.maxT),0,1),a=atan2(d.ty-e.y,d.tx-e.x),ax=e.x+cos(a)*(e.r+12),ay=e.y+sin(a)*(e.r+12);
  ctx.save();
  strokeRing(e.x,e.y,e.r+8+sin(G.time*18)*2,'rgba(255,235,140,'+(.24+.42*p)+')',2.1);
  ctx.translate(ax,ay);ctx.rotate(a);const ts=7+p*1.8;
  ctx.beginPath();ctx.moveTo(ts,0);ctx.lineTo(-ts*.55,-ts*.55);ctx.lineTo(-ts*.55,ts*.55);ctx.closePath();
  ctx.fillStyle='rgba(255,245,180,'+(.35+.4*p)+')';ctx.fill();
  ctx.restore();
}
function drawEnemies(){
  enemies.each(e=>{
    let col=e.hitFlash>0?'#fff':e.color;
    const cc=e.cc;
    if(cc.fearT>0)col='#ddd';
    const r=e.r+(e.hitFlash>0?2:0);
    if(e.isBoss){drawGeneratedBoss(e)}
    else{
      const gn=e.tier==='elite'?4:3;
      if(e.shape==='circle')glowCircle(e.x,e.y,r,col,gn);
      else if(e.shape==='square')glowPoly(sqPts(e.x,e.y,r,e.angle),col,true,gn);
      else glowPoly(triPts(e.x,e.y,r,e.angle),col,true,gn);
    }
    if(e._dashTele&&(e.moveType==='dasher'||e.isBoss))drawDashTelegraph(e);
    if(e.tier==='elite'&&e.hp<e.maxHp&&!e.isBoss){
      const bw=e.r*2;ctx.fillStyle='#333';ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw,3);ctx.fillStyle=e.color;ctx.fillRect(e.x-bw/2,e.y-e.r-8,bw*(e.hp/e.maxHp),3);
    }
    if(cc.markT>0){ctx.beginPath();ctx.arc(e.x,e.y-e.r-10,3,0,TAU);ctx.fillStyle='#ccc';ctx.fill()}
    if(cc.stunT>0||cc.rootT>0||cc.slowT>0||cc.bleedT>0){
      ctx.beginPath();ctx.arc(e.x,e.y,e.r+3,0,TAU);ctx.strokeStyle='rgba(255,255,255,.4)';ctx.lineWidth=1.2;ctx.stroke();
    }
    if(cc.silenceT>0){
      const sr=e.r+5;
      ctx.beginPath();ctx.moveTo(e.x-sr,e.y-sr);ctx.lineTo(e.x+sr,e.y+sr);
      ctx.moveTo(e.x+sr,e.y-sr);ctx.lineTo(e.x-sr,e.y+sr);
      ctx.strokeStyle='#0aa';ctx.lineWidth=2.2;ctx.globalAlpha=.85;ctx.stroke();
    }
  });
}

// == BULLETS ==
function updateBulletPool(pool,dt,isP){
  if(G.frozen&&!isP)return;
  pool.each(b=>{
    if(b.type==='curve'&&b.curve){const s=sqrt(b.vx**2+b.vy**2),a=atan2(b.vy,b.vx)+b.curve*dt;b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(b.type==='loop'&&b.loopAmp){
      const t=(G.time-b.spawnTime)*(b.loopFreq||2.6),ba=b.loopBaseAng,s=max(80,b.baseSpeed),sw=sin(t*TAU)*(b.loopAmp||120);
      const ux=cos(ba),uy=sin(ba),px=-uy,py=ux;
      b.vx=ux*s+px*sw;b.vy=uy*s+py*sw;
    }
    if(b.type==='pulse'&&b.pulseAmp){const t=1-b.life/b.maxLife,s=b.baseSpeed*(1+sin(t*b.pulseFreq*TAU)*b.pulseAmp),a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
    if(!isP){
      if(b.bossFx==='gravity'){
        const dx=player.x-b.x,dy=player.y-b.y,d=max(45,sqrt(dx*dx+dy*dy)),pow=b.bossFxPower||420;
        b.vx+=dx/d*pow*dt;b.vy+=dy/d*pow*dt;
      }else if(b.bossFx==='speed_shift'){
        const amp=b.bossFxPower||1.6,fq=b.bossFxFreq||7,ph=b.bossFxPhase||0;
        const s=b.baseSpeed*(1+sin((G.time+b.spawnTime)*fq+ph)*amp*.45),a=atan2(b.vy,b.vx);
        b.vx=cos(a)*max(80,s);b.vy=sin(a)*max(80,s);
      }else if(b.bossFx==='wind_shift'){
        const spin=b.bossFxSpin||0;
        if(spin){const a=atan2(b.bossWindY,b.bossWindX)+dt*spin,m=sqrt(b.bossWindX*b.bossWindX+b.bossWindY*b.bossWindY);b.bossWindX=cos(a)*m;b.bossWindY=sin(a)*m}
        b.vx+=b.bossWindX*dt;b.vy+=b.bossWindY*dt;
      }else if(b.bossFx==='homing'){
        const dx=player.x-b.x,dy=player.y-b.y,d=sqrt(dx*dx+dy*dy),stop=b.bossHomingStop||180;
        if(d>stop){
          const target=atan2(dy,dx),cur=atan2(b.vy,b.vx),turn=clamp(normAng(target-cur),-(b.bossHomingTurn||3)*dt,(b.bossHomingTurn||3)*dt);
          const na=cur+turn,s=max(90,sqrt(b.vx*b.vx+b.vy*b.vy));
          b.vx=cos(na)*s;b.vy=sin(na)*s;
        }
      }
      if(G.gravity){const dx=player.x-b.x,dy=player.y-b.y,d=max(50,sqrt(dx*dx+dy*dy));b.vx+=dx/d*G.gravity*dt;b.vy+=dy/d*G.gravity*dt}
      if(G.pulseSpeed){const s=sqrt(b.vx**2+b.vy**2)+G.pulseSpeed*dt,a=atan2(b.vy,b.vx);b.vx=cos(a)*s;b.vy=sin(a)*s}
      if(G.echo&&!b.echoed){b.echoTimer+=dt;if(b.echoTimer>.15){b.echoed=true;enemyBullets.spawn(eb=>{eb.x=b.x;eb.y=b.y;eb.vx=b.vx*.7;eb.vy=b.vy*.7;eb.r=b.r*.7;eb.color=b.color;eb.type='normal';eb.life=b.life*.5;eb.maxLife=eb.life;eb.spawnTime=G.time;eb.echoed=true;eb.echoTimer=0;eb.curve=0;eb.pulseAmp=0;eb.split=false;eb.damage=1;eb.baseSpeed=sqrt(eb.vx**2+eb.vy**2)})}}
      b.vx+=G.windX*dt*.5;b.vy+=G.windY*dt*.5;
    }
    b.x+=b.vx*dt;b.y+=b.vy*dt;b.life-=dt*(G.fragile&&!isP?1.45:1);
    if(G.mirror&&!isP){
      const rr=player.r+18;
      if(dist(b.x,b.y,player.x,player.y)<rr+b.r){
        const rvx=-b.vx*1.08,rvy=-b.vy*1.08,bl=min(2,b.life+.4);
        playerBullets.spawn(pb=>{pb.x=b.x;pb.y=b.y;pb.vx=rvx;pb.vy=rvy;pb.r=max(2.5,b.r*.85);pb.life=bl;pb.maxLife=bl;pb.type='normal';pb.color='#9ff';pb.spawnTime=G.time;pb.damage=1;pb.pierce=0;pb.split=false;pb.echoed=false;pb.baseSpeed=sqrt(rvx*rvx+rvy*rvy);pb.curve=0;pb.pulseAmp=0;pb.src='mirror'});
        b.active=false;burstParticles(b.x,b.y,'#aff',4,90);return;
      }
    }
    const obsHit=bulletHitsObs(b);
    if(obsHit){
      if(G.bounce&&!isP&&!b._bounced){
        b._bounced=true;
        if(obsHit.type==='wall'){
          const nx=clamp(b.x,obsHit.x,obsHit.x+obsHit.w),ny=clamp(b.y,obsHit.y,obsHit.y+obsHit.h);
          const dx=b.x-nx,dy=b.y-ny;
          if(abs(dx)>abs(dy))b.vx*=-.9;else b.vy*=-.9;
        }else{
          const nx=b.x-obsHit.x,ny=b.y-obsHit.y,d=max(1,sqrt(nx*nx+ny*ny)),dot=(b.vx*nx+b.vy*ny)/d;
          b.vx-=2*dot*nx/d;b.vy-=2*dot*ny/d;
        }
        b.life*=.85;burstParticles(b.x,b.y,'#fa8',3,70);
      }else{b.active=false;burstParticles(b.x,b.y,b.color,3,60)}
    }
    if(dist(b.x,b.y,player.x,player.y)>CFG.cullDist)b.active=false;
    if(b.life<=0){b.active=false;if(b.split&&!isP)for(let i=0;i<3;i++){const a=Math.random()*TAU;fireEB(b.x,b.y,cos(a)*100,sin(a)*100,2.5,b.color,'normal',1.5)}}
  });
}
function drawBulletPool(pool){pool.each(b=>{const a=clamp(b.life/b.maxLife,0,1);ctx.save();ctx.globalAlpha=a;
  const rc=b.src==='rocket'||b.src==='rocket_mini'?(b.src==='rocket_mini'?'#fa0':'#f80'):b.color;
  glowDot(b.x,b.y,b.r,rc);
  if(b.bossFx&&b.bossFx!=='normal'){ctx.beginPath();ctx.arc(b.x,b.y,b.r+2,0,TAU);ctx.strokeStyle=b.bossFx==='gravity'?'#f8f':b.bossFx==='speed_shift'?'#ff8':'#8ff';ctx.lineWidth=1;ctx.globalAlpha=.4*a;ctx.stroke();}
  ctx.restore()})}

// == WEAPON SYSTEM ==
// Weapon state per slot
const initFields=(s,o)=>{for(const k in o)s[k]=o[k]};
const WEAPON_INIT_FN={
  dagger:s=>initFields(s,{state:'idle',dx:0,dy:0,tx:0,ty:0,speed:800,dmg:4,idleTimer:0,spinTimer:0,spinR:25}),
  sword:s=>initFields(s,{swingCD:0,lungeTimer:0,lungeDir:0,lungeDist:120,lungeStartX:0,lungeStartY:0,lungeProg:0}),
  bow:s=>initFields(s,{charging:false,chargeTime:0,maxCharge:1.5,shotCD:0}),
  chain:s=>initFields(s,{timer:0.1,range:200,chains:4,stunDur:.3,dmg:5,_arcTimer:0,_targets:null}),
  rocket:s=>initFields(s,{timer:0.1,blastR:90,kbForce:250,lastFired:0}),
  mines:s=>initFields(s,{timer:.2,placeCD:2.1,mineLife:7,mineR:48,damage:18,maxMines:3,_mines:[]}),
  shuriken:s=>initFields(s,{timer:0.1,count:1,markDur:3,markAmp:.3,bounces:2,_shurikens:[]}),
  drone:s=>initFields(s,{timer:0.1,_drones:[],droneCount:1,droneRange:150,silenceDur:1.5}),
};
function createWeaponState(id){
  const s={id,lv:{a:0,b:0,c:0,d:0}};
  const init=WEAPON_INIT_FN[id];if(init)init(s);
  return s;
}

// Weapon definitions (packed rows -> hydrated objects for smaller source footprint)
const WDATA=[
  ['dagger','MAGIC DAGGER','#0ff','starter','Click to throw. Click again to redirect.','',[
    ['a','PIERCING THROW',3,['+50% speed','90% + homing','120% + homing']],
    ['b','SPECTRAL COPY',3,['1 ghost 50% dmg','2 ghosts 60%','3 ghosts 75%']],
    ['d','DAGGER STORM',2,['0.8s +75% radius','1.2s +150% radius']],
  ]],
  ['sword','PLASMA SWORD','#f0f','starter','Click to lunge-slash forward, cleaving enemies and bullets. i-frames during dash.','',[
    ['a','LUNGE REACH',3,['+33% range','+67%','+108%']],
    ['b','WIDE CLEAVE',3,['+25% size','+50%','+88%']],
    ['c','EDGE CHARGE',2,['+15% length +2 dmg','+30% length +4 dmg']],
    ['d','PHASE TRAIL',2,['Afterimage trail +12% cleave','Trail +28% cleave, denser']],
  ]],
  ['bow','VOLT BOW','#ff0','starter','Hold to charge, release a piercing beam.','',[
    ['a','PRISM SPLIT',2,['1 side pair','2 side pairs']],
    ['b','QUICK DRAW',3,['1.0s charge','0.8s','0.6s']],
    ['c','PLASMA BURN',2,['Applies burn','Stronger burn']],
  ]],
  ['chain','CHAIN LIGHTNING','#a0f','cc','Auto-zaps nearby bullets, chains between targets, and can leave stun fields.','BULLET CLEAR',[
    ['a','EXTRA CHAINS',2,['+3 chains (7)','+3 (10)']],
    ['b','MULTI STRIKE',2,['2 bolts at once','3 bolts']],
    ['c','STATIC FIELD',2,['3s lingering stun zone','5s zone + wider']],
  ]],
  ['rocket','ROCKET LAUNCHER','#f80','cc','Homing rockets explode for knockback and bullet clearing.','KNOCKBACK',[
    ['a','CONCUSSIVE BLAST',3,['+60 knockback','+120 kb','+200 kb']],
    ['b','CLUSTER BOMB',2,['5 homing mini-rockets','7']],
    ['c','BLAST RADIUS',2,['+44% radius','+78% radius']],
  ]],
  ['mines','LANDMINES','#7f7','cc','Auto-deploys proximity mines that detonate in an area and clear bullets.','AREA DENIAL',[
    ['a','BLAST CHAMBER',2,['+35% blast radius','+70% blast radius']],
    ['b','RESERVE RACK',2,['+1 max mine','+2 max mines']],
    ['c','SHOCK FUSE',2,['Leaves short stun field','Longer field + larger radius']],
  ]],
  ['shuriken','SHURIKEN','#bbb','cc','Bouncing shurikens mark enemies for bonus damage.','MARK',[
    ['a','EXTRA SHURIKEN',2,['+1','+1 (3 total)']],
    ['b','DEEP MARK',2,['45% bonus dmg','60%']],
    ['c','EXT MARK',2,['5s','7s']],
    ['d','EXTRA BOUNCES',3,['+2 bounces (4)','+2 (6)','+2 (8)']],
  ]],
  ['drone','PULSE DRONE','#0aa','cc','Drone silences enemies, slows bullets.','SILENCE',[
    ['a','EXTRA DRONE',2,['+1 drone','+1 (3 total)']],
    ['b','EXT SILENCE',2,['2.5s','3.5s']],
    ['c','DISRUPTION',2,['20% slow','40%']],
    ['d','OVERDRIVE',2,['0.9s cd','0.7s']],
  ]],
];
const WDEFS={};
for(const w of WDATA){
  const ups=[];
  for(let i=0;i<w[6].length;i++){const u=w[6][i];ups.push({id:u[0],name:u[1],maxLv:u[2],desc:u[3]})}
  const d={name:w[1],color:w[2],type:w[3],desc:w[4],upgrades:ups};
  if(w[5])d.cc=w[5];
  WDEFS[w[0]]=d;
}
const STARTER_KEYS=['dagger','sword','bow'];
const CC_KEYS=['chain','rocket','mines','shuriken','drone'];
const IMPLEMENTED_CC=['chain','rocket','mines','shuriken','drone'];

// Weapon update/draw dispatch
function updateWeapons(dt){
  for(const w of G.weapons){
    if(w.id==='dagger')updateDagger(w,dt);
    else if(w.id==='sword')updateSword(w,dt);
    else if(w.id==='bow')updateBow(w,dt);
    else if(w.id==='chain')updateChain(w,dt);
    else if(w.id==='rocket')updateRocket(w,dt);
    else if(w.id==='mines')updateMines(w,dt);
    else if(w.id==='shuriken')updateShuriken(w,dt);
    else if(w.id==='drone')updateDrone(w,dt);
  }
}
function drawWeapons(){
  for(const w of G.weapons){
    if(w.id==='dagger')drawDagger(w);
    else if(w.id==='sword')drawSword(w);
    else if(w.id==='bow')drawBow(w);
    else if(w.id==='chain')drawChain(w);
    else if(w.id==='rocket')drawRocket(w);
    else if(w.id==='mines')drawMines(w);
    else if(w.id==='shuriken')drawShuriken(w);
    else if(w.id==='drone')drawDrone(w);
  }
}
function getStarterForButton(btn){
  let first=null,second=null;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i];
    if(WDEFS[w.id].type!=='starter')continue;
    if(!first){first=w;continue}
    second=w;break;
  }
  if(btn===0)return first;
  if(btn===2)return second;
  return null;
}

// == MAGIC DAGGER ==
function updateDagger(w,dt){
  if(w.state==='flying'){
    const spdMult=[1,1.5,1.9,2.2][w.lv.a];
    const a=atan2(w.ty-w.dy,w.tx-w.dx),s=w.speed*spdMult*dt;
    const d=dist(w.dx,w.dy,w.tx,w.ty);
    if(d<s+5){w.dx=w.tx;w.dy=w.ty;
      if(w.lv.d>0){w.state='spinning';w.spinTimer=[0,.8,1.2][w.lv.d];w.spinR=[0,35,50][w.lv.d]}
      else{w.state='waiting';w.idleTimer=0}
    }else{w.dx+=cos(a)*s;w.dy+=sin(a)*s}
    // Damage enemies in path
    daggerHitEnemies(w,w.dmg);
  }else if(w.state==='spinning'){
    w.spinTimer-=dt;w.angle=(w.angle||0)+dt*15;
    daggerSpinDamage(w,dt);
    if(w.spinTimer<=0){w.state='waiting';w.idleTimer=0}
  }else if(w.state==='waiting'){
    w.idleTimer+=dt;if(w.idleTimer>2){w.state='returning'}
  }else if(w.state==='returning'){
    const a=atan2(player.y-w.dy,player.x-w.dx),s=w.speed*1.2*dt;
    w.dx+=cos(a)*s;w.dy+=sin(a)*s;
    daggerHitEnemies(w,w.dmg);
    if(dist(w.dx,w.dy,player.x,player.y)<20){w.state='idle'}
  }else{w.dx=player.x;w.dy=player.y}
  // Update ghost positions (trail behind main dagger with offset)
  if(w.lv.b>0){
    const nGhosts=[0,1,2,3][w.lv.b];
    if(!w._ghosts)w._ghosts=[];
    if(!w._posHistory)w._posHistory=[];
    w._posHistory.push({x:w.dx,y:w.dy});
    if(w._posHistory.length>30)w._posHistory.shift();
    w._ghosts=[];
    for(let g=0;g<nGhosts;g++){
      const idx=max(0,w._posHistory.length-1-(g+1)*6);
      w._ghosts.push({x:w._posHistory[idx].x,y:w._posHistory[idx].y});
    }
  }
}
function daggerHitEnemies(w,dmg){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<e.r+8){dealDamage(e,dmg,'dagger')}});
  // SPECTRAL COPY: ghost daggers hit too
  if(w.lv.b>0&&w._ghosts){
    const ghostDmg=dmg*[0,.5,.6,.75][w.lv.b];
    for(const g of w._ghosts){
      enemies.each(e=>{if(!e.active)return;if(dist(g.x,g.y,e.x,e.y)<e.r+8){dealDamage(e,ghostDmg,'dagger_ghost')}});
    }
  }
}
function daggerSpinDamage(w,dt){
  enemies.each(e=>{if(!e.active)return;if(dist(w.dx,w.dy,e.x,e.y)<w.spinR+e.r){dealDamage(e,[0,3,4][w.lv.d]*dt*10,'dagger')}});
}
function drawDagger(w){
  const x=w.dx||player.x,y=w.dy||player.y;
  if(w.state==='idle'){
    const a=player.angle,ox=player.x+cos(a)*18,oy=player.y+sin(a)*18;
    glowPoly([{x:ox+cos(a)*8,y:oy+sin(a)*8},{x:ox+cos(a+2.3)*5,y:oy+sin(a+2.3)*5},{x:ox+cos(a-2.3)*5,y:oy+sin(a-2.3)*5}],'#0ff',true,3);
  }else{
    const a=w.state==='spinning'?(w.angle||0):atan2(w.dy-(w.state==='returning'?player.y:w.ty),w.dx-(w.state==='returning'?player.x:w.tx))+PI;
    glowPoly([{x:x+cos(a)*10,y:y+sin(a)*10},{x:x+cos(a+2.3)*6,y:y+sin(a+2.3)*6},{x:x+cos(a-2.3)*6,y:y+sin(a-2.3)*6}],'#0ff',true,4);
    if(w.state==='spinning'){drawGlowArc(x,y,w.spinR,0,TAU,'#0ff',1)}
    // Render ghost copies
    if(w.lv.b>0&&w._ghosts&&w.state!=='idle'){
      for(let g=0;g<w._ghosts.length;g++){
        const gh=w._ghosts[g];
        const ga=(w.state==='spinning')?(w.angle||0):atan2(w.dy-gh.y,w.dx-gh.x);
        ctx.save();ctx.globalAlpha=.35-g*.08;
        glowPoly([{x:gh.x+cos(ga)*10,y:gh.y+sin(ga)*10},{x:gh.x+cos(ga+2.3)*6,y:gh.y+sin(ga+2.3)*6},{x:gh.x+cos(ga-2.3)*6,y:gh.y+sin(ga-2.3)*6}],'#0ff',true,3);
        ctx.restore();
      }
    }
  }
}
function onDaggerClick(w,wx,wy){
  if(w.state==='idle'||w.state==='waiting'||w.state==='spinning'){
    w.state='flying';w.tx=wx;w.ty=wy;
    if(w.state==='idle'){w.dx=player.x;w.dy=player.y}
  }else if(w.state==='flying'){w.tx=wx;w.ty=wy}
  else if(w.state==='returning'){w.state='flying';w.tx=wx;w.ty=wy}
}

// == PLASMA SWORD ==
function updateSword(w,dt){
  w.swingCD=max(0,w.swingCD-dt);
  if(w.lungeTimer>0){
    w.lungeTimer-=dt;
    const dur=.18;
    w.lungeProg=clamp(1-w.lungeTimer/dur,0,1);
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Move player along lunge path
    const px=w.lungeStartX+cos(w.lungeDir)*ld*w.lungeProg;
    const py=w.lungeStartY+sin(w.lungeDir)*ld*w.lungeProg;
    player.x=px;player.y=py;
    // Full i-frames during lunge dash
    player.invuln=max(player.invuln,.25);
    player.swordIFrame=max(player.swordIFrame,.25);
    // Hit enemies in cleave zone around player (extends forward by blade reach)
    const dmg=8+[0,2,4][w.lv.c];
    const bladeReach=70*(1+[0,.15,.3][w.lv.c]);
    enemies.each(e=>{if(!e.active)return;
      // Hitbox relative to current player position, extending forward
      const ex=e.x-px,ey=e.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;// projection along lunge direction from player
      if(proj<-15-e.r||proj>bladeReach+e.r)return;// small behind + blade reach ahead
      const perp=abs(ex*(-ly)+ey*lx);// perpendicular distance
      if(perp<cleaveW+e.r){
        if(!e._swordHitT||G.time-e._swordHitT>.15){
          e._swordHitT=G.time;
          dealDamage(e,dmg,'sword',false);
          addShake(2);
        }
      }
    });
    // Destroy enemy bullets in cleave zone around player
    enemyBullets.each(b=>{if(!b.active)return;
      const ex=b.x-px,ey=b.y-py;
      const lx=cos(w.lungeDir),ly=sin(w.lungeDir);
      const proj=ex*lx+ey*ly;
      if(proj<-15-b.r||proj>bladeReach+b.r)return;
      const perp=abs(ex*(-ly)+ey*lx);
      if(perp<cleaveW+b.r){b.active=false;burstParticles(b.x,b.y,'#f0f',3,80)}
    });
    // Old sword trail aftershock path from reference copy (mapped to lv.d).
    if(w.lv.d>0)w._aftershockEnd={x:px,y:py,w:cleaveW};
    if(w.lungeTimer<=0){w.lungeTimer=0;w.lungeProg=0;
      const trailLv=clamp(w.lv.d|0,0,2);
      if(trailLv>0&&w._aftershockEnd){
        const ad=[0,2,3][trailLv],al=[0,1.8,2.5][trailLv];
        const sx=w.lungeStartX,sy=w.lungeStartY,ex=w._aftershockEnd.x,ey=w._aftershockEnd.y;
        spawnSwordAftershock(sx,sy,ex,ey,w._aftershockEnd.w*1.1,ad,al);
      }
      w._aftershockEnd=null;
      burstParticles(player.x,player.y,'#f0f',8,120);addShake(4)}
  }
}
function onSwordClick(w,wx,wy){
  const cd=.4*(1-stats.cdReduction);
  if(w.swingCD>0||w.lungeTimer>0)return;
  w.swingCD=cd;
  w.lungeDir=player.angle;
  w.lungeDist=[120,160,200,250][w.lv.a]*(1+[0,.15,.3][w.lv.c]);
  w.lungeStartX=player.x;w.lungeStartY=player.y;
  w.lungeTimer=.18;w.lungeProg=0;w._aftershockEnd=null;
  if(hasAliveBoss())spawnSwordBossSlash(w.lungeDir,w);
  burstParticles(player.x+cos(w.lungeDir)*15,player.y+sin(w.lungeDir)*15,'#f0f',6,100);
}
function drawSword(w){
  const bladeLen=60*(1+[0,.15,.3][w.lv.c]);
  const a=w.lungeTimer>0?w.lungeDir:player.angle;
  const perpA=a+PI/2;
  if(w.lungeTimer>0){
    const prog=w.lungeProg;
    const ld=w.lungeDist;
    const cleaveW=[35,50,60,75][w.lv.b];
    // Old soft tapered slash field.
    const sx=w.lungeStartX,sy=w.lungeStartY;
    const ex=sx+cos(a)*ld*prog,ey=sy+sin(a)*ld*prog;
    const backW=cleaveW*.65,frontW=cleaveW*1.05;
    const bulge=max(8,cleaveW*.2);
    ctx.save();
    const grad=ctx.createLinearGradient(sx,sy,ex,ey);
    grad.addColorStop(0,'rgba(255,120,255,0)');
    grad.addColorStop(.35,'rgba(255,120,255,.08)');
    grad.addColorStop(1,'rgba(255,180,255,.18)');
    ctx.beginPath();
    ctx.moveTo(sx+cos(perpA)*backW,sy+sin(perpA)*backW);
    ctx.quadraticCurveTo((sx+ex)*.5+cos(perpA)*bulge,(sy+ey)*.5+sin(perpA)*bulge,ex+cos(perpA)*frontW,ey+sin(perpA)*frontW);
    ctx.lineTo(ex-cos(perpA)*frontW,ey-sin(perpA)*frontW);
    ctx.quadraticCurveTo((sx+ex)*.5-cos(perpA)*bulge,(sy+ey)*.5-sin(perpA)*bulge,sx-cos(perpA)*backW,sy-sin(perpA)*backW);
    ctx.closePath();
    ctx.fillStyle=grad;ctx.globalAlpha=1;ctx.fill();
    ctx.strokeStyle='rgba(255,120,255,.24)';ctx.lineWidth=1.2;ctx.stroke();
    ctx.restore();
    // Motion lines
    ctx.save();
    for(let i=0;i<5;i++){
      const t=i/5;
      const lx=lerp(sx,ex,t),ly=lerp(sy,ey,t);
      const off=(i%2===0?1:-1)*cleaveW*.5;
      ctx.beginPath();ctx.moveTo(lx+cos(perpA)*off,ly+sin(perpA)*off);
      ctx.lineTo(lx+cos(perpA)*off-cos(a)*15,ly+sin(perpA)*off-sin(a)*15);
      ctx.strokeStyle='#f0f';ctx.lineWidth=1.5;ctx.globalAlpha=.25*(1-t);ctx.stroke();
    }
    ctx.restore();
    // Draw the blade swinging during lunge
    const swingAngle=a + (-PI/2 + PI*prog);
    const swPerpA=swingAngle+PI/2;
    const hiltX=player.x+cos(swingAngle)*10,hiltY=player.y+sin(swingAngle)*10;
    const tipX=player.x+cos(swingAngle)*(10+bladeLen),tipY=player.y+sin(swingAngle)*(10+bladeLen);
    const pts=[
      {x:hiltX+cos(swPerpA)*4,y:hiltY+sin(swPerpA)*4},
      {x:hiltX-cos(swPerpA)*4,y:hiltY-sin(swPerpA)*4},
      {x:tipX-cos(swPerpA)*1.5,y:tipY-sin(swPerpA)*1.5},
      {x:tipX+cos(swingAngle)*6,y:tipY+sin(swingAngle)*6},
      {x:tipX+cos(swPerpA)*1.5,y:tipY+sin(swPerpA)*1.5},
    ];
    glowPoly(pts,'#f0f',true,5);
    // Old dynamic ribbon-like sword trail.
    ctx.save();
    ctx.lineCap='round';
    const trailSteps=7;
    for(let s=1;s<=trailSteps;s++){
      const tp=max(0,prog-s*.05);
      const ta=a+(-PI/2+PI*tp);
      const fade=(1-s/trailSteps);
      const wave=sin(G.time*20+s*.9)*2.2*fade;
      const nx=cos(ta+PI/2),ny=sin(ta+PI/2);
      const thX=player.x+cos(ta)*10+nx*wave,thY=player.y+sin(ta)*10+ny*wave;
      const ttX=player.x+cos(ta)*(10+bladeLen)+nx*wave*1.4,ttY=player.y+sin(ta)*(10+bladeLen)+ny*wave*1.4;
      const mx=(thX+ttX)*.5+nx*(6+2*fade),my=(thY+ttY)*.5+ny*(6+2*fade);
      const g=ctx.createLinearGradient(thX,thY,ttX,ttY);
      g.addColorStop(0,'rgba(255,120,255,0)');
      g.addColorStop(.35,'rgba(255,120,255,'+(.08+.15*fade)+')');
      g.addColorStop(1,'rgba(255,255,255,'+(.05+.15*fade)+')');
      ctx.strokeStyle=g;ctx.lineWidth=2.2+3.4*fade;
      ctx.beginPath();ctx.moveTo(thX,thY);ctx.quadraticCurveTo(mx,my,ttX,ttY);ctx.stroke();
    }
    ctx.restore();
  }else{
    // Idle: show sword pointing in aim direction
    const hiltX=player.x+cos(a)*14,hiltY=player.y+sin(a)*14;
    const tipX=player.x+cos(a)*(14+bladeLen*.7),tipY=player.y+sin(a)*(14+bladeLen*.7);
    const pts=[
      {x:hiltX+cos(perpA)*2.5,y:hiltY+sin(perpA)*2.5},
      {x:hiltX-cos(perpA)*2.5,y:hiltY-sin(perpA)*2.5},
      {x:tipX-cos(perpA)*1,y:tipY-sin(perpA)*1},
      {x:tipX+cos(a)*4,y:tipY+sin(a)*4},
      {x:tipX+cos(perpA)*1,y:tipY+sin(perpA)*1},
    ];
    glowPoly(pts,'#f0f',true,2);
  }
}

// == VOLT BOW ==
function updateBow(w,dt){
  w.shotCD=max(0,w.shotCD-dt);
  const maxC=[1.5,1.0,.8,.6][w.lv.b];
  w.maxCharge=maxC;
  if(w.charging){w.chargeTime=min(w.chargeTime+dt,maxC)}
}
function onBowDown(w){if(w.shotCD<=0)w.charging=true}
function onBowUp(w){
  if(!w.charging)return;w.charging=false;
  if(w.shotCD>0){w.chargeTime=0;return}
  const ct=w.chargeTime,mc=w.maxCharge;
  const pct=clamp(ct/mc,0,1);
  const a=player.angle;
  const beamCount=1;
  const spacing=10+pct*18;
  for(let i=0;i<beamCount;i++){
    const off=(i-(beamCount-1)/2)*spacing;
    fireBowBeam(w,pct,a,off,1,1,1,'#ff0');
    const splitLv=clamp(w.lv.a|0,0,2);
    for(let s=1;s<=splitLv;s++){
      const da=.07*s;
      fireBowBeam(w,pct,a+da,off,.5,.7,.85,'#ffd84a');
      fireBowBeam(w,pct,a-da,off,.5,.7,.85,'#ffd84a');
    }
  }
  w.chargeTime=0;w.shotCD=.22;
  addShake(2+pct*4);
  trigSlowMo(.04,.7+pct*.3);
  burstParticles(player.x+cos(a)*22,player.y+sin(a)*22,'#fff',8,140);
}
function drawBow(w){
  if(w.charging){
    const pct=clamp(w.chargeTime/w.maxCharge,0,1);
    const r=18+pct*10;
    const a=player.angle;
    const tx=player.x+cos(a)*(r+2),ty=player.y+sin(a)*(r+2);
    const pa=a+PI/2;
    ctx.save();
    // Small pointed aim triangle instead of a line.
    const tipX=tx+cos(a)*(5+pct*3),tipY=ty+sin(a)*(5+pct*3);
    const leftX=tx+cos(pa)*(2+pct*1.5),leftY=ty+sin(pa)*(2+pct*1.5);
    const rightX=tx-cos(pa)*(2+pct*1.5),rightY=ty-sin(pa)*(2+pct*1.5);
    ctx.beginPath();ctx.moveTo(tipX,tipY);ctx.lineTo(leftX,leftY);ctx.lineTo(rightX,rightY);ctx.closePath();
    ctx.fillStyle='#ff0';ctx.globalAlpha=.35+.4*pct;ctx.shadowColor='#ff0';ctx.shadowBlur=8+10*pct;ctx.fill();
    strokeRing(player.x,player.y,r,'#ffd84a',1.2+pct*1.2,.3+pct*.5);
    strokeRing(player.x,player.y,r*.55,'#fff',.9+pct*.9,.25+pct*.45);
    ctx.restore();
  }
}

function nearestEnemy(x,y,maxD,skip){
  let best=null,bestD=maxD===undefined?Infinity:maxD;
  enemies.each(e=>{
    if(!e.active)return;
    if(skip&&(skip.has?skip.has(e):skip(e)))return;
    const d=dist(x,y,e.x,e.y);
    if(d<bestD){bestD=d;best=e}
  });
  return best;
}
function nearestEnemyBullet(x,y,maxD,skipA,skipB){
  let best=null,bestD=maxD===undefined?Infinity:maxD;
  enemyBullets.each(b=>{
    if(!b.active)return;
    if(skipA&&(skipA.has?skipA.has(b):skipA(b)))return;
    if(skipB&&(skipB.has?skipB.has(b):skipB(b)))return;
    const d=dist(x,y,b.x,b.y);
    if(d<bestD){bestD=d;best=b}
  });
  return best;
}
function steerVelocity(vx,vy,targetX,targetY,x,y,turnRate,dt){
  const desired=atan2(targetY-y,targetX-x);
  const cur=atan2(vy,vx);
  const turn=clamp(normAng(desired-cur),-turnRate*dt,turnRate*dt);
  const na=cur+turn;
  const spd=sqrt(vx*vx+vy*vy);
  return{vx:cos(na)*spd,vy:sin(na)*spd};
}

// == CHAIN LIGHTNING ==
function updateChain(w,dt){
  // Always update static fields
  updateStaticFields(dt);
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    const range=w.range;// fixed range 200
    const maxChains=w.chains+[0,3,3][w.lv.a];
    const bolts=[1,2,3][w.lv.b]||1;
    const fieldLv=w.lv.c;
    if(!nearestEnemyBullet(player.x,player.y,range))return;
    w.timer=.8;
    w._zigzags=[];w._targets=[];
    const globalHit=new Set();
    for(let bolt=0;bolt<bolts;bolt++){
      const hitBullets=new Set(),targets=[];
      let sx=player.x,sy=player.y;
      if(bolt>0){const oa=TAU/bolts*bolt;sx=player.x+cos(oa)*15;sy=player.y+sin(oa)*15}
      for(let c=0;c<maxChains;c++){
        const bestObj=nearestEnemyBullet(sx,sy,range+(c>0?100:0),hitBullets,globalHit);
        if(!bestObj)break;
        hitBullets.add(bestObj);globalHit.add(bestObj);
        targets.push({x:bestObj.x,y:bestObj.y});
        burstParticles(bestObj.x,bestObj.y,'#a0f',3,80);
        bestObj.active=false;
        if(fieldLv>0){
          const dur=[0,3,5][fieldLv],rad=[0,25,40][fieldLv];
          spawnStaticField(bestObj.x,bestObj.y,dur,rad);
        }
        sx=bestObj.x;sy=bestObj.y;
      }
      let px=bolt>0?player.x+cos(TAU/bolts*bolt)*15:player.x;
      let py=bolt>0?player.y+sin(TAU/bolts*bolt)*15:player.y;
      for(const t of targets){
        const pts=generateLightningPath(px,py,t.x,t.y,8);
        w._zigzags.push(pts);
        w._targets.push(t);
        px=t.x;py=t.y;
      }
    }
    w._arcTimer=.45;
  }
  if(w._arcTimer>0)w._arcTimer-=dt;
}
// Static field lingering zones
if(!window._staticFields)window._staticFields=[];
const MAX_STATIC_FIELDS=200;
function spawnStaticField(x,y,dur,radius){
  // Cap total particles to prevent performance issues
  if(window._staticFields.length>=MAX_STATIC_FIELDS)return;
  const n=3+Math.floor(Math.random()*3);// 3-5 particles per hit
  for(let i=0;i<n;i++){
    if(window._staticFields.length>=MAX_STATIC_FIELDS)break;
    const a=Math.random()*TAU,r=Math.random()*radius;
    window._staticFields.push({x:x+cos(a)*r,y:y+sin(a)*r,life:dur,maxLife:dur,r:radius,stunDur:.15,
      vx:(Math.random()-.5)*20,vy:(Math.random()-.5)*20,size:2+Math.random()*3});
  }
}
function updateStaticFields(dt){
  const sf=window._staticFields;
  for(let i=sf.length-1;i>=0;i--){
    const f=sf[i];f.life-=dt;
    f.x+=f.vx*dt;f.y+=f.vy*dt;
    f.vx*=.95;f.vy*=.95;
    f.vx+=(Math.random()-.5)*40*dt;f.vy+=(Math.random()-.5)*40*dt;
    if(f.life<=0){sf.splice(i,1);continue}
    // Stun enemies touching this particle (3s cooldown between stuns)
    // Only check stun every 0.2s per particle to reduce iterations
    f._checkT=(f._checkT||0)-dt;
    if(f._checkT>0)continue;
    f._checkT=.2;
    enemies.each(e=>{if(!e.active)return;
      if(dist(f.x,f.y,e.x,e.y)<e.r+8){
        if(G.time-(e._lastStaticStun||0)<3)return;
        const bossMult=e.isBoss?.2:1;
        e.cc.stunT=max(e.cc.stunT,f.stunDur*bossMult);
        e._lastStaticStun=G.time;
      }
    });
  }
}
function drawStaticFields(){
  for(const f of window._staticFields){
    const a=clamp(f.life/f.maxLife,0,1);
    ctx.save();ctx.globalAlpha=a*.8;
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a,0,TAU);
    ctx.fillStyle='#c6f';ctx.fill();
    // Outer spark glow
    ctx.beginPath();ctx.arc(f.x,f.y,f.size*a*2,0,TAU);
    ctx.fillStyle='#a0f';ctx.globalAlpha=a*.15;ctx.fill();
    ctx.restore();
  }
}
function generateLightningPath(x1,y1,x2,y2,segments){
  const pts=[{x:x1,y:y1}];
  const dx=x2-x1,dy=y2-y1,d=sqrt(dx*dx+dy*dy);
  const perpX=-dy/d,perpY=dx/d;
  for(let i=1;i<segments;i++){
    const t=i/segments;
    const mx=x1+dx*t,my=y1+dy*t;
    const jitter=(Math.random()-.5)*d*.18;
    pts.push({x:mx+perpX*jitter,y:my+perpY*jitter});
  }
  pts.push({x:x2,y:y2});
  return pts;
}
function drawChain(w){
  if(w._arcTimer>0&&w._zigzags){
    const alpha=clamp(w._arcTimer/.45,0,1);
    const drawArcLayer=(pts,col,lw,a,blur)=>{
      ctx.beginPath();ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++)ctx.lineTo(pts[i].x,pts[i].y);
      ctx.strokeStyle=col;ctx.lineWidth=lw;ctx.globalAlpha=a;ctx.shadowColor=col;ctx.shadowBlur=blur;ctx.stroke();
    };
    ctx.save();
    for(const pts of w._zigzags){
      drawArcLayer(pts,'#a0f',6,alpha*.25,15);
      drawArcLayer(pts,'#c6f',3,alpha*.6,8);
      drawArcLayer(pts,'#eaf',1.5,alpha,4);
      const last=pts[pts.length-1];
      ctx.beginPath();ctx.arc(last.x,last.y,4*alpha,0,TAU);
      ctx.fillStyle='#fff';ctx.globalAlpha=alpha*.8;ctx.shadowBlur=10;ctx.fill();
    }
    ctx.restore();
  }
}

// == ROCKET LAUNCHER ==
function updateRocket(w,dt){
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=2.2;
    const best=nearestEnemy(player.x,player.y,9999);
    const a=best?atan2(best.y-player.y,best.x-player.x):player.angle;
    const rSpd=350;// faster rockets
    playerBullets.spawn(b=>{
      b.x=player.x+cos(a)*16;b.y=player.y+sin(a)*16;
      b.vx=cos(a)*rSpd;b.vy=sin(a)*rSpd;
      b.r=6;b.life=5;b.maxLife=5;b.type='normal';b.color='#f80';
      b.spawnTime=G.time;b.damage=0;b.pierce=0;
      b.split=false;b.echoed=false;b.baseSpeed=rSpd;b.curve=0;b.pulseAmp=0;
      b.src='rocket';b._homing=true;b._homingDelay=0;
    });
    w.lastFired=G.time;
  }
  // Update homing for active rockets + mini-rockets
  playerBullets.each(b=>{
    if(!b.active||(b.src!=='rocket'&&b.src!=='rocket_mini')||!b._homing)return;
    // Homing delay for cluster mini-rockets
    if(b._homingDelay>0){b._homingDelay-=dt;return}
    const best=nearestEnemy(b.x,b.y,800);
    if(best){
      const turnRate=b.src==='rocket_mini'?4:3.5;
      const nv=steerVelocity(b.vx,b.vy,best.x,best.y,b.x,b.y,turnRate,dt);
      b.vx=nv.vx;b.vy=nv.vy;
    }
  });
}
function drawRocket(w){/* Rockets are drawn via bullet pool */}

// Rocket explosion on enemy hit (called from collision)
function rocketExplode(bx,by){
  const w=G.weapons.find(w=>w.id==='rocket');if(!w)return;
  const blastR=w.blastR+[0,30,50][w.lv.c];
  const kbForce=w.kbForce+[0,40,80,120][w.lv.a];
  const disorient=[.5,.8,1.2,1.5][w.lv.a]||.5;
  burstParticles(bx,by,'#f80',25,250);burstParticles(bx,by,'#ff4',15,180);addShake(8);
  // Store explosion ring for visual
  if(!G._rocketRings)G._rocketRings=[];
  G._rocketRings.push({x:bx,y:by,r:blastR,life:.3,maxLife:.3});
  // Destroy enemy bullets in blast radius
  enemyBullets.each(b=>{if(!b.active)return;
    if(dist(bx,by,b.x,b.y)<blastR){b.active=false;burstParticles(b.x,b.y,'#f80',2,60)}
  });
  // Damage + knockback enemies
  enemies.each(e=>{if(!e.active)return;const d=dist(bx,by,e.x,e.y);
    if(d<blastR+e.r){
      dealDamage(e,1,'rocket');
      const bossMult=e.isBoss?.4:1;
      const a=atan2(e.y-by,e.x-bx);
      e.cc.kbVx=cos(a)*kbForce*bossMult;e.cc.kbVy=sin(a)*kbForce*bossMult;
      e.cc.disorientT=disorient*bossMult;
    }
  });
  // Cluster bombs - fly outward first, then home in
  if(w.lv.b>0){const n=[0,5,7][w.lv.b];for(let i=0;i<n;i++){const a=TAU/n*i;
    playerBullets.spawn(b=>{b.x=bx+cos(a)*10;b.y=by+sin(a)*10;b.vx=cos(a)*220;b.vy=sin(a)*220;b.r=3;b.life=2.0;b.maxLife=2.0;b.type='normal';b.color='#fa0';b.spawnTime=G.time;b.damage=1;b.pierce=0;b.split=false;b.echoed=false;b.baseSpeed=220;b.curve=0;b.pulseAmp=0;b.src='rocket_mini';b._homing=true;b._homingDelay=.35})}}
}

// == LANDMINES ==
function updateMines(w,dt){
  if(!w._mines)w._mines=[];
  const maxM=w.maxMines+[0,1,2][w.lv.b];
  const rad=w.mineR*(1+[0,.35,.7][w.lv.a]);
  const dmg=w.damage+[0,6,12][w.lv.a];
  const cd=max(.55,w.placeCD*(1-stats.cdReduction));
  w.timer-=dt;
  if(w.timer<=0&&w._mines.length<maxM){
    let px=player.x+cos(player.angle)*34,py=player.y+sin(player.angle)*34;
    const near=nearestEnemy(player.x,player.y,330);
    if(near){
      const a=atan2(near.y-player.y,near.x-player.x),d=min(160,dist(player.x,player.y,near.x,near.y)*.5+24);
      px=player.x+cos(a)*d;py=player.y+sin(a)*d;
    }
    w._mines.push({x:px,y:py,r:rad,life:w.mineLife,maxLife:w.mineLife,arm:.32,pulse:Math.random()*TAU});
    w.timer=cd;
  }
  for(let i=w._mines.length-1;i>=0;i--){
    const m=w._mines[i];
    m.life-=dt;m.arm=max(0,m.arm-dt);m.pulse+=dt*7;
    if(m.life<=0){w._mines.splice(i,1);continue}
    if(m.arm>0)continue;
    let trigger=false;
    enemies.each(e=>{if(!trigger&&e.active&&dist(m.x,m.y,e.x,e.y)<m.r+e.r)trigger=true});
    if(!trigger)continue;
    burstParticles(m.x,m.y,'#7f7',22,220);burstParticles(m.x,m.y,'#fff',10,160);addShake(7);
    enemyBullets.each(b=>{if(!b.active)return;if(dist(m.x,m.y,b.x,b.y)<m.r){b.active=false;burstParticles(b.x,b.y,'#7f7',2,80)}});
    enemies.each(e=>{
      if(!e.active)return;
      const d=dist(m.x,m.y,e.x,e.y);
      if(d<m.r+e.r){
        dealDamage(e,dmg,'mines');
        const bossMult=e.isBoss?.4:1,p=(1-d/(m.r+e.r))*130,a=atan2(e.y-m.y,e.x-m.x);
        e.cc.kbVx+=cos(a)*p*bossMult;e.cc.kbVy+=sin(a)*p*bossMult;
        if(w.lv.c>0)e.cc.stunT=max(e.cc.stunT,[0,.2,.32][w.lv.c]*(e.isBoss?.25:1));
      }
    });
    if(w.lv.c>0)spawnStaticField(m.x,m.y,[0,1.6,2.7][w.lv.c],[0,24,36][w.lv.c]);
    w._mines.splice(i,1);
  }
}
function drawMines(w){
  if(!w._mines)return;
  for(let i=0;i<w._mines.length;i++){
    const m=w._mines[i],a=clamp(m.life/m.maxLife,0,1),blink=.55+.45*sin(m.pulse),rr=6+blink*2.5;
    ctx.save();
    strokeRing(m.x,m.y,m.r,'#7f7',1,.18*a);
    ctx.beginPath();ctx.arc(m.x,m.y,rr,0,TAU);ctx.fillStyle='#7f7';ctx.globalAlpha=.55+.25*blink;ctx.fill();
    ctx.beginPath();ctx.arc(m.x,m.y,2.5+blink,0,TAU);ctx.fillStyle='#fff';ctx.globalAlpha=.5*a;ctx.fill();
    if(m.arm>0)strokeRing(m.x,m.y,rr+4*(m.arm/.32),'#fff',1.2,.3);
    ctx.restore();
  }
}

// == PULSE DRONE ==
function updateDrone(w,dt){
  const count=w.droneCount+[0,1,2][w.lv.a];
  const range=w.droneRange;
  const silDur=[1.5,2.5,3.5][w.lv.b];
  const slowAmt=[0,.2,.4][w.lv.c]||0;
  const cd=[1.5,.9,.7][w.lv.d]||1.5;
  // Spawn/manage drones
  while(w._drones.length<count)w._drones.push({angle:TAU/count*w._drones.length,orbitR:60+w._drones.length*15,pulseT:0,x:player.x,y:player.y});
  // Update drone positions - seek nearest enemy, tethered to player
  const maxLeash=250;// max distance from player
  for(let i=0;i<w._drones.length;i++){
    const d=w._drones[i];
    if(!d.x)d.x=player.x;if(!d.y)d.y=player.y;
    d.pulseT=max(0,d.pulseT-dt);
    const nearE=nearestEnemy(d.x,d.y,400);
    const driftSpd=80;
    if(nearE){
      // Move toward nearest enemy
      const toE=atan2(nearE.y-d.y,nearE.x-d.x);
      d.x+=cos(toE)*driftSpd*dt;d.y+=sin(toE)*driftSpd*dt;
    }else{
      // Orbit player if no enemies nearby
      d.angle+=dt*(2.5-i*.3);
      const tgtX=player.x+cos(d.angle)*d.orbitR;
      const tgtY=player.y+sin(d.angle)*d.orbitR;
      d.x=lerp(d.x,tgtX,4*dt);d.y=lerp(d.y,tgtY,4*dt);
    }
    // Leash: pull back toward player if too far
    const dp=dist(d.x,d.y,player.x,player.y);
    if(dp>maxLeash){const toP=atan2(player.y-d.y,player.x-d.x);d.x+=cos(toP)*(dp-maxLeash)*3*dt;d.y+=sin(toP)*(dp-maxLeash)*3*dt}
    // Slow enemy bullets in range
    enemyBullets.each(b=>{if(!b.active)return;
      if(dist(d.x,d.y,b.x,b.y)<range){
        const slow=.4;// 40% speed reduction
        const spd=sqrt(b.vx*b.vx+b.vy*b.vy);
        if(spd>50){const a=atan2(b.vy,b.vx);const ns=spd*(1-slow*dt*3);b.vx=cos(a)*ns;b.vy=sin(a)*ns}
      }
    });
    // Fire pulse at nearby enemies (silence)
    d._fireT=(d._fireT||0)-dt*(1-stats.cdReduction);
    if(d._fireT<=0){
      d._fireT=cd;
      const e=nearestEnemy(d.x,d.y,range+80);
      if(e&&dist(d.x,d.y,e.x,e.y)<range+e.r){
        const bossMult=e.isBoss?.3:1;
        if(!e.isBoss)e.cc.silenceT=max(e.cc.silenceT,silDur*bossMult);
        if(slowAmt>0){e.cc.slowAmt=max(e.cc.slowAmt,slowAmt);e.cc.slowT=max(e.cc.slowT,silDur*bossMult)}
        dealDamage(e,1,'drone');
        d.pulseT=.3;
        burstParticles(d.x,d.y,'#0aa',5,80);
      }
    }
  }
  w.timer=w._drones[0]?w._drones[0]._fireT:0;
}
function drawDrone(w){
  for(const d of w._drones){
    ctx.save();
    // Drone body
    const pulse=d.pulseT>0?1+d.pulseT*2:1;
    ctx.beginPath();ctx.arc(d.x,d.y,6*pulse,0,TAU);
    ctx.fillStyle='#0aa';ctx.globalAlpha=.6;ctx.fill();
    strokeRing(d.x,d.y,6*pulse,'#0ff',1.5,.8);
    // Inner glow
    ctx.beginPath();ctx.arc(d.x,d.y,3*pulse,0,TAU);
    ctx.fillStyle='#fff';ctx.globalAlpha=.5;ctx.fill();
    // Range ring (subtle)
    strokeRing(d.x,d.y,w.droneRange,'#0aa',.5,.1);
    // Pulse ring when firing
    if(d.pulseT>0){
      const pr=w.droneRange*(1-d.pulseT/.3);
      strokeRing(d.x,d.y,pr,'#0ff',2,d.pulseT/.3*.4);
    }
    ctx.restore();
  }
}

// == SHURIKEN ==
function updateShuriken(w,dt){
  const count=w.count+[0,1,2][w.lv.a];
  const markAmp=[.3,.45,.6][w.lv.b];
  const markDur=[3,5,7][w.lv.c];
  const maxBounces=w.bounces+[0,2,2,2][w.lv.d];
  w.timer-=dt*(1-stats.cdReduction);
  if(w.timer<=0){
    w.timer=1.2;
    for(let n=0;n<count;n++){
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active)return;const d=dist(player.x,player.y,e.x,e.y);
        const alreadyTarget=w._shurikens.some(s=>s.target===e);
        if(!alreadyTarget||!best){if(d<bestD){bestD=d;best=e}}
      });
      if(!best)break;
      const a=atan2(best.y-player.y,best.x-player.x);
      w._shurikens.push({x:player.x,y:player.y,vx:cos(a)*1400,vy:sin(a)*1400,target:best,life:4,markAmp,markDur,angle:0,bouncesLeft:maxBounces,hitSet:new Set()});
    }
  }
  for(let i=w._shurikens.length-1;i>=0;i--){
    const s=w._shurikens[i];s.life-=dt;s.angle+=dt*12;
    if(s.life<=0){w._shurikens.splice(i,1);continue}
    if(s.target&&s.target.active){
      const desired=atan2(s.target.y-s.y,s.target.x-s.x);
      const cur=atan2(s.vy,s.vx),diff=normAng(desired-cur),turn=clamp(diff,-12*dt,12*dt);
      const na=cur+turn,spd=sqrt(s.vx*s.vx+s.vy*s.vy);
      s.vx=cos(na)*spd;s.vy=sin(na)*spd;
    }else{
      let best=null,bestD=Infinity;
      enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;const d=dist(s.x,s.y,e.x,e.y);if(d<bestD){bestD=d;best=e}});
      if(best)s.target=best;
    }
    s.x+=s.vx*dt;s.y+=s.vy*dt;
    enemies.each(e=>{if(!e.active||s.hitSet.has(e))return;
      if(dist(s.x,s.y,e.x,e.y)<e.r+6){
        s.hitSet.add(e);
        const bossMult=e.isBoss?.4:1;
        e.cc.markT=max(e.cc.markT,s.markDur*bossMult);
        e.cc.markAmp=max(e.cc.markAmp,s.markAmp);
        dealDamage(e,1,'shuriken');
        burstParticles(s.x,s.y,'#bbb',5,80);
        if(s.bouncesLeft>0){
          s.bouncesLeft--;
          let next=null,nextD=Infinity;
          enemies.each(e2=>{if(!e2.active||s.hitSet.has(e2))return;const d=dist(s.x,s.y,e2.x,e2.y);if(d<nextD){nextD=d;next=e2}});
          if(next){
            s.target=next;
            const a=atan2(next.y-s.y,next.x-s.x),spd=sqrt(s.vx*s.vx+s.vy*s.vy);
            s.vx=cos(a)*spd;s.vy=sin(a)*spd;
            s.life=max(s.life,2);
          }else{w._shurikens.splice(i,1)}
        }else{w._shurikens.splice(i,1)}
      }
    });
  }
}
function drawShuriken(w){
  for(const s of w._shurikens){
    ctx.save();ctx.translate(s.x,s.y);ctx.rotate(s.angle);
    ctx.beginPath();
    for(let i=0;i<4;i++){const a=TAU/4*i;
      ctx.moveTo(0,0);ctx.lineTo(cos(a)*8,sin(a)*8);ctx.lineTo(cos(a+.4)*4,sin(a+.4)*4);
    }
    ctx.strokeStyle='#bbb';ctx.lineWidth=2;ctx.globalAlpha=.8;ctx.stroke();
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='#fff';ctx.fill();
    ctx.restore();
  }
}

// == PASSIVES ==
const PASSIVE_ROWS=[
  ['regen','REGENERATION','#4f4',3,['Heal 1HP/14s','1HP/8s','1HP/8s + emergency heal']],
  ['speed','SPEED BOOST','#4f4',3,['+15% speed','+30%','+40% + 8% dodge']],
  ['cooldown','COOLDOWN REDUCTION','#48f',3,['-12% all CDs','-20%','-25% + faster weapons']],
  ['damage','POWER SURGE','#f44',2,['+30% damage','+50% damage']],
];
const PASSIVE_DEFS={};
for(let i=0;i<PASSIVE_ROWS.length;i++){const p=PASSIVE_ROWS[i];PASSIVE_DEFS[p[0]]={name:p[1],color:p[2],maxLv:p[3],desc:p[4]}}
const PASSIVE_KEYS=PASSIVE_ROWS.map(p=>p[0]);
const IMPL_PASSIVES=PASSIVE_KEYS;

// == BOSS SYSTEM ==
const BOSS_COLORS=['#f66','#f8c','#c8f','#8cf','#a0f','#ff8'];
const BOSS_SHAPES=['circle','square','triangle'];
const MOD_SHIELD=1,MOD_RAGE=2,MOD_TWIN=4,MOD_WARP=8,MOD_SUMMON=16;
const MOD_EXCLUSIVE=MOD_TWIN|MOD_WARP;
const BOSS_MOD_POOL=[MOD_SHIELD,MOD_RAGE,MOD_TWIN,MOD_WARP,MOD_SUMMON];
const BOSS_CORE_MODS=[MOD_SHIELD,MOD_WARP,MOD_SUMMON,MOD_RAGE];
const ATK_RADIAL=0,ATK_WALL=1,ATK_CURVE=2,ATK_SPREAD=3,ATK_LASER=4,ATK_DASH=5;
const BOSS_ATTACK_POOL=[ATK_RADIAL,ATK_WALL,ATK_CURVE,ATK_SPREAD,ATK_LASER,ATK_DASH];
const BOSS_NAME_PREFIX=['Void','Astral','Iron','Crimson','Aether','Obsidian','Radiant','Grim'];
const BOSS_NAME_CORE=['Warden','Revenant','Harbinger','Sentinel','Seraph','Tyrant','Overseer','Monarch'];
const BOSS_NAME_SUFFIX=['Prime','Ascendant','Omega','the Hollow','the Unbound','of Ruin','of Echoes','Mk-II'];
const BOSS_ATK_FN=[
  function(en){EFIRE.bossRadial(en)},
  function(en){EFIRE.bossWall(en)},
  function(en){for(let i=0;i<5;i++){const a=en.angle+TAU/5*i,s=205;fireBossEB(en.x,en.y,cos(a)*s,sin(a)*s,4,en.color,'loop',3.4,{loopAmp:160,loopFreq:1.15,loopBaseAng:a})}},
  function(en){const a=atan2(player.y-en.y,player.x-en.x);for(let i=-3;i<=3;i++)fireBossEB(en.x,en.y,cos(a+i*.11)*220,sin(a+i*.11)*220,4,en.color,'normal',2.6)},
  function(en,ai){
    ai.laserSpin+=.36;const beams=ai.enraged?5:3;
    for(let i=0;i<beams;i++){
      const a=ai.laserSpin+TAU/beams*i;
      spawnBossLaser({owner:en,angle:a,length:max(W,H)*1.9,width:ai.enraged?28:22,life:ai.enraged?2.1:1.8,color:en.color,rotSpeed:ai.enraged?.75:.45,warn:ai.enraged?1.15:1,warnColor:'#ff9f66'});
    }
  },
  function(en,ai){
    if(ai._dashStrike)return;
    const da=atan2(player.y-en.y,player.x-en.x),dd=clamp(dist(en.x,en.y,player.x,player.y)+52+(ai.enraged?20:0),180,360);
    ai._dashStrike={phase:'tele',t:1,maxT:1,sx:en.x,sy:en.y,ex:en.x+cos(da)*dd,ey:en.y+sin(da)*dd,a:da,burst:false};
    burstParticles(en.x,en.y,en.color,8,130);
  },
];
function makeBossCC(){return{stunT:0,silenceT:0,rootT:0,slowAmt:0,slowT:0,fearT:0,markT:0,markAmp:0,kbVx:0,kbVy:0,disorientT:0,bleedDmg:0,bleedT:0}}
function pickUnique(arr,n){const a=arr.slice();for(let i=a.length-1;i>0;i--){const j=ri(0,i);[a[i],a[j]]=[a[j],a[i]]}return a.slice(0,n)}
function shuffleInPlace(arr){for(let i=arr.length-1;i>0;i--){const j=ri(0,i);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr}
function nextBossCoreMod(){
  if(!G._bossModQueue||G._bossModQueue.length===0)G._bossModQueue=shuffleInPlace(BOSS_CORE_MODS.slice());
  return G._bossModQueue.pop();
}
function generateBossName(mods){
  if(mods&MOD_TWIN)return 'Twin '+rPick(BOSS_NAME_CORE)+' '+rPick(['Apex','Prime','Ascendant']);
  return rPick(BOSS_NAME_PREFIX)+' '+rPick(BOSS_NAME_CORE)+' '+rPick(BOSS_NAME_SUFFIX);
}
function initBossEntity(e,cfg,side){
  const a=rAngle()+side*PI,sd=max(CX,CY)+100;
  e.x=player.x+cos(a)*sd;e.y=player.y+sin(a)*sd;
  e.shape=cfg.shape;e.color=hostileColor(cfg.color);e.tier='boss';e.isBoss=true;e.bossKind='generated';
  e.bossShape=cfg.shape;e.bossAccessory=cfg.accessory;e.bossName=cfg.name;
  e.bossMods=cfg.mods;e.bossAttacks=cfg.attacks;
  e.r=cfg.r;e.hp=cfg.hp;e.maxHp=cfg.hp;
  e.fireCD=cfg.fireCD;e.fireTimer=.45+side*.2;e.hitFlash=0;e.angle=0;e.spawnTime=G.time;
  e.moveParams={speed:cfg.moveSpeed};e.fireParams={count:10,offset:0};
  e.cc=makeBossCC();e.shieldHP=0;e._dashInvuln=0;
  e._role=((cfg.mods&MOD_TWIN)&&side===1)?'melee':'ranged';
  e._twinIdx=side;e._twinPartner=null;
  e.moveType='chaser';e.firePattern='bossAimed';
}
function makeRandomBossAI(cfg){
  return{
    timer:0,attackIdx:0,laserSpin:rAngle(),shieldNodes:[],enraged:false,linkBeam:false,linkTimer:0,dashTimer:0,warpTimer:0,warpCD:3,_portals:[],_warpTele:null,_dashStrike:null,summonTimer:0,
    update(en,dt){
      this.timer+=dt;en.angle+=dt*(this.enraged?1.8:1.1);
      if(this._dashStrike){
        const ds=this._dashStrike;
        if(ds.phase==='tele'){
          ds.t-=dt;
          en._dashInvuln=max(en._dashInvuln,.1);
          en._dashTele={t:ds.t,maxT:ds.maxT,tx:ds.ex,ty:ds.ey};
          if(ds.t<=0){
            ds.phase='dash';
            ds.t=.32;ds.maxT=.32;
            ds.sx=en.x;ds.sy=en.y;
            en._dashTele=null;
          }
        }else{
          ds.t-=dt;
          const p=clamp(1-ds.t/ds.maxT,0,1),ep=1-(1-p)*(1-p);
          en.x=lerp(ds.sx,ds.ex,ep);en.y=lerp(ds.sy,ds.ey,ep);
          en._dashInvuln=max(en._dashInvuln,.3);
          if((this.timer*45|0)%2===0)burstParticles(en.x,en.y,en.color,2,70);
          if(ds.t<=0){
            en.x=ds.ex;en.y=ds.ey;
            if(!ds.burst){
              ds.burst=true;
              burstParticles(en.x,en.y,en.color,10,160);
              for(let i=0;i<10;i++){const a=TAU/10*i+ds.a*.35;fireBossEB(en.x,en.y,cos(a)*230,sin(a)*230,4,en.color,'normal',.9)}
            }
            this._dashStrike=null;
          }
        }
        return;
      }
      const toP=atan2(player.y-en.y,player.x-en.x),d=dist(en.x,en.y,player.x,player.y);
      const baseSp=en.moveParams.speed;
      if(en._role==='melee'){
        const orbitR=170+en._twinIdx*20;
        if(d>orbitR+25){en.x+=cos(toP)*baseSp*dt;en.y+=sin(toP)*baseSp*dt}
        else{const ta=toP+(en._twinIdx===0?PI/2:-PI/2);en.x+=cos(ta)*baseSp*.7*dt;en.y+=sin(ta)*baseSp*.7*dt}
      }else{
        en.x+=cos(toP)*baseSp*.35*dt;en.y+=sin(toP)*baseSp*.35*dt;
      }
      if((cfg.mods&MOD_SHIELD)&&en.hp<en.maxHp*.6&&this.shieldNodes.length===0){
        for(let i=0;i<4;i++)this.shieldNodes.push({angle:TAU/4*i,hp:12,lastHit:G.time});
        G.bannerTimer=.9;G.bannerText='BOSS SHIELD NODES';G.bannerColor=en.color;
        G.waveModTimer=4;
        G.waveModText='SHIELD NODES: break the glowing hex shields around the boss. Boss is invincible until all are destroyed.';
      }
      for(const sn of this.shieldNodes)sn.angle+=dt*.7;
      if((cfg.mods&MOD_RAGE)&&en.hp<en.maxHp*.35&&!this.enraged){
        this.enraged=true;en.fireCD*=.72;
        if(!en._baseColor)en._baseColor=en.color;
        en.color='#f33';
        G.bannerTimer=1.1;G.bannerText='BOSS ENRAGED';G.bannerColor=en.color;
      }
      if(cfg.mods&MOD_TWIN){
        this.linkTimer+=dt;this.linkBeam=(this.linkTimer%3.6)<2.2;
      }
      if(cfg.mods&MOD_WARP){
        if(this._warpTele){
          this._warpTele.t-=dt;
          if(this._warpTele.t<=0){
            const wt=this._warpTele;
            this._warpTele=null;
            const fromX=en.x,fromY=en.y;
            en.x=wt.toX;en.y=wt.toY;
            for(let i=0;i<8;i++){const pa=TAU/8*i;fireBossEB(fromX,fromY,cos(pa)*150,sin(pa)*150,4,en.color,'normal',2.8)}
            this._portals.push({x1:fromX,y1:fromY,x2:wt.toX,y2:wt.toY,life:.25});
            burstParticles(fromX,fromY,en.color,10,120);burstParticles(wt.toX,wt.toY,en.color,10,120);
          }
        }else{
          this.warpTimer+=dt;
          if(this.warpTimer>this.warpCD){
            this.warpTimer=0;
            const ta=rAngle(),td=rr(120,240);
            this._warpTele={toX:player.x+cos(ta)*td,toY:player.y+sin(ta)*td,t:1,maxT:1};
          }
        }
      }
      for(let i=this._portals.length-1;i>=0;i--){this._portals[i].life-=dt;if(this._portals[i].life<=0)this._portals.splice(i,1)}
      if((cfg.mods&MOD_SUMMON)&&G.waveState==='encounter'){
        this.summonTimer+=dt;
        if(this.summonTimer>(this.enraged?6:8)){
          this.summonTimer=0;
          const n=this.enraged?2:1;
          for(let i=0;i<n;i++){const aa=rAngle(),dd=rr(90,170);spawnEnemy('small',{x:en.x+cos(aa)*dd,y:en.y+sin(aa)*dd,moveType:'converge',moveParams:{speed:145},hpMult:1.1,fireMult:1.2,color:en.color})}
        }
      }
    },
    fire(en){
      if(en._role==='melee')return;
      const atk=cfg.attacks[this.attackIdx%cfg.attacks.length];this.attackIdx++;
      const fire=BOSS_ATK_FN[atk];if(fire)fire(en,this);
      if((cfg.mods&MOD_WARP)&&this._portals.length&&atk!==ATK_LASER){
        for(const p of this._portals){for(let i=0;i<5;i++){const a=TAU/5*i;fireBossEB(p.x1,p.y1,cos(a)*130,sin(a)*130,3.5,en.color,'curve',2.6,{curve:.3})}}
      }
    }
  };
}
function makeRandomBossConfig(){
  let mods=nextBossCoreMod();
  const targetMods=min(4,1+floor(max(0,G.wave-1)/4)); // 1 early, then slowly increases
  let modCount=1;
  while(modCount<targetMods){
    let pool=BOSS_MOD_POOL.filter(m=>!(mods&m));
    if(mods&MOD_EXCLUSIVE)pool=pool.filter(m=>(m&MOD_EXCLUSIVE)===0);
    if(!pool.length)break;
    mods|=rPick(pool);
    modCount++;
  }
  let attacks=pickUnique(BOSS_ATTACK_POOL,(mods&MOD_TWIN)?2:3);
  const shape=rPick(BOSS_SHAPES),color=rPick(BOSS_COLORS),accessory=ri(0,2);
  const hp=floor((114+G.wave*85+G.wave*G.wave*22+ri(-40,60))*.5),r=ri(34,48),fireCD=rr(.9,1.45)*max(.52,1-G.wave*.02),moveSpeed=rr(70,105)+G.wave*1.3;
  const name=generateBossName(mods);
  return{mods,attacks,shape,color,accessory,hp,r,fireCD,moveSpeed,name};
}
function spawnBoss(){
  const cfg=makeRandomBossConfig();
  enemies.each(e=>{if(e.active&&!e.isBoss)e.active=false});
  enemyBullets.clear();
  const pair=(cfg.mods&MOD_TWIN)!==0;
  const spawned=[];
  for(let side=0;side<(pair?2:1);side++){
    enemies.spawn(e=>{
      initBossEntity(e,cfg,side);
      e.bossAI=makeRandomBossAI(cfg);
      spawned.push(e);
    });
  }
  if(spawned.length===2){
    spawned[0]._twinPartner=spawned[1];spawned[1]._twinPartner=spawned[0];
    G._twinBoss=spawned;
  }else G._twinBoss=null;
  G.bossEntity=spawned[0];
  G.bannerTimer=2;G.bannerText='BOSS: '+cfg.name;G.bannerColor=cfg.color;
}

// == FORMATIONS ==
// == WAVE DIRECTOR ==
let spawnTimer=0;
function updateDirector(dt){
  if(G.waveState==='spawning'){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const maxE=6+G.wave*2.4+G.difficulty*1.2;
      if(enemies.count()<maxE){spawnEnemy(Math.random()<.1+G.wave*.02?'elite':'small')}
      spawnTimer=max(.16,1.65-G.wave*.11-G.difficulty*.1-G.wave*G.wave*.0015);
    }
    // Check quota
    if(G.waveKills>=G.waveQuota){
      G.waveState='encounter';
      G._bossSpawnPending=true;
      G.killFlash=max(G.killFlash,.16);
      setTimeout(()=>{spawnBoss();G._bossSpawnPending=false},120);
    }
  }else if(G.waveState==='encounter'){
    // Check if boss enemies are dead
    if(G._bossSpawnPending)return;
    let encounterDone=true;
    enemies.each(e=>{if(e.isBoss)encounterDone=false});
    if(encounterDone){
      G.waveState='clear';
      enemyBullets.clear();
      burstParticles(player.x,player.y,'#fff',30,250);
      addShake(10);trigSlowMo(.3,.3);
      G.bannerTimer=2;G.bannerText='WAVE '+G.wave+' CLEAR!';G.bannerColor='#0ff';
      setTimeout(()=>startNextWave(),2000);
    }
  }
  // Freeze timer
  if(G.frozen){G.freezeTimer-=dt;if(G.freezeTimer<=0)G.frozen=false}
  // Phase tick
  if(currentPhase)currentPhase.tick(dt);
}

function startNextWave(){
  G.wave++;G.waveKills=0;
  G.waveQuota=min(16,4+G.wave*2);// shorter waves
  G.difficulty=.8+G.wave*.5+G.wave*G.wave*.02;
  G.waveState='spawning';
  // Apply new phase
  if(currentPhase)currentPhase.unapply();
  applyPhase(selectPhase());
  G.waveBannerTimer=2;G.waveBannerText='WAVE '+G.wave;
  G.waveBannerSub=currentPhase?currentPhase.name:'';
  G.waveModTimer=3;
  G.waveModText=currentPhase?currentPhase.desc:'';
}

// == COLLISION ==
function dealDamage(e,rawDmg,src,forceCrit){
  if(!e.active)return;
  if(e._dashInvuln>0)return;
  let dmg=rawDmg;
  const isShuriken=src==='shuriken';
  if(isShuriken)dmg=1;
  if(!isShuriken&&e.cc.markAmp>0)dmg*=(1+e.cc.markAmp);
  let isCrit=forceCrit||false;
  const critChance=stats.critChance+(G.lucky?.08:0);
  if(!isShuriken&&!isCrit&&critChance>0&&Math.random()<critChance){isCrit=true;dmg*=stats.critMult}
  if(!isShuriken)dmg*=stats.dmgMult;
  if(!isShuriken&&e.cc.markT>0)dmg*=(1+e.cc.markAmp);
  // Shield nodes active => boss is invincible until nodes are broken.
  if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
    let target=null,bestHp=1/0,nx=0,ny=0;
    for(const sn of e.bossAI.shieldNodes){
      if(sn.hp<=0)continue;
      if(sn.hp<bestHp){bestHp=sn.hp;target=sn}
    }
    if(target){
      nx=e.x+cos(target.angle)*(e.r+24);ny=e.y+sin(target.angle)*(e.r+24);
      const nd=max(1,dmg*.9);
      target.hp=max(0,target.hp-nd);
      target.lastHit=G.time;
      burstParticles(nx,ny,'#9ef',8,140);
      spawnDmgNum(nx,ny,nd|0,false);
      if(!e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        G.bannerTimer=1.2;G.bannerText='SHIELD BROKEN';G.bannerColor='#9ef';
      }
    }
    return;
  }
  e.hp-=dmg;e.hitFlash=1;
  spawnDmgNum(e.x,e.y,dmg|0,isCrit);
  burstParticles(e.x,e.y,e.color,3,80);
  if(e.hp<=0)killEnemy(e);
}
function killEnemy(e){
  if(!e.active)return;
  e.active=false;
  // XP
  const normalEnemyXp=15;
  const bossEnemyXp=450;
  let xpBase=e.isBoss?bossEnemyXp:e.tier==='elite'?55:normalEnemyXp;
  const xpGain=xpBase*stats.xpMult*(G.lucky?1.25:1);
  G.xp+=xpGain;
  // Check level up
  while(G.xp>=G.xpToNext&&G.xpToNext>0){G.xp-=G.xpToNext;G.level++;G.xpToNext=floor((100+G.level*100)*XP_REQ_SCALE);G.levelUpQueue++}
  // Kill tracking
  G.totalKills++;G.waveKills++;
  // Kill flash for big enemies
  if(e.isBoss||e.tier==='elite')G.killFlash=.05;
  // Particles (shape-specific)
  if(e.shape==='circle'){for(let i=0;i<12;i++){const a=TAU/12*i;spawnParticle(e.x,e.y,cos(a)*200,sin(a)*200,e.color,.3,2)}}
  else if(e.shape==='square'){for(let i=0;i<8;i++){const a=PI/4+TAU/8*i;spawnParticle(e.x+cos(a)*e.r,e.y+sin(a)*e.r,cos(a)*150,sin(a)*150,e.color,.3,3)}}
  else{for(let i=0;i<3;i++){const a=TAU/3*i;for(let j=0;j<4;j++)spawnParticle(e.x,e.y,cos(a+rr(-.3,.3))*(100+j*50),sin(a+rr(-.3,.3))*(100+j*50),e.color,.3,2)}}
  if(e.isBoss){burstParticles(e.x,e.y,'#fff',40,300);burstParticles(e.x,e.y,e.color,30,250);addShake(15);trigSlowMo(.5,.3);
    // Handle twins: switch to partner if still alive
    if(G._twinBoss&&e._twinIdx!==undefined){
      const partner=e._twinPartner;
      if(partner&&partner.active){G.bossEntity=partner}else{G.bossEntity=null;G._twinBoss=null}
    }else{G.bossEntity=null}
  }
  else{burstParticles(e.x,e.y,e.color,15,180);addShake(e.tier==='elite'?8:3);trigSlowMo(.06,.5)}
}

function checkCollisions(){
  if(!player.alive)return;
  // Player bullets vs enemies
  playerBullets.each(b=>{
    if(!b.active)return;
    enemies.each(e=>{
      if(!e.active)return;
      // Sentinel shield nodes can be targeted directly by bullets.
      if(e.isBoss&&e.bossAI&&e.bossAI.shieldNodes&&e.bossAI.shieldNodes.some(sn=>sn.hp>0)){
        for(const sn of e.bossAI.shieldNodes){
          if(sn.hp<=0)continue;
          const nx=e.x+cos(sn.angle)*(e.r+24),ny=e.y+sin(sn.angle)*(e.r+24);
          if(dist(b.x,b.y,nx,ny)<b.r+10){
            sn.hp=max(0,sn.hp-max(1,b.damage*1.1));
            sn.lastHit=G.time;
            burstParticles(nx,ny,'#f99',6,120);
            b.active=false;
            return;
          }
        }
      }
      if(dist(b.x,b.y,e.x,e.y)<b.r+e.r){
        if(b.src==='rocket'){b.active=false;rocketExplode(b.x,b.y);return}
        if(b.src==='rocket_mini'){b.active=false;// mini-rockets do small explosion, no cluster
          burstParticles(b.x,b.y,'#fa0',8,100);addShake(2);
          enemies.each(e2=>{if(!e2.active)return;if(dist(b.x,b.y,e2.x,e2.y)<40+e2.r){dealDamage(e2,1,'rocket');const a2=atan2(e2.y-b.y,e2.x-b.x);e2.cc.kbVx+=cos(a2)*80;e2.cc.kbVy+=sin(a2)*80}});
          return}
        dealDamage(e,b.damage,b.src||'bullet');
        if(b.pierce>0)b.pierce--;
        else if(!G.pierce)b.active=false;
      }
    });
  });
  // Enemy bullets vs player
  if(player.invuln<=0){
    enemyBullets.each(b=>{
      if(!b.active)return;
      if(dist(b.x,b.y,player.x,player.y)<b.r+player.r){
        // Dodge chance
        if(stats.dodgeChance>0&&Math.random()<stats.dodgeChance)return;
        b.active=false;damagePlayer();
      }
    });
    enemies.each(e=>{
      if(!e.active)return;
      if(dist(e.x,e.y,player.x,player.y)<e.r+player.r){
        damagePlayer();
      }
    });
  }
}
function damagePlayer(){
  if(player.invuln>0||!player.alive)return;
  player.hp--;player.invuln=CFG.invulnDur;player.hitFlash=.3;
  addShake(10);burstParticles(player.x,player.y,'#0ff',15,200);
  if(player.hp<=0){
    player.alive=false;
    burstParticles(player.x,player.y,'#0ff',40,300);burstParticles(player.x,player.y,'#fff',20,250);
    addShake(15);
    keys.clear();mouseDown=false;rightDown=false;pendingClick=null;
    G.gameOverFade=0;
    state='dying';
  }
}

// == UPGRADE SYSTEM ==
let upgradeChoices=[];
function generateUpgradeChoices(){
  const opts=[];
  // Weapon upgrades for held weapons
  for(const w of G.weapons){
    const def=WDEFS[w.id];if(!def)continue;
    for(const u of def.upgrades){
      if(w.lv[u.id]<u.maxLv)opts.push({type:'weaponUpg',weaponId:w.id,upgId:u.id,def:u,wdef:def,curLv:w.lv[u.id]});
    }
  }
  // New CC weapons (max 2 CC = 3 total weapons)
  const ccCount=G.weapons.filter(w=>WDEFS[w.id].type==='cc').length;
  if(ccCount<2){
    const held=G.weapons.map(w=>w.id);
    for(const k of IMPLEMENTED_CC)if(!held.includes(k))opts.push({type:'newWeapon',weaponId:k,wdef:WDEFS[k]});
  }
  // Passive upgrades (max 3 passives)
  let passiveCount=0;
  for(let i=0;i<IMPL_PASSIVES.length;i++)if((G.passives[IMPL_PASSIVES[i]]|0)>0)passiveCount++;
  for(const k of IMPL_PASSIVES){
    const curLv=G.passives[k]||0;
    const def=PASSIVE_DEFS[k];if(!def)continue;
    if(curLv>0&&curLv<def.maxLv)opts.push({type:'passiveUpg',passiveId:k,def,curLv});
    else if(curLv===0&&passiveCount<3)opts.push({type:'newPassive',passiveId:k,def});
  }
  // Shuffle and pick up to 5 unique options
  for(let i=opts.length-1;i>0;i--){const j=ri(0,i);[opts[i],opts[j]]=[opts[j],opts[i]]}
  upgradeChoices=opts.slice(0,5);
  // If no real upgrades left, loop stage-1 speed/damage upgrades.
  if(upgradeChoices.length<5){
    while(upgradeChoices.length<5){
      const id=(upgradeChoices.length&1)?'speed':'damage';
      upgradeChoices.push({type:'loopPassive',passiveId:id,def:PASSIVE_DEFS[id]});
    }
  }
}
function selectUpgrade(idx){
  const c=upgradeChoices[idx];if(!c)return;
  if(c.type==='weaponUpg'){
    const w=G.weapons.find(w=>w.id===c.weaponId);if(w)w.lv[c.upgId]++;}
  else if(c.type==='newWeapon'){G.weapons.push(createWeaponState(c.weaponId))}
  else if(c.type==='newPassive'){G.passives[c.passiveId]=1}
  else if(c.type==='passiveUpg'){G.passives[c.passiveId]++}
  else if(c.type==='loopPassive'){const k=c.passiveId==='speed'?'_speedLoop':'_damageLoop';G.passives[k]=(G.passives[k]|0)+1}
  recomputeStats();
  G.levelUpQueue--;
  if(G.levelUpQueue>0){generateUpgradeChoices();state='levelUp';G.refreshAvailable=1}
  else state='playing';
}
function drawUpgradeScreen(ease){
  ease=ease||1;
  ctx.save();ctx.globalAlpha=ease;drawText('LEVEL UP',CX,CY-140,22,'#ff0','center','middle');ctx.restore();
  const n=min(5,upgradeChoices.length),cw=150,ch=140,g=12,total=cw*n+g*(n-1),sx=CX-total/2,sy=CY-60;
  function drawWrap(t,cx,top,w,maxLines){
    ctx.save();ctx.font='bold 9px monospace';
    const words=(t||'').split(/\s+/).filter(Boolean),lines=[];let line='';
    for(let i=0;i<words.length;i++){
      const next=line?line+' '+words[i]:words[i];
      if(ctx.measureText(next).width>w&&line){lines.push(line);line=words[i]}
      else line=next;
    }
    if(line)lines.push(line);
    const shown=lines.slice(0,maxLines);
    if(lines.length>maxLines&&shown.length)shown[shown.length-1]=shown[shown.length-1].replace(/\.*$/,'')+'...';
    ctx.textAlign='center';ctx.textBaseline='top';ctx.fillStyle='#9aa';
    for(let i=0;i<shown.length;i++)ctx.fillText(shown[i],cx,top+i*11);
    ctx.restore();
  }
  for(let i=0;i<n;i++){
    const c=upgradeChoices[i],x=sx+i*(cw+g),y=sy;
    const hov=mouseX>=x&&mouseX<=x+cw&&mouseY>=y&&mouseY<=y+ch;
    let col='#0ff',name='',desc='';
    if(c.type==='weaponUpg'){col=c.wdef.color;name=c.wdef.name+': '+c.def.name;desc=c.def.desc[c.curLv]||''}
    else if(c.type==='newWeapon'){col=c.wdef.color;name='NEW '+c.wdef.name;desc=c.wdef.cc?('CC: '+c.wdef.cc):c.wdef.desc}
    else if(c.type==='newPassive'){col=c.def.color;name='NEW '+c.def.name;desc=c.def.desc[0]}
    else if(c.type==='passiveUpg'){col=c.def.color;name=c.def.name;desc=c.def.desc[c.curLv]||''}
    else if(c.type==='loopPassive'){col=c.def.color;name=c.def.name;desc=c.def.desc[0]}
    drawPanel(x,y,cw,ch,'rgba(8,16,24,.9)',hov?'#fff':col,hov?2:1.2,hov?1:.78);
    drawText(name,x+cw/2,y+24,10,hov?'#fff':col,'center','middle');
    drawWrap(desc,x+cw/2,y+56,cw-16,5);
    drawText('['+(i+1)+']',x+cw/2,y+ch-14,12,'#666','center','middle');
  }
  drawText(G.refreshAvailable>0?('[R] Reroll ('+G.refreshAvailable+')'):'[R] No rerolls',CX,sy+ch+20,13,G.refreshAvailable>0?'#4f4':'#666','center','middle');
}

// == SCANLINES ==
function drawScanlines(){ctx.save();ctx.fillStyle='#000';ctx.globalAlpha=.04;for(let y=0;y<H;y+=4)ctx.fillRect(0,y,W,1);ctx.restore()}

// == VIGNETTE ==
function drawVignette(){
  const grd=ctx.createRadialGradient(CX,CY,min(W,H)*.3,CX,CY,min(W,H)*.7);
  grd.addColorStop(0,'rgba(0,0,0,0)');
  const lowHP=player.hp<=1&&player.alive;
  grd.addColorStop(1,lowHP?'rgba(80,0,0,0.5)':'rgba(0,0,0,0.35)');
  ctx.save();ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);ctx.restore();
}
// == HUD ==
function drawHUD(){
  const topW=min(W-16,560),topH=54,topX=CX-topW/2,topY=10;
  const hpProg=clamp(player.hp/max(1,player.maxHp),0,1),xpProg=clamp(G.xp/G.xpToNext,0,1);
  const hpCol=hpProg>.5?'#0ef':hpProg>.25?'#fd4':'#f55';
  drawPanel(topX,topY,topW,topH,'rgba(0,0,0,.55)','rgba(255,255,255,.15)',1);
  const hpX=topX+42,hpY=topY+9,hpW=topW-54,hpH=12,seg=10,gap=2,segW=(hpW-gap*(seg-1))/seg;
  for(let i=0;i<seg;i++){
    const x=hpX+i*(segW+gap),fill=clamp(hpProg*seg-i,0,1);
    ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(x,hpY,segW,hpH);
    if(fill>0){ctx.fillStyle=hpCol;ctx.fillRect(x,hpY,segW*fill,hpH)}
    ctx.strokeStyle='rgba(255,255,255,.24)';ctx.strokeRect(x,hpY,segW,hpH);
  }
  const xpY=hpY+hpH+6;
  ctx.fillStyle='rgba(18,18,18,.95)';ctx.fillRect(hpX,xpY,hpW,9);
  ctx.fillStyle='#fd4';ctx.fillRect(hpX,xpY,hpW*xpProg,9);
  ctx.strokeStyle='rgba(255,223,74,.3)';ctx.strokeRect(hpX,xpY,hpW,9);
  drawText('HP',topX+12,hpY,10,'#dff');drawText('XP',topX+12,xpY-1,10,'#fd4');
  const sec=(G.time%60)|0,minu=(G.time/60)|0;
  drawText('TIME '+minu+':'+(sec<10?'0':'')+sec,topX+12,topY+41,9,'#8ea');
  if(currentPhase)drawText(currentPhase.name,topX+topW-12,topY+41,9,currentPhase.color,'right');
  const by=topY+topH+8,bw=min(W-80,460),bx=CX-bw/2;
  if(G.bossEntity&&G.bossEntity.active){
    const e=G.bossEntity,bh=12,p=e.hp/e.maxHp;
    drawText(e.bossName||'BOSS',CX,by+16,11,e.color,'center','top');
    drawPanel(bx,by,bw,bh,'#222','rgba(255,80,80,.6)',1);
    ctx.fillStyle='#c33';ctx.fillRect(bx,by,bw*p,bh);
  }else if(G.waveState==='spawning'){
    const p=clamp(G.waveKills/G.waveQuota,0,1);
    drawPanel(bx,by,bw,7,'rgba(20,20,20,.92)','rgba(0,255,255,.32)',1);
    ctx.fillStyle='#0ff';ctx.fillRect(bx,by,bw*p,7);
    drawText('WAVE PROGRESS',CX,by+10,8,'#9cd','center','top');
  }
  const CD={chain:.8,rocket:2.2,mines:2.1,shuriken:1.2,drone:1.5},sw=52,start=CX-(max(1,G.weapons.length)*sw)/2+sw/2;
  for(let i=0;i<G.weapons.length;i++){
    const w=G.weapons[i],d=WDEFS[w.id],x=start+i*sw,y=H-46;
    drawPanel(x-18,y-12,36,24,'rgba(0,0,0,.5)',d.color,1);
    drawText(d.name.charAt(0),x,y-1,12,d.color,'center','middle');
    const mc=CD[w.id];if(mc&&w.timer!==undefined){const p=clamp(1-w.timer/mc,0,1);ctx.fillStyle='rgba(0,0,0,.55)';ctx.fillRect(x-18,y+14,36,3);ctx.fillStyle=d.color;ctx.fillRect(x-18,y+14,36*p,3)}
  }
  // Banner
  if(G.bannerTimer>0){G.bannerTimer-=1/60;ctx.save();ctx.globalAlpha=min(1,G.bannerTimer*2);
    drawText(G.bannerText,CX,CY-60,24,G.bannerColor,'center','middle');ctx.restore()}
  // Wave banner
  if(G.waveBannerTimer>0){G.waveBannerTimer-=1/60;const s=min(1,G.waveBannerTimer);
    ctx.save();ctx.globalAlpha=s;const sz=30+20*(1-s);
    drawText(G.waveBannerText,CX,CY-30,sz,'#fff','center','middle');
    if(G.waveBannerSub)drawText(G.waveBannerSub,CX,CY+10,16,currentPhase?currentPhase.color:'#888','center','middle');
    ctx.restore()}
  // Bottom wave modifier description popup
  if(G.waveModTimer>0&&G.waveModText){
    G.waveModTimer-=1/60;
    const a=clamp(G.waveModTimer/3,0,1);
    const boxW=min(W-40,720),boxH=50,boxX=CX-boxW/2,boxY=H-136;
    drawPanel(boxX,boxY,boxW,boxH,'#000',currentPhase?currentPhase.color:'#aaa',1.4,.24*a);
    drawPanel(boxX,boxY,boxW,boxH,null,currentPhase?currentPhase.color:'#aaa',1.4,.4*a);
    drawText('MODIFIER: '+G.waveModText,CX,boxY+16,16,currentPhase?currentPhase.color:'#9ab','center','top');
  }
}

// == SCREENS ==
let titleTime=0;
function drawTitle(dt){
  titleTime+=dt;
  drawMenuBg(dt,.28);
  ctx.save();ctx.globalAlpha=.7+sin(titleTime*3)*.3;drawText('NEON PHASES',CX,CY-80,42,'#0ff','center','middle');ctx.restore();
  if((titleTime*2|0)%2)drawText('Press ENTER to Start',CX,CY+12,16,'#fff','center','middle');
  drawScanlines();
}
function drawWeaponSelect(dt){
  drawMenuBg(dt,.35);
  drawText('CHOOSE YOUR WEAPON',CX,60,24,'#0ff','center','middle');
  const n=STARTER_KEYS.length;
  const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
  function drawStarterIcon(id,x,y,col,hover){
    const s=hover?1.1:1;
    ctx.save();ctx.translate(x,y);ctx.scale(s,s);ctx.globalAlpha=.92;
    if(id==='dagger'){
      glowPoly([{x:0,y:-14},{x:8,y:8},{x:0,y:4},{x:-8,y:8}],col,true,4);
    }else if(id==='sword'){
      glowPoly([{x:-3,y:12},{x:3,y:12},{x:2,y:-12},{x:0,y:-18},{x:-2,y:-12}],col,true,4);
      ctx.beginPath();ctx.moveTo(-7,10);ctx.lineTo(7,10);ctx.strokeStyle=col;ctx.lineWidth=2;ctx.stroke();
    }else if(id==='bow'){
      drawGlowArc(-2,0,12,-PI*.55,PI*.55,col,2);
      ctx.beginPath();ctx.moveTo(-10,0);ctx.lineTo(10,0);ctx.strokeStyle=col;ctx.lineWidth=1.8;ctx.stroke();
      glowPoly([{x:12,y:0},{x:4,y:-4},{x:4,y:4}],col,true,3);
    }
    ctx.restore();
  }
  function drawCardDesc(text,cx,top,w,maxLines){
    ctx.save();ctx.font='bold 9px monospace';
    const words=(text||'').split(/\s+/).filter(Boolean),lines=[];let line='';
    for(let i=0;i<words.length;i++){
      const next=line?line+' '+words[i]:words[i];
      if(ctx.measureText(next).width>w&&line){lines.push(line);line=words[i]}
      else line=next;
    }
    if(line)lines.push(line);
    const shown=lines.slice(0,maxLines);
    if(lines.length>maxLines&&shown.length)shown[shown.length-1]=shown[shown.length-1].replace(/\.*$/,'')+'...';
    ctx.textAlign='center';ctx.textBaseline='top';ctx.fillStyle='#9aa';
    for(let i=0;i<shown.length;i++)ctx.fillText(shown[i],cx,top+i*12);
    ctx.restore();
  }
  for(let i=0;i<n;i++){
    const wid=STARTER_KEYS[i],def=WDEFS[wid];
    const cx=sx+i*(cw+gap),cy=sy;
    const hover=mouseX>=cx&&mouseX<=cx+cw&&mouseY>=cy&&mouseY<=cy+ch;
    const bc=hover?'#fff':def.color;
    drawPanel(cx,cy,cw,ch,'rgba(8,16,24,0.9)',bc,hover?2:1.2,hover?1:.75);
    drawText(def.name,cx+cw/2,cy+22,13,bc,'center','middle');
    drawStarterIcon(wid,cx+cw/2,cy+54,bc,hover);
    drawText(def.type==='starter'?'PRIMARY':'CC',cx+cw/2,cy+84,10,def.color,'center','middle');
    drawCardDesc(def.desc,cx+cw/2,cy+102,cw-22,4);
    drawText('['+(i+1)+']',cx+cw/2,cy+ch-20,14,'#555','center','middle');
  }
  drawScanlines();
}
function selectWeapon(idx){
  if(idx<0||idx>=STARTER_KEYS.length)return;
  G.weapons=[createWeaponState(STARTER_KEYS[idx])];
  state='playing';startNextWave();
}
function drawPause(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('PAUSED',CX,CY-20,36,'#0ff','center','middle');
  drawText('Press ESC to Resume',CX,CY+30,16,'#888','center','middle');
}
function drawGameOver(){
  ctx.save();ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,0,W,H);ctx.restore();
  drawText('GAME OVER',CX,CY-110,36,'#f44','center','middle');
  const survived=max(0,G.wave-1);
  drawText('Waves Survived: '+survived,CX,CY-66,17,'#fff','center','middle');
  drawText('Enemies Killed: '+G.totalKills,CX,CY-44,14,'#9cf','center','middle');
  drawText('[R] Restart',CX,CY+30,12,'#888','center','middle');
}
function drawDeathFade(dt,drawFx){
  G.gameOverFade=min(1,(G.gameOverFade||0)+dt*2.8);
  if(drawFx){updateParticles(dt);drawParticles()}
  ctx.fillStyle='rgba(0,0,0,'+G.gameOverFade+')';ctx.fillRect(0,0,W,H);
  drawScanlines();
  if(G.gameOverFade>=1)state='gameover';
}

// == GAME START ==
function startGame(){
  resize();resetPlayer();recomputeStats();
  enemyBullets.clear();playerBullets.clear();particles.clear();enemies.clear();
  obsCache.clear();
  dmgNums.length=0;
  cam.x=0;cam.y=0;
  G.time=0;G.difficulty=.8;
  G.wave=0;G.waveKills=0;G.waveQuota=0;G.waveState='clear';
  G.xp=0;G.level=1;G.xpToNext=floor(200*XP_REQ_SCALE);G.levelUpQueue=0;
  G.totalKills=0;
  G.frozen=false;G.freezeTimer=0;G.killFlash=0;
  G.bannerTimer=0;G.waveBannerTimer=0;G.waveModTimer=0;G.waveModText='';
  G.gravity=0;G.windX=0;G.windY=0;
  G.pulseTimer=0;G.pulseSpeed=0;
  G.reversed=false;G.reverseTimer=0;G.reverseCD=0;
  G.pierce=false;G.echo=false;G.bounce=false;G.mirror=false;G.fragile=false;G.lucky=false;
  G.weapons=[];G.passives={};G.bossEntity=null;G._twinBoss=null;G._rocketRings=[];G._upgradeTransition=1;G.refreshAvailable=0;G._bossLaserHitCD=0;G._bossModQueue=[];G._bossSpawnPending=false;G.gameOverFade=0;
  bossLasers.length=0;
  window._staticFields=[];bowBeams.length=0;swordAftershocks.length=0;swordBossSlashes.length=0;
  currentPhase=null;lastPhaseIdx=-1;spawnTimer=1;slowTimer=0;
  state='weaponSelect';
}

// == KEY HANDLER ==
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code))e.preventDefault();
  const c=e.code;
  if(state==='dying')return;
  if(c==='Escape'){if(state==='playing')state='paused';else if(state==='paused')state='playing'}
  if(c==='Enter'&&state==='title'){startGame()}
  if(c==='KeyR'&&state==='gameover'){startGame()}
  if(state==='weaponSelect'){
    if(c==='Digit1')selectWeapon(0);if(c==='Digit2')selectWeapon(1);
    if(c==='Digit3')selectWeapon(2);
  }
  if(state==='levelUp'&&(G._upgradeTransition||0)>=.9){
    if(c==='Digit1')selectUpgrade(0);if(c==='Digit2')selectUpgrade(1);if(c==='Digit3')selectUpgrade(2);if(c==='Digit4')selectUpgrade(3);if(c==='Digit5')selectUpgrade(4);
    if(c==='KeyR'&&G.refreshAvailable>0){G.refreshAvailable--;generateUpgradeChoices()}
  }
  // Dagger recall with R
  if(c==='KeyR'&&state==='playing'){
    const dw=G.weapons.find(w=>w.id==='dagger');
    if(dw&&dw.state!=='idle')dw.state='returning';
  }
});

// == MOUSE INPUT ROUTING ==
function handleMouseDown(btn,wx,wy){
  const w=getStarterForButton(btn);
  if(!w)return;
  if(w.id==='dagger')onDaggerClick(w,wx,wy);
  else if(w.id==='sword')onSwordClick(w,wx,wy);
  else if(w.id==='bow')onBowDown(w);
}
function handleMouseUp(btn){
  const w=getStarterForButton(btn);
  if(!w)return;
  if(w.id==='bow')onBowUp(w);
}

// == MAIN LOOP ==
let lastTime=performance.now();
function frame(ts){
  requestAnimationFrame(frame);
  let dt=clamp((ts-lastTime)/1000,0,.05);lastTime=ts;

  if(state==='title'){drawTitle(dt);return}
  if(state==='paused'){drawPause();return}
  if(state==='weaponSelect'){
    if(pendingClick){
      const n=STARTER_KEYS.length;
      const cw=180,ch=200,gap=20,total=cw*n+gap*(n-1),sx=CX-total/2,sy=CY-70;
      for(let i=0;i<n;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectWeapon(i);break}}
      pendingClick=null;
    }
    drawWeaponSelect(dt);return;
  }
  if(state==='dying'){drawDeathFade(dt,true);return}
  if(state==='gameover'){
    ctx.fillStyle='#000';ctx.fillRect(0,0,W,H);
    drawGameOver();drawScanlines();return;
  }
  if(state==='levelUp'){
    // Slide-in transition
    if(G._upgradeTransition===undefined)G._upgradeTransition=1;
    G._upgradeTransition=min(1,G._upgradeTransition+dt*4);// 0.25s transition
    const t=G._upgradeTransition;
    const ease=t<1?1-Math.pow(1-t,3):1;// ease-out cubic
    ctx.fillStyle='rgba(0,0,0,'+(.62*ease)+')';ctx.fillRect(0,0,W,H);
    if(pendingClick&&t>=.9){// only accept clicks after transition mostly done
      const nc=min(5,upgradeChoices.length);
      const cw=150,ch=140,gap=12,total=cw*nc+gap*(nc-1),sx=CX-total/2,sy=CY-60;
      for(let i=0;i<nc;i++){const cx=sx+i*(cw+gap);
        if(pendingClick.x>=cx&&pendingClick.x<=cx+cw&&pendingClick.y>=sy&&pendingClick.y<=sy+ch){selectUpgrade(i);break}}
      pendingClick=null;
    }else if(pendingClick){pendingClick=null}
    drawUpgradeScreen(ease);drawScanlines();return;
  }

  // == PLAYING ==
  // Handle mouse input
  if(pendingClick&&state==='playing'){
    const wm=worldMouse();handleMouseDown(pendingClick.btn,wm.x,wm.y);pendingClick=null;
  }
  // Track mouseup for charge-based weapons.
  if(!mouseDown)handleMouseUp(0);
  if(!rightDown)handleMouseUp(2);

  // Slow-mo
  if(slowTimer>0){slowTimer-=dt;dt*=slowScale}
  G.time+=dt;
  // Kill flash decay
  G.killFlash=max(0,G.killFlash-dt);
  // Level up check
  if(G.levelUpQueue>0&&state==='playing'){generateUpgradeChoices();state='levelUp';G._upgradeTransition=0;G.refreshAvailable=1;return}

  cam.x=lerp(cam.x,player.x,8*dt);cam.y=lerp(cam.y,player.y,8*dt);
  ctx.fillStyle='rgba(0,0,0,'+CFG.trailAlpha+')';ctx.fillRect(0,0,W,H);
  updateShake();
  ctx.save();ctx.translate(-cam.x+CX+shakeX,-cam.y+CY+shakeY);

  drawGround();drawObstacles();
  updatePlayer(dt);updateWeapons(dt);
  updateEnemies(dt);
  updateBossLasers(dt);
  updateBulletPool(enemyBullets,dt,false);updateBulletPool(playerBullets,dt,true);
  updateParticles(dt);updateDmgNums(dt);updateSwordAftershocks(dt);updateSwordBossSlashes(dt);updateBowBeams(dt);
  checkCollisions();
  if(state==='dying'){
    ctx.restore();
    drawDeathFade(dt,false);
    pendingClick=null;
    return;
  }
  updateDirector(dt);

  drawBossLasers();
  drawBulletPool(enemyBullets);drawBulletPool(playerBullets);
  drawEnemies();drawPlayer();drawWeapons();drawSwordAftershocks();drawSwordBossSlashes();drawBowBeams();drawStaticFields();drawParticles();drawDmgNums();
  // Twin link beam
  if(G._twinBoss){
    const t=G._twinBoss;
    if(t[0]&&t[0].active&&t[1]&&t[1].active&&t[0].bossAI.linkBeam){
      ctx.save();const la=clamp(.4+sin(G.time*5)*.2,0,1);
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#f4a';ctx.lineWidth=6;ctx.globalAlpha=la*.3;ctx.shadowColor='#f4a';ctx.shadowBlur=15;ctx.stroke();
      ctx.beginPath();ctx.moveTo(t[0].x,t[0].y);ctx.lineTo(t[1].x,t[1].y);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.globalAlpha=la*.5;ctx.shadowBlur=8;ctx.stroke();
      // Beam damages player
      const lx=t[1].x-t[0].x,ly=t[1].y-t[0].y,ll=sqrt(lx*lx+ly*ly);
      if(ll>0){const nx=-ly/ll,ny=lx/ll;
        const px=player.x-t[0].x,py=player.y-t[0].y;
        const proj=px*lx/ll+py*ly/ll;const perp=abs(px*nx+py*ny);
        if(proj>0&&proj<ll&&perp<20)damagePlayer();}
      ctx.restore();
    }else if(t[0]&&!t[0].active&&t[1]&&t[1].active){G.bossEntity=t[1]}
  }
  // Boss portals (modifier-driven)
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._portals)return;
    for(const p of be.bossAI._portals){
      const a=clamp(p.life/.25,0,1);
      drawWarperPortal(p.x1,p.y1,a,0);
      drawWarperPortal(p.x2,p.y2,a,1.1);
    }
  });
  enemies.each(be=>{
    if(!be.active||!be.isBoss||!be.bossAI||!be.bossAI._warpTele)return;
    const wt=be.bossAI._warpTele;
    const a=1-clamp(wt.t/max(.0001,wt.maxT),0,1);
    drawWarperPortal(wt.toX,wt.toY,.35+.65*a,1.6);
    drawWarperPortal(be.x,be.y,.25+.45*a,.35);
  });
  // Rocket explosion rings
  if(G._rocketRings){for(let i=G._rocketRings.length-1;i>=0;i--){const rr=G._rocketRings[i];rr.life-=dt;if(rr.life<=0){G._rocketRings.splice(i,1);continue}
    const prog=1-rr.life/rr.maxLife;ctx.save();ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog,0,TAU);
    ctx.strokeStyle='#f80';ctx.lineWidth=3*(1-prog);ctx.globalAlpha=(1-prog)*.6;ctx.shadowColor='#f80';ctx.shadowBlur=10;ctx.stroke();
    ctx.beginPath();ctx.arc(rr.x,rr.y,rr.r*prog*.6,0,TAU);ctx.strokeStyle='#ff4';ctx.lineWidth=2*(1-prog);ctx.globalAlpha=(1-prog)*.4;ctx.stroke();ctx.restore()}}

  ctx.restore();

  // Screen space effects
  if(G.killFlash>0){ctx.save();ctx.fillStyle='#fff';ctx.globalAlpha=G.killFlash*3;ctx.fillRect(0,0,W,H);ctx.restore()}
  if(G.frozen){ctx.save();ctx.fillStyle='rgba(50,100,200,0.08)';ctx.fillRect(0,0,W,H);ctx.restore()}
  drawVignette();
  drawHUD();drawScanlines();
  pendingClick=null;
}

requestAnimationFrame(frame);
</script>
</body>
</html>
